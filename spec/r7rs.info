This is r7rs.info, produced by makeinfo version 6.8 from r7rs.txi.

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* R7RS: (r7rs).         The Revised(7) Report on Scheme.
END-INFO-DIR-ENTRY

usepackageamsmath

   usepackagehyperref

Summary
*******

The report gives a defining description of the programming language
Scheme.  Scheme is a statically scoped and properly tail recursive
dialect of the Lisp programming language [McCarthy] invented by Guy
Lewis Steele Jr. and Gerald Jay Sussman.  It was designed to have
exceptionally clear and simple semantics and few different ways to form
expressions.  A wide variety of programming paradigms, including
imperative, functional, and object-oriented styles, find convenient
expression in Scheme.

The introduction offers a brief history of the language and of the
report.

The first three chapters present the fundamental ideas of the language
and describe the notational conventions used for describing the language
and for writing programs in the language.

Chapters *note Expressions:: and *note Program structure:: describe the
syntax and semantics of expressions, definitions, programs, and
libraries.

Chapter *note Standard procedures:: describes Scheme's built-in
procedures, which include all of the language's data manipulation and
input/output primitives.

Chapter *note Formal syntax and semantics:: provides a formal syntax for
Scheme written in extended BNF, along with a formal denotational
semantics.  An example of the use of the language follows the formal
syntax and semantics.

Appendix *note Standard Libraries:: provides a list of the standard
libraries and the identifiers that they export.

Appendix *note Standard Feature Identifiers:: provides a list of
optional but standardized implementation feature names.

The report concludes with a list of references and an alphabetic index.

     _Note:_ The editors of the R^{5}RS and R^{6}RS reports are listed
     as authors of this report in recognition of the substantial
     portions of this report that are copied directly from R^{5}RS and
     R^{6}RS. There is no intended implication that those editors,
     individually or collectively, support or do not support this
     report.


File: r7rs.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Revised(7) Report on the Algorithmic Language Scheme
****************************************************


     ALEX SHINN,JOHN COWAN, ANDARTHUR A. GLECKLER (Editors)
     STEVEN GANZ              ALEXEY RADUL             OLIN SHIVERS
     AARON W. HSU             JEFFREY T. READ          ALARIC SNELL-PYM
     BRADLEY LUCIER           DAVID RUSH               GERALD J. SUSSMAN
     EMMANUEL MEDERNACH       BENJAMIN L. RUSSEL
     RICHARD KELSEY,WILLIAM CLINGER,AND JONATHAN REES
     (Editors, Revised^5 Report on the Algorithmic Language Scheme)
     MICHAEL SPERBER,R. KENT DYBVIG, MATTHEW FLATT,AND ANTON VAN STRAATEN
     (Editors, Revised^6 Report on the Algorithmic Language Scheme)



Dedicated to the memory of John McCarthy and Daniel Weinreb
large today

clearpage

Summary
*******

The report gives a defining description of the programming language
Scheme.  Scheme is a statically scoped and properly tail recursive
dialect of the Lisp programming language [McCarthy] invented by Guy
Lewis Steele Jr. and Gerald Jay Sussman.  It was designed to have
exceptionally clear and simple semantics and few different ways to form
expressions.  A wide variety of programming paradigms, including
imperative, functional, and object-oriented styles, find convenient
expression in Scheme.

The introduction offers a brief history of the language and of the
report.

The first three chapters present the fundamental ideas of the language
and describe the notational conventions used for describing the language
and for writing programs in the language.

Chapters *note Expressions:: and *note Program structure:: describe the
syntax and semantics of expressions, definitions, programs, and
libraries.

Chapter *note Standard procedures:: describes Scheme's built-in
procedures, which include all of the language's data manipulation and
input/output primitives.

Chapter *note Formal syntax and semantics:: provides a formal syntax for
Scheme written in extended BNF, along with a formal denotational
semantics.  An example of the use of the language follows the formal
syntax and semantics.

Appendix *note Standard Libraries:: provides a list of the standard
libraries and the identifiers that they export.

Appendix *note Standard Feature Identifiers:: provides a list of
optional but standardized implementation feature names.

The report concludes with a list of references and an alphabetic index.

     _Note:_ The editors of the R^{5}RS and R^{6}RS reports are listed
     as authors of this report in recognition of the substantial
     portions of this report that are copied directly from R^{5}RS and
     R^{6}RS. There is no intended implication that those editors,
     individually or collectively, support or do not support this
     report.

Contents
********

* Menu:

* Introduction::
* Overview of Scheme::
* Lexical conventions::
* Basic concepts::
* Expressions::
* Program structure::
* Standard procedures::
* Formal syntax and semantics::
* Standard Libraries::
* Standard Feature Identifiers::
* Language changes::
* Additional material::
* Example::
* Bibliography::
* Index::


File: r7rs.info,  Node: Introduction,  Next: Overview of Scheme,  Prev: Top,  Up: Top

Introduction
************

* Menu:

* Background::
* Acknowledgments::

Programming languages should be designed not by piling feature on top of
feature, but by removing the weaknesses and restrictions that make
additional features appear necessary.  Scheme demonstrates that a very
small number of rules for forming expressions, with no restrictions on
how they are composed, suffice to form a practical and efficient
programming language that is flexible enough to support most of the
major programming paradigms in use today.

Scheme was one of the first programming languages to incorporate
first-class procedures as in the lambda calculus, thereby proving the
usefulness of static scope rules and block structure in a dynamically
typed language.  Scheme was the first major dialect of Lisp to
distinguish procedures from lambda expressions and symbols, to use a
single lexical environment for all variables, and to evaluate the
operator position of a procedure call in the same way as an operand
position.  By relying entirely on procedure calls to express iteration,
Scheme emphasized the fact that tail-recursive procedure calls are
essentially GOTOs that pass arguments, thus allowing a programming style
that is both coherent and efficient.  Scheme was the first widely used
programming language to embrace first-class escape procedures, from
which all previously known sequential control structures can be
synthesized.  A subsequent version of Scheme introduced the concept of
exact and inexact numbers, an extension of Common Lisp's generic
arithmetic.  More recently, Scheme became the first programming language
to support hygienic macros, which permit the syntax of a
block-structured language to be extended in a consistent and reliable
manner.


File: r7rs.info,  Node: Background,  Next: Acknowledgments,  Prev: Introduction,  Up: Introduction

Background
==========

The first description of Scheme was written in 1975 [Scheme75].  A
revised report [Scheme78] appeared in 1978, which described the
evolution of the language as its MIT implementation was upgraded to
support an innovative compiler [Rabbit].  Three distinct projects began
in 1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and
Indiana University [Rees82], [MITScheme], [Scheme311].  An introductory
computer science textbook using Scheme was published in 1984 [SICP].

As Scheme became more widespread, local dialects began to diverge until
students and researchers occasionally found it difficult to understand
code written at other sites.  Fifteen representatives of the major
implementations of Scheme therefore met in October 1984 to work toward a
better and more widely accepted standard for Scheme.  Their report, the
RRRS [RRRS], was published at MIT and Indiana University in the summer
of 1985.  Further revision took place in the spring of 1986, resulting
in the R^{3}RS [R3RS]. Work in the spring of 1988 resulted in R^{4}RS
[R4RS], which became the basis for the IEEE Standard for the Scheme
Programming Language in 1991 [IEEEScheme].  In 1998, several additions
to the IEEE standard, including high-level hygienic macros, multiple
return values, and 'eval', were finalized as the R^{5}RS [R5RS].

In the fall of 2006, work began on a more ambitious standard, including
many new improvements and stricter requirements made in the interest of
improved portability.  The resulting standard, the R^{6}RS, was
completed in August 2007 [R6RS], and was organized as a core language
and set of mandatory standard libraries.  Several new implementations of
Scheme conforming to it were created.  However, most existing R^{5}RS
implementations (even excluding those which are essentially
unmaintained) did not adopt R^{6}RS, or adopted only selected parts of
it.

In consequence, the Scheme Steering Committee decided in August 2009 to
divide the standard into two separate but compatible languages -- a
"small" language, suitable for educators, researchers, and users of
embedded languages, focused on R^{5}RS compatibility, and a "large"
language focused on the practical needs of mainstream software
development, intended to become a replacement for R^{6}RS. The present
report describes the "small" language of that effort: therefore it
cannot be considered in isolation as the successor to R^{6}RS.




We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee.  In
particular, we encourage implementers of Scheme to use this report as a
starting point for manuals and other documentation, modifying it as
necessary.


File: r7rs.info,  Node: Acknowledgments,  Prev: Background,  Up: Introduction

Acknowledgments
===============

We would like to thank the members of the Steering Committee, William
Clinger, Marc Feeley, Chris Hanson, Jonathan Rees, and Olin Shivers, for
their support and guidance.

This report is very much a community effort, and we'd like to thank
everyone who provided comments and feedback, including the following
people: David Adler, Eli Barzilay, Taylan Ulrich Bayirli/Kammer, Marco
Benelli, Pierpaolo Bernardi, Peter Bex, Per Bothner, John Boyle, Taylor
Campbell, Raffael Cavallaro, Ray Dillinger, Biep Durieux, Sztefan
Edwards, Helmut Eller, Justin Ethier, Jay Reynolds Freeman, Tony
Garnock-Jones, Alan Manuel Gloria, Steve Hafner, Sven Hartrumpf, Brian
Harvey, Moritz Heidkamp, Jean-Michel Hufflen, Aubrey Jaffer, Takashi
Kato, Shiro Kawai, Richard Kelsey, Oleg Kiselyov, Pjotr Kourzanov,
Jonathan Kraut, Daniel Krueger, Christian Stigen Larsen, Noah Lavine,
Stephen Leach, Larry D. Lee, Kun Liang, Thomas Lord, Vincent Stewart
Manis, Perry Metzger, Michael Montague, Mikael More, Vitaly Magerya,
Vincent Manis, Vassil Nikolov, Joseph Wayne Norton, Yuki Okumura, Daichi
Oohashi, Jeronimo Pellegrini, Jussi Piitulainen, Alex Queiroz, Jim Rees,
Grant Rettke, Andrew Robbins, Devon Schudy, Bakul Shah, Robert Smith,
Arthur Smyles, Michael Sperber, John David Stone, Jay Sulzberger,
Malcolm Tredinnick, Sam Tobin-Hochstadt, Andre van Tonder, Daniel
Villeneuve, Denis Washington, Alan Watson, Mark H. Weaver, G"oran
Weinholt, David A. Wheeler, Andy Wingo, James Wise, J"org F.
Wittenberger, Kevin A. Wortman, Sascha Ziemann.

In addition we would like to thank all the past editors, and the people
who helped them in turn: Hal Abelson, Norman Adams, David Bartley, Alan
Bawden, Michael Blair, Gary Brooks, George Carrette, Andy Cromarty,
Pavel Curtis, Jeff Dalton, Olivier Danvy, Ken Dickey, Bruce Duba, Robert
Findler, Andy Freeman, Richard Gabriel, Yekta G"ursel, Ken Haase, Robert
Halstead, Robert Hieb, Paul Hudak, Morry Katz, Eugene Kohlbecker, Chris
Lindblad, Jacob Matthews, Mark Meyer, Jim Miller, Don Oxley, Jim
Philbin, Kent Pitman, John Ramsdell, Guillermo Rozas, Mike Shaff,
Jonathan Shapiro, Guy Steele, Julie Sussman, Perry Wagle, Mitchel Wand,
Daniel Weise, Henry Wu, and Ozan Yigit.  We thank Carol Fessenden,
Daniel Friedman, and Christopher Haynes for permission to use text from
the Scheme 311 version 4 reference manual.  We thank Texas Instruments,
Inc.  for permission to use text from the _TI Scheme Language Reference
Manual_ [TImanual85].  We gladly acknowledge the influence of manuals
for MIT Scheme [MITScheme], T [Rees84], Scheme 84 [Scheme84], Common
Lisp [CLtL], and Algol 60 [Naur63], as well as the following SRFIs: 0,
1, 4, 6, 9, 11, 13, 16, 30, 34, 39, 43, 46, 62, and 87, all of which are
available at <http://srfi.schemers.org>.




File: r7rs.info,  Node: Overview of Scheme,  Next: Lexical conventions,  Prev: Introduction,  Up: Top

1 Overview of Scheme
********************

* Menu:

* Semantics::
* Syntax::
* Notation and terminology::


File: r7rs.info,  Node: Semantics,  Next: Syntax,  Prev: Overview of Scheme,  Up: Overview of Scheme

1.1 Semantics
=============

This section gives an overview of Scheme's semantics.  A detailed
informal semantics is the subject of chapters *note Basic concepts::
through *note Standard procedures::.  For reference purposes, section
*note Formal semantics:: provides a formal semantics of Scheme.

Scheme is a statically scoped programming language.  Each use of a
variable is associated with a lexically apparent binding of that
variable.

Scheme is a dynamically typed language.  Types are associated with
values (also called objects) rather than with variables.  Statically
typed languages, by contrast, associate types with variables and
expressions as well as with values.

All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent.  No Scheme object
is ever destroyed.  The reason that implementations of Scheme do not
(usually!)  run out of storage is that they are permitted to reclaim the
storage occupied by an object if they can prove that the object cannot
possibly matter to any future computation.

Implementations of Scheme are required to be properly tail-recursive.
This allows the execution of an iterative computation in constant space,
even if the iterative computation is described by a syntactically
recursive procedure.  Thus with a properly tail-recursive
implementation, iteration can be expressed using the ordinary
procedure-call mechanics, so that special iteration constructs are
useful only as syntactic sugar.  See section *note Proper tail
recursion::.

Scheme procedures are objects in their own right.  Procedures can be
created dynamically, stored in data structures, returned as results of
procedures, and so on.

One distinguishing feature of Scheme is that continuations, which in
most other languages only operate behind the scenes, also have
"first-class" status.  Continuations are useful for implementing a wide
variety of advanced control constructs, including non-local exits,
backtracking, and coroutines.  See section *note Control features::.

Arguments to Scheme procedures are always passed by value, which means
that the actual argument expressions are evaluated before the procedure
gains control, regardless of whether the procedure needs the result of
the evaluation.

Scheme's model of arithmetic is designed to remain as independent as
possible of the particular ways in which numbers are represented within
a computer.  In Scheme, every integer is a rational number, every
rational is a real, and every real is a complex number.  Thus the
distinction between integer and real arithmetic, so important to many
programming languages, does not appear in Scheme.  In its place is a
distinction between exact arithmetic, which corresponds to the
mathematical ideal, and inexact arithmetic on approximations.  Exact
arithmetic is not limited to integers.


File: r7rs.info,  Node: Syntax,  Next: Notation and terminology,  Prev: Semantics,  Up: Overview of Scheme

1.2 Syntax
==========

Scheme, like most dialects of Lisp, employs a fully parenthesized prefix
notation for programs and other data; the grammar of Scheme generates a
sublanguage of the language used for data.  An important consequence of
this simple, uniform representation is that Scheme programs and data can
easily be treated uniformly by other Scheme programs.  For example, the
'eval' procedure evaluates a Scheme program expressed as data.

The 'read' procedure performs syntactic as well as lexical decomposition
of the data it reads.  The 'read' procedure parses its input as data
(section *note External representation::), not as program.

The formal syntax of Scheme is described in section *note Formal
syntax::.


File: r7rs.info,  Node: Notation and terminology,  Prev: Syntax,  Up: Overview of Scheme

1.3 Notation and terminology
============================

* Menu:

* Base and optional features::
* Error situations and unspecified behavior::
* Entry format::
* Evaluation examples::
* Naming conventions::


File: r7rs.info,  Node: Base and optional features,  Next: Error situations and unspecified behavior,  Prev: Notation and terminology,  Up: Notation and terminology

1.3.1 Base and optional features
--------------------------------

Every identifier defined in this report appears in one or more of
several "libraries".  Identifiers defined in the "base library" are not
marked specially in the body of the report.  This library includes the
core syntax of Scheme and generally useful procedures that manipulate
data.  For example, the variable 'abs' is bound to a procedure of one
argument that computes the absolute value of a number, and the variable
'+' is bound to a procedure that computes sums.  The full list all the
standard libraries and the identifiers they export is given in Appendix
*note Standard Libraries::.

All implementations of Scheme:

   * Must provide the base library and all the identifiers exported from
     it.

   * May provide or omit the other libraries given in this report, but
     each library must either be provided in its entirety, exporting no
     additional identifiers, or else omitted altogether.

   * May provide other libraries not described in this report.

   * May also extend the function of any identifier in this report,
     provided the extensions are not in conflict with the language
     reported here.

   * Must support portable code by providing a mode of operation in
     which the lexical syntax does not conflict with the lexical syntax
     described in this report.


File: r7rs.info,  Node: Error situations and unspecified behavior,  Next: Entry format,  Prev: Base and optional features,  Up: Notation and terminology

1.3.2 Error situations and unspecified behavior
-----------------------------------------------

When speaking of an error situation, this report uses the phrase "an
error is signaled" to indicate that implementations must detect and
report the error.  An error is signaled by raising a non-continuable
exception, as if by the procedure 'raise' as described in section *note
Exceptions::.  The object raised is implementation-dependent and need
not be distinct from objects previously used for the same purpose.  In
addition to errors signaled in situations described in this report,
programmers can signal their own errors and handle signaled errors.

The phrase "an error that satisfies _predicate_ is signaled" means that
an error is signaled as above.  Furthermore, if the object that is
signaled is passed to the specified predicate (such as 'file-error?' or
'read-error?'), the predicate returns #t.

If such wording does not appear in the discussion of an error, then
implementations are not required to detect or report the error, though
they are encouraged to do so.  Such a situation is sometimes, but not
always, referred to with the phrase "an error."  In such a situation, an
implementation may or may not signal an error; if it does signal an
error, the object that is signaled may or may not satisfy the predicates
'error-object?', 'file-error?', or 'read-error?'.  Alternatively,
implementations may provide non-portable extensions.

For example, it is an error for a procedure to be passed an argument of
a type that the procedure is not explicitly specified to handle, even
though such domain errors are seldom mentioned in this report.
Implementations may signal an error, extend a procedure's domain of
definition to include such arguments, or fail catastrophically.

This report uses the phrase "may report a violation of an implementation
restriction" to indicate circumstances under which an implementation is
permitted to report that it is unable to continue execution of a correct
program because of some restriction imposed by the implementation.
Implementation restrictions are discouraged, but implementations are
encouraged to report violations of implementation restrictions.

For example, an implementation may report a violation of an
implementation restriction if it does not have enough storage to run a
program, or if an arithmetic operation would produce an exact number
that is too large for the implementation to represent.

If the value of an expression is said to be "unspecified," then the
expression must evaluate to some object without signaling an error, but
the value depends on the implementation; this report explicitly does not
say what value is returned.

Finally, the words and phrases "must," "must not," "shall," "shall not,"
"should," "should not," "may," "required," "recommended," and
"optional," although not capitalized in this report, are to be
interpreted as described in RFC 2119 [rfc2119].  They are used only with
reference to implementer or implementation behavior, not with reference
to programmer or program behavior.


File: r7rs.info,  Node: Entry format,  Next: Evaluation examples,  Prev: Error situations and unspecified behavior,  Up: Notation and terminology

1.3.3 Entry format
------------------

Chapters *note Expressions:: and *note Standard procedures:: are
organized into entries.  Each entry describes one language feature or a
group of related features, where a feature is either a syntactic
construct or a procedure.  An entry begins with one or more header lines
of the form

 -- CATEGORY: TEMPLATE

for identifiers in the base library, or

 -- NAME library CATEGORY: TEMPLATE

where NAME is the short name of a library as defined in Appendix *note
Standard Libraries::.

If CATEGORY is "syntax," the entry describes an expression type, and the
template gives the syntax of the expression type.  Components of
expressions are designated by syntactic variables, which are written
using angle brackets, for example <expression> and <variable>.
Syntactic variables are intended to denote segments of program text; for
example, <expression> stands for any string of characters which is a
syntactically valid expression.  The notation

 <thing1> ...

indicates zero or more occurrences of a <thing>, and

 <thing1> <thing2> ...

indicates one or more occurrences of a <thing>.

If CATEGORY is "auxiliary syntax," then the entry describes a syntax
binding that occurs only as part of specific surrounding expressions.
Any use as an independent syntactic construct or variable is an error.

If CATEGORY is "procedure," then the entry describes a procedure, and
the header line gives a template for a call to the procedure.  Argument
names in the template are ITALICIZED.  Thus the header line

 -- procedure: (vector-ref VECTOR K)

indicates that the procedure bound to the vector-ref variable takes two
arguments, a vector VECTOR and an exact non-negative integer K (see
below).  The header lines


 -- procedure: (make-vector K)

 -- procedure: (make-vector K FILL)

indicate that the make-vector procedure must be defined to take either
one or two arguments.

It is an error for a procedure to be presented with an argument that it
is not specified to handle.  For succinctness, we follow the convention
that if an argument name is also the name of a type listed in section
*note Disjointness of types::, then it is an error if that argument is
not of the named type.  For example, the header line for vector-ref
given above dictates that the first argument to vector-ref is a vector.
The following naming conventions also imply type restrictions:

     ALIST
          association list (list of pairs)
     BOOLEAN
          boolean value (#t or #f)
     BYTE
          exact integer 0 <= byte < 256
     BYTEVECTOR
          bytevector
     CHAR
          character
     END
          exact non-negative integer
     K, K1, ... KJ, ...
          exact non-negative integer
     LETTER
          alphabetic character
     LIST, LIST1, ... LISTJ, ...
          list (see section *note Pairs and lists::)
     N, N1, ... NJ, ...
          integer
     OBJ
          any object
     PAIR
          pair
     PORT
          port
     PROC
          procedure
     Q, Q1, ... QJ, ...
          rational number
     START
          exact non-negative integer
     STRING
          string
     SYMBOL
          symbol
     THUNK
          zero-argument procedure
     VECTOR
          vector
     X, X1, ... XJ, ...
          real number
     Y, Y1, ... YJ, ...
          real number
     Z, Z1, ... ZJ, ...
          complex number

The names START and END are used as indexes into strings, vectors, and
bytevectors.  Their use implies the following:

   * It is an error if START is greater than END.

   * It is an error if END is greater than the length of the string,
     vector, or bytevector.

   * If START is omitted, it is assumed to be zero.

   * If END is omitted, it assumed to be the length of the string,
     vector, or bytevector.

   * The index START is always inclusive and the index END is always
     exclusive.  As an example, consider a string.  If START and END are
     the same, an empty substring is referred to, and if START is zero
     and END is the length of STRING, then the entire string is referred
     to.


File: r7rs.info,  Node: Evaluation examples,  Next: Naming conventions,  Prev: Entry format,  Up: Notation and terminology

1.3.4 Evaluation examples
-------------------------

The symbol "=>" used in program examples is read "evaluates to."  For
example,


     (* 5 8)                                ==>  40


means that the expression (* 5 8) evaluates to the object 40.  Or, more
precisely: the expression given by the sequence of characters "(* 5 8)"
evaluates, in an environment containing the base library, to an object
that can be represented externally by the sequence of characters "40."
See section *note External representations:: for a discussion of
external representations of objects.


File: r7rs.info,  Node: Naming conventions,  Prev: Evaluation examples,  Up: Notation and terminology

1.3.5 Naming conventions
------------------------

By convention, '?' is the final character of the names of procedures
that always return a boolean value.  Such procedures are called
"predicates".  Predicates are generally understood to be side-effect
free, except that they may raise an exception when passed the wrong type
of argument.

Similarly, '!' is the final character of the names of procedures that
store values into previously allocated locations (see section *note
Storage model::).  Such procedures are called "mutation procedures".
The value returned by a mutation procedure is unspecified.

By convention, "'->'" appears within the names of procedures that take
an object of one type and return an analogous object of another type.
For example, 'list->vector' takes a list and returns a vector whose
elements are the same as those of the list.

A "command" is a procedure that does not return useful values to its
continuation.

A "thunk" is a procedure that does not accept arguments.


File: r7rs.info,  Node: Lexical conventions,  Next: Basic concepts,  Prev: Overview of Scheme,  Up: Top

2 Lexical conventions
*********************

* Menu:

* Identifiers::
* Whitespace and comments::
* Other notations::
* Datum labels::

This section gives an informal account of some of the lexical
conventions used in writing Scheme programs.  For a formal syntax of
Scheme, see section *note Formal syntax::.


File: r7rs.info,  Node: Identifiers,  Next: Whitespace and comments,  Prev: Lexical conventions,  Up: Lexical conventions

2.1 Identifiers
===============

An identifier is any sequence of letters, digits, and "extended
identifier characters" provided that it does not have a prefix which is
a valid number.  However, the '.' token (a single period) used in the
list syntax is not an identifier.

All implementations of Scheme must support the following extended
identifier characters:


     ! $ % & * + - . / : < = > ? @ ^ _ ~

Alternatively, an identifier can be represented by a sequence of zero or
more characters enclosed within vertical lines ('|'), analogous to
string literals.  Any character, including whitespace characters, but
excluding the backslash and vertical line characters, can appear
verbatim in such an identifier.  In addition, characters can be
specified using either an <inline hex escape> or the same escapes
available in strings.

For example, the identifier |H\x65;llo| is the same identifier as Hello,
and in an implementation that supports the appropriate Unicode character
the identifier |\x3BB;| is the same as the identifier lambda.  What is
more, |\t\t| and |\x9;\x9;| are the same.  Note that || is a valid
identifier that is different from any other identifier.

Here are some examples of identifiers:


     ...                      +
     +soup+                   <=?
     ->string                 a34kTMNs
     lambda                   list->vector
     q                        V17a
     |two words|              |two\x20;words|
     the-word-recursion-has-many-meanings


See section *note Lexical structure:: for the formal syntax of
identifiers.

Identifiers have two uses within Scheme programs:

   * Any identifier can be used as a variable or as a syntactic keyword
     (see sections *note Variables; syntactic keywords; and regions::
     and *note Macros::).

   * When an identifier appears as a literal or within a literal (see
     section *note Literal expressions::), it is being used to denote a
     _symbol_ (see section *note Symbols::).

In contrast with earlier revisions of the report [R5RS], the syntax
distinguishes between upper and lower case in identifiers and in
characters specified using their names.  However, it does not
distinguish between upper and lower case in numbers, nor in <inline hex
escapes> used in the syntax of identifiers, characters, or strings.
None of the identifiers defined in this report contain upper-case
characters, even when they appear to do so as a result of the
English-language convention of capitalizing the first word of a
sentence.

The following directives give explicit control over case folding.

''#!fold-case ''#!no-fold-case

These directives can appear anywhere comments are permitted (see section
*note Whitespace and comments::) but must be followed by a delimiter.
They are treated as comments, except that they affect the reading of
subsequent data from the same port.  The ''#!fold-case directive causes
subsequent identifiers and character names to be case-folded as if by
'string-foldcase' (see section *note Strings::).  It has no effect on
character literals.  The ''#!no-fold-case directive causes a return to
the default, non-folding behavior.


File: r7rs.info,  Node: Whitespace and comments,  Next: Other notations,  Prev: Identifiers,  Up: Lexical conventions

2.2 Whitespace and comments
===========================

"Whitespace" characters include the space, tab, and newline characters.
(Implementations may provide additional whitespace characters such as
page break.)  Whitespace is used for improved readability and as
necessary to separate tokens from each other, a token being an
indivisible lexical unit such as an identifier or number, but is
otherwise insignificant.  Whitespace can occur between any two tokens,
but not within a token.  Whitespace occurring inside a string or inside
a symbol delimited by vertical lines is significant.

The lexical syntax includes several comment forms.  Comments are treated
exactly like whitespace.

A semicolon (;) indicates the start of a line comment.  The comment
continues to the end of the line on which the semicolon appears.

Another way to indicate a comment is to prefix a <datum> (cf. section
*note External representation::) with #; and optional <whitespace>.  The
comment consists of the comment prefix #;, the space, and the <datum>
together.  This notation is useful for "commenting out" sections of
code.

Block comments are indicated with properly nested #| and |# pairs.


     #|
        The FACT procedure computes the factorial
        of a non-negative integer.
     |#
     (define fact
       (lambda (n)
         (if (= n 0)
             #;(= n 1)
             1        ;Base case: return 1
             (* n (fact (- n 1))))))



File: r7rs.info,  Node: Other notations,  Next: Datum labels,  Prev: Whitespace and comments,  Up: Lexical conventions

2.3 Other notations
===================

For a description of the notations used for numbers, see section *note
Numbers::.

. + -
     These are used in numbers, and can also occur anywhere in an
     identifier.  A delimited plus or minus sign by itself is also an
     identifier.  A delimited period (not occurring within a number or
     identifier) is used in the notation for pairs (section *note Pairs
     and lists::), and to indicate a rest-parameter in a formal
     parameter list (section *note Procedures::).  Note that a sequence
     of two or more periods _is_ an identifier.

( )
     Parentheses are used for grouping and to notate lists (section
     *note Pairs and lists::).

'
     The apostrophe (single quote) character is used to indicate literal
     data (section *note Literal expressions::).

`
     The grave accent (backquote) character is used to indicate partly
     constant data (section *note Quasiquotation::).

, ,@
     The character comma and the sequence comma at-sign are used in
     conjunction with quasiquotation (section *note Quasiquotation::).

"
     The quotation mark character is used to delimit strings (section
     *note Strings::).

\
     Backslash is used in the syntax for character constants (section
     *note Characters::) and as an escape character within string
     constants (section *note Strings::) and identifiers (section *note
     Lexical structure::).

[ ] { }
     Left and right square and curly brackets (braces) are reserved for
     possible future extensions to the language.

#
     The number sign is used for a variety of purposes depending on the
     character that immediately follows it:

#t #f
     These are the boolean constants (section *note Booleans::), along
     with the alternatives #true and #false.

#\
     This introduces a character constant (section *note Characters::).

#(
     This introduces a vector constant (section *note Vectors::).
     Vector constants are terminated by ) .

# u8(
     This introduces a bytevector constant (section *note
     Bytevectors::).  Bytevector constants are terminated by ) .

#e #i #b #o #d #x
     These are used in the notation for numbers (section *note Syntax of
     numerical constants::).

SHARP<n>= SHARP<n>#
     These are used for labeling and referencing other literal data
     (section *note Datum labels::).


File: r7rs.info,  Node: Datum labels,  Prev: Other notations,  Up: Lexical conventions

2.4 Datum labels
================

 -- lexical syntax: SHARP<n>=<datum>

 -- lexical syntax: SHARP<n>#

     The lexical syntax SHARP<n>=<datum> reads the same as <datum>, but
     also results in <datum> being labelled by <n>.  It is an error if
     <n> is not a sequence of digits.

     The lexical syntax SHARP<n># serves as a reference to some object
     labelled by SHARP<n>=; the result is the same object as the
     SHARP<n>= (see section *note Equivalence predicates::).

     Together, these syntaxes permit the notation of structures with
     shared or circular substructure.

     (let ((x (list 'a 'b 'c)))
       (set-cdr! (cddr x) x)
       x)                                   ==> #0=(a b c . #0#)


     The scope of a datum label is the portion of the outermost datum in
     which it appears that is to the right of the label.  Consequently,
     a reference SHARP<n># can occur only after a label SHARP<n>=; it is
     an error to attempt a forward reference.  In addition, it is an
     error if the reference appears as the labelled object itself (as in
     SHARP<n>= SHARP<n>#), because the object labelled by SHARP<n>= is
     not well defined in this case.

     It is an error for a <program> or <library> to include circular
     references except in literals.  In particular, it is an error for
     'quasiquote' (section *note Quasiquotation::) to contain them.

     #1=(begin (display #\x) #1#)
                                            ==> _error_



File: r7rs.info,  Node: Basic concepts,  Next: Expressions,  Prev: Lexical conventions,  Up: Top

3 Basic concepts
****************

* Menu:

* Variables; syntactic keywords; and regions::
* Disjointness of types::
* External representations::
* Storage model::
* Proper tail recursion::


File: r7rs.info,  Node: Variables; syntactic keywords; and regions,  Next: Disjointness of types,  Prev: Basic concepts,  Up: Basic concepts

3.1 Variables; syntactic keywords; and regions
==============================================

An identifier can name either a type of syntax or a location where a
value can be stored.  An identifier that names a type of syntax is
called a _syntactic keyword_ and is said to be _bound_ to a transformer
for that syntax.  An identifier that names a location is called a
_variable_ and is said to be _bound_ to that location.  The set of all
visible bindings in effect at some point in a program is known as the
_environment_ in effect at that point.  The value stored in the location
to which a variable is bound is called the variable's value.  By abuse
of terminology, the variable is sometimes said to name the value or to
be bound to the value.  This is not quite accurate, but confusion rarely
results from this practice.

Certain expression types are used to create new kinds of syntax and to
bind syntactic keywords to those new syntaxes, while other expression
types create new locations and bind variables to those locations.  These
expression types are called _binding constructs_.

Those that bind syntactic keywords are listed in section *note Macros::.
The most fundamental of the variable binding constructs is the 'lambda'
expression, because all other variable binding constructs (except
top-level bindings) can be explained in terms of 'lambda' expressions.
The other variable binding constructs are 'let', 'let*', 'letrec',
'letrec*', 'let-values', 'let*-values', and 'do' expressions (see
sections *note Procedures::, *note Binding constructs::, and *note
Iteration::).

Scheme is a language with block structure.  To each place where an
identifier is bound in a program there corresponds a "region" of the
program text within which the binding is visible.  The region is
determined by the particular binding construct that establishes the
binding; if the binding is established by a 'lambda' expression, for
example, then its region is the entire 'lambda' expression.  Every
mention of an identifier refers to the binding of the identifier that
established the innermost of the regions containing the use.  If there
is no binding of the identifier whose region contains the use, then the
use refers to the binding for the variable in the global environment, if
any (chapters *note Expressions:: and *note Standard procedures::); if
there is no binding for the identifier, it is said to be "unbound".


File: r7rs.info,  Node: Disjointness of types,  Next: External representations,  Prev: Variables; syntactic keywords; and regions,  Up: Basic concepts

3.2 Disjointness of types
=========================

No object satisfies more than one of the following predicates:


     boolean?          bytevector?
     char?             eof-object?
     null?             number?
     pair?             port?
     procedure?        string?
     symbol?           vector?


and all predicates created by 'define-record-type'.

These predicates define the types _boolean, bytevector, character_, the
empty list object, _eof-object, number, pair, port, procedure, string,
symbol, vector_, and all record types.

Although there is a separate boolean type, any Scheme value can be used
as a boolean value for the purpose of a conditional test.  As explained
in section *note Booleans::, all values count as true in such a test
except for #f.  This report uses the word "true" to refer to any Scheme
value except #f, and the word "false" to refer to #f.


File: r7rs.info,  Node: External representations,  Next: Storage model,  Prev: Disjointness of types,  Up: Basic concepts

3.3 External representations
============================

An important concept in Scheme (and Lisp) is that of the _external
representation_ of an object as a sequence of characters.  For example,
an external representation of the integer 28 is the sequence of
characters "28", and an external representation of a list consisting of
the integers 8 and 13 is the sequence of characters "(8 13)".

The external representation of an object is not necessarily unique.  The
integer 28 also has representations "#e28.000" and "#x1c", and the list
in the previous paragraph also has the representations "( 08 13 )" and
"(8 . (13 . ()))" (see section *note Pairs and lists::).

Many objects have standard external representations, but some, such as
procedures, do not have standard representations (although particular
implementations may define representations for them).

An external representation can be written in a program to obtain the
corresponding object (see 'quote', section *note Literal expressions::).

External representations can also be used for input and output.  The
procedure 'read' (section *note Input::) parses external
representations, and the procedure 'write' (section *note Output::)
generates them.  Together, they provide an elegant and powerful
input/output facility.

Note that the sequence of characters "(+ 2 6)" is _not_ an external
representation of the integer 8, even though it _is_ an expression
evaluating to the integer 8; rather, it is an external representation of
a three-element list, the elements of which are the symbol + and the
integers 2 and 6.  Scheme's syntax has the property that any sequence of
characters that is an expression is also the external representation of
some object.  This can lead to confusion, since it is not always obvious
out of context whether a given sequence of characters is intended to
denote data or program, but it is also a source of power, since it
facilitates writing programs such as interpreters and compilers that
treat programs as data (or vice versa).

The syntax of external representations of various kinds of objects
accompanies the description of the primitives for manipulating the
objects in the appropriate sections of chapter *note Standard
procedures::.


File: r7rs.info,  Node: Storage model,  Next: Proper tail recursion,  Prev: External representations,  Up: Basic concepts

3.4 Storage model
=================

Variables and objects such as pairs, strings, vectors, and bytevectors
implicitly denote locations or sequences of locations.  A string, for
example, denotes as many locations as there are characters in the
string.  A new value can be stored into one of these locations using the
string-set! procedure, but the string continues to denote the same
locations as before.

An object fetched from a location, by a variable reference or by a
procedure such as 'car', 'vector-ref', or 'string-ref', is equivalent in
the sense of 'eqv?' (section *note Equivalence predicates::) to the
object last stored in the location before the fetch.

Every location is marked to show whether it is in use.  No variable or
object ever refers to a location that is not in use.

Whenever this report speaks of storage being newly allocated for a
variable or object, what is meant is that an appropriate number of
locations are chosen from the set of locations that are not in use, and
the chosen locations are marked to indicate that they are now in use
before the variable or object is made to denote them.  Notwithstanding
this, it is understood that the empty list cannot be newly allocated,
because it is a unique object.  It is also understood that empty
strings, empty vectors, and empty bytevectors, which contain no
locations, may or may not be newly allocated.

Every object that denotes locations is either mutable or immutable.
Literal constants, the strings returned by 'symbol->string', and
possibly the environment returned by 'scheme-report-environment' are
immutable objects.  All objects created by the other procedures listed
in this report are mutable.  It is an error to attempt to store a new
value into a location that is denoted by an immutable object.

These locations are to be understood as conceptual, not physical.
Hence, they do not necessarily correspond to memory addresses, and even
if they do, the memory address might not be constant.

     _Rationale:_ In many systems it is desirable for constants (i.e.
     the values of literal expressions) to reside in read-only memory.
     Making it an error to alter constants permits this implementation
     strategy, while not requiring other systems to distinguish between
     mutable and immutable objects.


File: r7rs.info,  Node: Proper tail recursion,  Prev: Storage model,  Up: Basic concepts

3.5 Proper tail recursion
=========================

Implementations of Scheme are required to be _properly tail-recursive_.
Procedure calls that occur in certain syntactic contexts defined below
are _tail calls_.  A Scheme implementation is properly tail-recursive if
it supports an unbounded number of active tail calls.  A call is
_active_ if the called procedure might still return.  Note that this
includes calls that might be returned from either by the current
continuation or by continuations captured earlier by
'call-with-current-continuation' that are later invoked.  In the absence
of captured continuations, calls could return at most once and the
active calls would be those that had not yet returned.  A formal
definition of proper tail recursion can be found in
[propertailrecursion].

     _Rationale:_

     Intuitively, no space is needed for an active tail call because the
     continuation that is used in the tail call has the same semantics
     as the continuation passed to the procedure containing the call.
     Although an improper implementation might use a new continuation in
     the call, a return to this new continuation would be followed
     immediately by a return to the continuation passed to the
     procedure.  A properly tail-recursive implementation returns to
     that continuation directly.

     Proper tail recursion was one of the central ideas in Steele and
     Sussman's original version of Scheme.  Their first Scheme
     interpreter implemented both functions and actors.  Control flow
     was expressed using actors, which differed from functions in that
     they passed their results on to another actor instead of returning
     to a caller.  In the terminology of this section, each actor
     finished with a tail call to another actor.

     Steele and Sussman later observed that in their interpreter the
     code for dealing with actors was identical to that for functions
     and thus there was no need to include both in the language.

A _tail call_ is a procedure call that occurs in a _tail context_.  Tail
contexts are defined inductively.  Note that a tail context is always
determined with respect to a particular lambda expression.

   * The last expression within the body of a lambda expression, shown
     as <tail expression> below, occurs in a tail context.  The same is
     true of all the bodies of 'case-lambda' expressions.

     (lambda <formals>
       <definition>* <expression>* <tail expression>)

     (case-lambda (<formals> <tail body>)*)



   * If one of the following expressions is in a tail context, then the
     subexpressions shown as <tail expression> are in a tail context.
     These were derived from rules in the grammar given in chapter *note
     Formal syntax and semantics:: by replacing some occurrences of
     <body> with <tail body>, some occurrences of <expression> with
     <tail expression>, and some occurrences of <sequence> with <tail
     sequence>.  Only those rules that contain tail contexts are shown
     here.

     (if <expression> <tail expression> <tail expression>)
     (if <expression> <tail expression>)

     (cond <cond clause>+)
     (cond <cond clause>* (else <tail sequence>))

     (case <expression>
       <case clause>+)
     (case <expression>
       <case clause>*
       (else <tail sequence>))

     (and <expression>* <tail expression>)
     (or <expression>* <tail expression>)

     (when <test> <tail sequence>)
     (unless <test> <tail sequence>)

     (let (<binding spec>*) <tail body>)
     (let <variable> (<binding spec>*) <tail body>)
     (let* (<binding spec>*) <tail body>)
     (letrec (<binding spec>*) <tail body>)
     (letrec* (<binding spec>*) <tail body>)
     (let-values (<mv binding spec>*) <tail body>)
     (let*-values (<mv binding spec>*) <tail body>)

     (let-syntax (<syntax spec>*) <tail body>)
     (letrec-syntax (<syntax spec>*) <tail body>)

     (begin <tail sequence>)

     (do (<iteration spec>*)
         (<test> <tail sequence>)
       <expression>*)

     where

     <cond clause> --> (<test> <tail sequence>)
     <case clause> --> ((<datum>*) <tail sequence>)

     <tail body> --> <definition>* <tail sequence>
     <tail sequence> --> <expression>* <tail expression>



   * If a 'cond' or 'case' expression is in a tail context, and has a
     clause of the form '(<expression1> => <expression2>)' then the
     (implied) call to the procedure that results from the evaluation of
     <expression2> is in a tail context.  <expression2> itself is not in
     a tail context.

Certain procedures defined in this report are also required to perform
tail calls.  The first argument passed to 'apply' and to
'call-with-current-continuation', and the second argument passed to
'call-with-values', must be called via a tail call.  Similarly, 'eval'
must evaluate its first argument as if it were in tail position within
the 'eval' procedure.

In the following example the only tail call is the call to 'f'.  None of
the calls to 'g' or 'h' are tail calls.  The reference to 'x' is in a
tail context, but it is not a call and thus is not a tail call.


     (lambda ()
       (if (g)
           (let ((x (h)))
             x)
           (and (g) (f))))


     _Note:_ Implementations may recognize that some non-tail calls,
     such as the call to 'h' above, can be evaluated as though they were
     tail calls.  In the example above, the 'let' expression could be
     compiled as a tail call to 'h'.  (The possibility of 'h' returning
     an unexpected number of values can be ignored, because in that case
     the effect of the 'let' is explicitly unspecified and
     implementation-dependent.)


File: r7rs.info,  Node: Expressions,  Next: Program structure,  Prev: Basic concepts,  Up: Top

4 Expressions
*************

* Menu:

* Primitive expression types::
* Derived expression types::
* Macros::

Expression types are categorized as _primitive_ or _derived_.  Primitive
expression types include variables and procedure calls.  Derived
expression types are not semantically primitive, but can instead be
defined as macros.  Suitable syntax definitions of some of the derived
expressions are given in section *note Derived expression type::.

The procedures 'force', 'promise?', 'make-promise', and 'make-parameter'
are also described in this chapter because they are intimately
associated with the 'delay', 'delay-force', and 'parameterize'
expression types.


File: r7rs.info,  Node: Primitive expression types,  Next: Derived expression types,  Prev: Expressions,  Up: Expressions

4.1 Primitive expression types
==============================

* Menu:

* Variable references::
* Literal expressions::
* Procedure calls::
* Procedures::
* Conditionals::
* Assignments::
* Inclusion::


File: r7rs.info,  Node: Variable references,  Next: Literal expressions,  Prev: Primitive expression types,  Up: Primitive expression types

4.1.1 Variable references
-------------------------

 -- syntax: <variable>

     An expression consisting of a variable (section *note Variables;
     syntactic keywords; and regions::) is a variable reference.  The
     value of the variable reference is the value stored in the location
     to which the variable is bound.  It is an error to reference an
     unbound variable.

     (define x 28)
     x                                      ==>  28



File: r7rs.info,  Node: Literal expressions,  Next: Procedure calls,  Prev: Variable references,  Up: Primitive expression types

4.1.2 Literal expressions
-------------------------

 -- syntax: quote <datum>

 -- syntax: '<datum>

 -- syntax: <constant>

     '(quote <datum>)' evaluates to <datum>.  <Datum> can be any
     external representation of a Scheme object (see section *note
     External representations::).  This notation is used to include
     literal constants in Scheme code.


     (quote a)                              ==>  a
     (quote #(a b c))                       ==>  #(a b c)
     (quote (+ 1 2))                        ==>  (+ 1 2)


     '(quote <datum>)' can be abbreviated as '<datum>.  The two
     notations are equivalent in all respects.

     'a                                     ==>  a
     '#(a b c)                              ==>  #(a b c)
     '()                                    ==>  ()
     '(+ 1 2)                               ==>  (+ 1 2)
     '(quote a)                             ==>  (quote a)
     ''a                                    ==>  (quote a)


     Numerical constants, string constants, character constants, vector
     constants, bytevector constants, and boolean constants evaluate to
     themselves; they need not be quoted.

     '145932                                ==>  145932
     145932                                 ==>  145932
     '"abc"                                 ==>  "abc"
     "abc"                                  ==>  "abc"
     '#\a                                   ==>  #\a
     #\a                                    ==>  #\a
     '#(a 10)                               ==>  #(a 10)
     #(a 10)                                ==>  #(a 10)
     '#u8(64 65)                            ==>  #u8(64 65)
     #u8(64 65)                             ==>  #u8(64 65)
     '#t                                    ==>  #t
     #t                                     ==>  #t


     As noted in section *note Storage model::, it is an error to
     attempt to alter a constant (i.e.  the value of a literal
     expression) using a mutation procedure like 'set-car!' or
     'string-set!'.


File: r7rs.info,  Node: Procedure calls,  Next: Procedures,  Prev: Literal expressions,  Up: Primitive expression types

4.1.3 Procedure calls
---------------------

 -- syntax: (<operator> <operand1> ...)

     A procedure call is written by enclosing in parentheses an
     expression for the procedure to be called followed by expressions
     for the arguments to be passed to it.  The operator and operand
     expressions are evaluated (in an unspecified order) and the
     resulting procedure is passed the resulting arguments.


     (+ 3 4)                                ==>  7
     ((if #f + *) 3 4)                      ==>  12


     The procedures in this document are available as the values of
     variables exported by the standard libraries.  For example, the
     addition and multiplication procedures in the above examples are
     the values of the variables '+' and '*' in the base library.  New
     procedures are created by evaluating lambda expressions (see
     section *note Procedures::).

     Procedure calls can return any number of values (see 'values' in
     section *note Control features::).  Most of the procedures defined
     in this report return one value or, for procedures such as 'apply',
     pass on the values returned by a call to one of their arguments.
     Exceptions are noted in the individual descriptions.

          _Note:_ In contrast to other dialects of Lisp, the order of
          evaluation is unspecified, and the operator expression and the
          operand expressions are always evaluated with the same
          evaluation rules.

          _Note:_ Although the order of evaluation is otherwise
          unspecified, the effect of any concurrent evaluation of the
          operator and operand expressions is constrained to be
          consistent with some sequential order of evaluation.  The
          order of evaluation may be chosen differently for each
          procedure call.

          _Note:_ In many dialects of Lisp, the empty list, (), is a
          legitimate expression evaluating to itself.  In Scheme, it is
          an error.


File: r7rs.info,  Node: Procedures,  Next: Conditionals,  Prev: Procedure calls,  Up: Primitive expression types

4.1.4 Procedures
----------------

 -- syntax: lambda <formals> <body>

     _Syntax:_ <Formals> is a formal arguments list as described below,
     and <body> is a sequence of zero or more definitions followed by
     one or more expressions.

     _Semantics:_ A lambda expression evaluates to a procedure.  The
     environment in effect when the lambda expression was evaluated is
     remembered as part of the procedure.  When the procedure is later
     called with some actual arguments, the environment in which the
     lambda expression was evaluated will be extended by binding the
     variables in the formal argument list to fresh locations, and the
     corresponding actual argument values will be stored in those
     locations.  (A "fresh" location is one that is distinct from every
     previously existing location.)  Next, the expressions in the body
     of the lambda expression (which, if it contains definitions,
     represents a 'letrec*' form -- see section *note Binding
     constructs::) will be evaluated sequentially in the extended
     environment.  The results of the last expression in the body will
     be returned as the results of the procedure call.

     (lambda (x) (+ x x))                   ==>  __a procedure
     ((lambda (x) (+ x x)) 4)               ==>  8

     (define reverse-subtract
       (lambda (x y) (- y x)))
     (reverse-subtract 7 10)                ==>  3

     (define add4
       (let ((x 4))
         (lambda (y) (+ x y))))
     (add4 6)                               ==>  10


     <Formals> have one of the following forms:

        * (<variable1> ...): The procedure takes a fixed number of
          arguments; when the procedure is called, the arguments will be
          stored in fresh locations that are bound to the corresponding
          variables.

        * <variable>: The procedure takes any number of arguments; when
          the procedure is called, the sequence of actual arguments is
          converted into a newly allocated list, and the list is stored
          in a fresh location that is bound to <variable>.

        * (<variable1> ... <variable_n> . <variable_n+1>): If a
          space-delimited period precedes the last variable, then the
          procedure takes n or more arguments, where n is the number of
          formal arguments before the period (it is an error if there is
          not at least one).  The value stored in the binding of the
          last variable will be a newly allocated list of the actual
          arguments left over after all the other actual arguments have
          been matched up against the other formal arguments.

     It is an error for a <variable> to appear more than once in
     <formals>.

     ((lambda x x) 3 4 5 6)                 ==>  (3 4 5 6)
     ((lambda (x y . z) z)
      3 4 5 6)                              ==>  (5 6)


Each procedure created as the result of evaluating a lambda expression
is (conceptually) tagged with a storage location, in order to make
'eqv?' and 'eq?' work on procedures (see section *note Equivalence
predicates::).


File: r7rs.info,  Node: Conditionals,  Next: Assignments,  Prev: Procedures,  Up: Primitive expression types

4.1.5 Conditionals
------------------

 -- syntax: if <test> <consequent> <alternate>
 -- syntax: if <test> <consequent>

     _Syntax:_ <Test>, <consequent>, and <alternate> are expressions.

     _Semantics:_ An 'if' expression is evaluated as follows: first,
     <test> is evaluated.  If it yields a true value (see section *note
     Booleans::), then <consequent> is evaluated and its values are
     returned.  Otherwise <alternate> is evaluated and its values are
     returned.  If <test> yields a false value and no <alternate> is
     specified, then the result of the expression is unspecified.

     (if (> 3 2) 'yes 'no)                  ==>  yes
     (if (> 2 3) 'yes 'no)                  ==>  no
     (if (> 3 2)
         (- 3 2)
         (+ 3 2))                           ==>  1



File: r7rs.info,  Node: Assignments,  Next: Inclusion,  Prev: Conditionals,  Up: Primitive expression types

4.1.6 Assignments
-----------------

 -- syntax: set! <variable> <expression>

     _Semantics:_ <Expression> is evaluated, and the resulting value is
     stored in the location to which <variable> is bound.  It is an
     error if <variable> is not bound either in some region enclosing
     the 'set!' expression or else globally.  The result of the 'set!'
     expression is unspecified.

     (define x 2)
     (+ x 1)                                ==>  3
     (set! x 4)                             ==>  _unspecified_
     (+ x 1)                                ==>  5



File: r7rs.info,  Node: Inclusion,  Prev: Assignments,  Up: Primitive expression types

4.1.7 Inclusion
---------------

 -- syntax: include <string1> <string2> ...
 -- syntax: include-ci <string1> <string2> ...

     _Semantics:_ Both 'include' and 'include-ci' take one or more
     filenames expressed as string literals, apply an
     implementation-specific algorithm to find corresponding files, read
     the contents of the files in the specified order as if by repeated
     applications of 'read', and effectively replace the 'include' or
     'include-ci' expression with a 'begin' expression containing what
     was read from the files.  The difference between the two is that
     'include-ci' reads each file as if it began with the ''#!fold-case
     directive, while 'include' does not.

          _Note:_ Implementations are encouraged to search for files in
          the directory which contains the including file, and to
          provide a way for users to specify other directories to
          search.


File: r7rs.info,  Node: Derived expression types,  Next: Macros,  Prev: Primitive expression types,  Up: Expressions

4.2 Derived expression types
============================

* Menu:

* Conditional::
* Binding constructs::
* Sequencing::
* Iteration::
* Delayed evaluation::
* Dynamic bindings::
* Exception handling::
* Quasiquotation::
* Case-lambda::

The constructs in this section are hygienic, as discussed in section
*note Macros::.  For reference purposes, section *note Derived
expression type:: gives syntax definitions that will convert most of the
constructs described in this section into the primitive constructs
described in the previous section.


File: r7rs.info,  Node: Conditional,  Next: Binding constructs,  Prev: Derived expression types,  Up: Derived expression types

4.2.1 Conditionals
------------------

 -- syntax: cond <clause1> <clause2> ...

 -- auxiliary syntax: else

 -- auxiliary syntax: =>

     _Syntax:_ <Clauses> take one of two forms, either

     (<test> <expression1> ...)


     where <test> is any expression, or

     (<test> => <expression>)


     The last <clause> can be an "else clause," which has the form

     (else <expression1> <expression2> ...).


     _Semantics:_ A 'cond' expression is evaluated by evaluating the
     <test> expressions of successive <clause>s in order until one of
     them evaluates to a true value (see section *note Booleans::).
     When a <test> evaluates to a true value, the remaining
     <expression>s in its <clause> are evaluated in order, and the
     results of the last <expression> in the <clause> are returned as
     the results of the entire 'cond' expression.

     If the selected <clause> contains only the <test> and no
     <expression>s, then the value of the <test> is returned as the
     result.  If the selected <clause> uses the '=>' alternate form,
     then the <expression> is evaluated.  It is an error if its value is
     not a procedure that accepts one argument.  This procedure is then
     called on the value of the <test> and the values returned by this
     procedure are returned by the 'cond' expression.

     If all <test>s evaluate to #f, and there is no else clause, then
     the result of the conditional expression is unspecified; if there
     is an else clause, then its <expression>s are evaluated in order,
     and the values of the last one are returned.

     (cond ((> 3 2) 'greater)
           ((< 3 2) 'less))                 ==>  greater

     (cond ((> 3 3) 'greater)
           ((< 3 3) 'less)
           (else 'equal))                   ==>  equal

     (cond ((assv 'b '((a 1) (b 2))) => cadr)
           (else #f))                       ==>  2


 -- syntax: case <key> <clause1> <clause2> ...

     _Syntax:_ <Key> can be any expression.  Each <clause> has the form

     ((<datum1> ...) <expression1> <expression2> ...),


     where each <datum> is an external representation of some object.
     It is an error if any of the <datum>s are the same anywhere in the
     expression.  Alternatively, a <clause> can be of the form

     ((<datum1> ...) => <expression>)


     The last <clause> can be an "else clause," which has one of the
     forms

     (else <expression1> <expression2> ...)


     or

     (else => <expression>).


     _Semantics:_ A 'case' expression is evaluated as follows.  <Key> is
     evaluated and its result is compared against each <datum>.  If the
     result of evaluating <key> is the same (in the sense of 'eqv?'; see
     section *note Equivalence predicates::) to a <datum>, then the
     expressions in the corresponding <clause> are evaluated in order
     and the results of the last expression in the <clause> are returned
     as the results of the 'case' expression.

     If the result of evaluating <key> is different from every <datum>,
     then if there is an else clause, its expressions are evaluated and
     the results of the last are the results of the 'case' expression;
     otherwise the result of the 'case' expression is unspecified.

     If the selected <clause> or else clause uses the '=>' alternate
     form, then the <expression> is evaluated.  It is an error if its
     value is not a procedure accepting one argument.  This procedure is
     then called on the value of the <key> and the values returned by
     this procedure are returned by the 'case' expression.

     (case (* 2 3)
       ((2 3 5 7) 'prime)
       ((1 4 6 8 9) 'composite))            ==>  composite
     (case (car '(c d))
       ((a) 'a)
       ((b) 'b))                            ==>  _unspecified_
     (case (car '(c d))
       ((a e i o u) 'vowel)
       ((w y) 'semivowel)
       (else => (lambda (x) x)))            ==>  c


 -- syntax: and <test1> ...

     _Semantics:_ The <test> expressions are evaluated from left to
     right, and if any expression evaluates to #f (see section *note
     Booleans::), then #f is returned.  Any remaining expressions are
     not evaluated.  If all the expressions evaluate to true values, the
     values of the last expression are returned.  If there are no
     expressions, then #t is returned.

     (and (= 2 2) (> 2 1))                  ==>  #t
     (and (= 2 2) (< 2 1))                  ==>  #f
     (and 1 2 'c '(f g))                    ==>  (f g)
     (and)                                  ==>  #t


 -- syntax: or <test1> ...

     _Semantics:_ The <test> expressions are evaluated from left to
     right, and the value of the first expression that evaluates to a
     true value (see section *note Booleans::) is returned.  Any
     remaining expressions are not evaluated.  If all expressions
     evaluate to #f or if there are no expressions, then #f is returned.

     (or (= 2 2) (> 2 1))                   ==>  #t
     (or (= 2 2) (< 2 1))                   ==>  #t
     (or #f #f #f)                          ==>  #f
     (or (memq 'b '(a b c))
         (/ 3 0))                           ==>  (b c)


 -- syntax: when <test> <expression1> <expression2> ...

     _Syntax:_ The <test> is an expression.

     _Semantics:_ The test is evaluated, and if it evaluates to a true
     value, the expressions are evaluated in order.  The result of the
     'when' expression is unspecified.

     (when (= 1 1.0)
       (display "1")
       (display "2"))                       ==>  _unspecified_
               _and prints_  12


 -- syntax: unless <test> <expression1> <expression2> ...

     _Syntax:_ The <test> is an expression.

     _Semantics:_ The test is evaluated, and if it evaluates to #f, the
     expressions are evaluated in order.  The result of the 'unless'
     expression is unspecified.

     (unless (= 1 1.0)
       (display "1")
       (display "2"))                       ==>  _unspecified_
               _and prints nothing_


 -- syntax: cond-expand <ce-clause1> <ce-clause2> ...

     _Syntax:_ The 'cond-expand' expression type provides a way to
     statically expand different expressions depending on the
     implementation.  A <ce-clause> takes the following form:

     (<feature requirement> <expression> ...)

     The last clause can be an "else clause," which has the form

     (else <expression> ...)

     A <feature requirement> takes one of the following forms:

        * <feature identifier>
        * (library <library name>)
        * (and <feature requirement> ...)
        * (or <feature requirement> ...)
        * (not <feature requirement>)

     _Semantics:_ Each implementation maintains a list of feature
     identifiers which are present, as well as a list of libraries which
     can be imported.  The value of a <feature requirement> is
     determined by replacing each <feature identifier> and (library
     <library name>) on the implementation's lists with #t, and all
     other feature identifiers and library names with #f, then
     evaluating the resulting expression as a Scheme boolean expression
     under the normal interpretation of 'and', 'or', and 'not'.

     A 'cond-expand' is then expanded by evaluating the <feature
     requirement>s of successive <ce-clause>s in order until one of them
     returns #t.  When a true clause is found, the corresponding
     <expression>s are expanded to a 'begin', and the remaining clauses
     are ignored.  If none of the <feature requirement>s evaluate to #t,
     then if there is an else clause, its <expression>s are included.
     Otherwise, the behavior of the 'cond-expand' is unspecified.
     Unlike 'cond', 'cond-expand' does not depend on the value of any
     variables.

     The exact features provided are implementation-defined, but for
     portability a core set of features is given in appendix *note
     Standard Feature Identifiers::.


File: r7rs.info,  Node: Binding constructs,  Next: Sequencing,  Prev: Conditional,  Up: Derived expression types

4.2.2 Binding constructs
------------------------

The binding constructs 'let', 'let*', 'letrec', 'letrec*', 'let-values',
and 'let*-values' give Scheme a block structure, like Algol 60.  The
syntax of the first four constructs is identical, but they differ in the
regions they establish for their variable bindings.  In a 'let'
expression, the initial values are computed before any of the variables
become bound; in a 'let*' expression, the bindings and evaluations are
performed sequentially; while in 'letrec' and 'letrec*' expressions, all
the bindings are in effect while their initial values are being
computed, thus allowing mutually recursive definitions.  The
'let-values' and 'let*-values' constructs are analogous to 'let' and
'let*' respectively, but are designed to handle multiple-valued
expressions, binding different identifiers to the returned values.

 -- syntax: let <bindings> <body>

     _Syntax:_ <Bindings> has the form

     ((<variable1> <init1>) ...),


     where each <init> is an expression, and <body> is a sequence of
     zero or more definitions followed by a sequence of one or more
     expressions as described in section *note Procedures::.  It is an
     error for a <variable> to appear more than once in the list of
     variables being bound.

     _Semantics:_ The <init>s are evaluated in the current environment
     (in some unspecified order), the <variable>s are bound to fresh
     locations holding the results, the <body> is evaluated in the
     extended environment, and the values of the last expression of
     <body> are returned.  Each binding of a <variable> has <body> as
     its region.

     (let ((x 2) (y 3))
       (* x y))                             ==>  6

     (let ((x 2) (y 3))
       (let ((x 7)
             (z (+ x y)))
         (* z x)))                          ==>  35


     See also "named 'let'," section *note Iteration::.

 -- syntax: let* <bindings> <body>

     _Syntax:_ <Bindings> has the form

     ((<variable1> <init1>) ...),


     and <body> is a sequence of zero or more definitions followed by
     one or more expressions as described in section *note Procedures::.

     _Semantics:_ The 'let*' binding construct is similar to 'let', but
     the bindings are performed sequentially from left to right, and the
     region of a binding indicated by '(<variable> <init>)' is that part
     of the 'let*' expression to the right of the binding.  Thus the
     second binding is done in an environment in which the first binding
     is visible, and so on.  The <variable>s need not be distinct.

     (let ((x 2) (y 3))
       (let* ((x 7)
              (z (+ x y)))
         (* z x)))                          ==>  70


 -- syntax: letrec <bindings> <body>

     _Syntax:_ <Bindings> has the form

     ((<variable1> <init1>) ...),


     and <body> is a sequence of zero or more definitions followed by
     one or more expressions as described in section *note Procedures::.
     It is an error for a <variable> to appear more than once in the
     list of variables being bound.

     _Semantics:_ The <variable>s are bound to fresh locations holding
     unspecified values, the <init>s are evaluated in the resulting
     environment (in some unspecified order), each <variable> is
     assigned to the result of the corresponding <init>, the <body> is
     evaluated in the resulting environment, and the values of the last
     expression in <body> are returned.  Each binding of a <variable>
     has the entire 'letrec' expression as its region, making it
     possible to define mutually recursive procedures.

     (letrec ((even?
               (lambda (n)
                 (if (zero? n)
                     #t
                     (odd? (- n 1)))))
              (odd?
               (lambda (n)
                 (if (zero? n)
                     #f
                     (even? (- n 1))))))
       (even? 88))
                                            ==>  #t


     One restriction on 'letrec' is very important: if it is not
     possible to evaluate each <init> without assigning or referring to
     the value of any <variable>, it is an error.  The restriction is
     necessary because 'letrec' is defined in terms of a procedure call
     where a 'lambda' expression binds the <variable>s to the values of
     the <init>s.  In the most common uses of 'letrec', all the <init>s
     are lambda expressions and the restriction is satisfied
     automatically.

 -- syntax: letrec* <bindings> <body>

     _Syntax:_ <Bindings> has the form

     ((<variable1> <init1>) ...),


     and <body> is a sequence of zero or more definitions followed by
     one or more expressions as described in section *note Procedures::.
     It is an error for a <variable> to appear more than once in the
     list of variables being bound.

     _Semantics:_ The <variable>s are bound to fresh locations, each
     <variable> is assigned in left-to-right order to the result of
     evaluating the corresponding <init> (interleaving evaluations and
     assignments), the <body> is evaluated in the resulting environment,
     and the values of the last expression in <body> are returned.
     Despite the left-to-right evaluation and assignment order, each
     binding of a <variable> has the entire 'letrec*' expression as its
     region, making it possible to define mutually recursive procedures.

     If it is not possible to evaluate each <init> without assigning or
     referring to the value of the corresponding <variable> or the
     <variable> of any of the bindings that follow it in <bindings>, it
     is an error.  Another restriction is that it is an error to invoke
     the continuation of an <init> more than once.

     ;; Returns the arithmetic, geometric, and
     ;; harmonic means of a nested list of numbers
     (define (means ton)
       (letrec*
          ((mean
             (lambda (f g)
               (f (/ (sum g ton) n))))
           (sum
             (lambda (g ton)
               (if (null? ton)
                 (+)
                 (if (number? ton)
                     (g ton)
                     (+ (sum g (car ton))
                        (sum g (cdr ton)))))))
           (n (sum (lambda (x) 1) ton)))
         (values (mean values values)
                 (mean exp log)
                 (mean / /))))


     Evaluating '(means '(3 (1 4)))' returns three values: 8/3,
     2.28942848510666 (approximately), and 36/19.

 -- syntax: let-values <mv binding spec> <body>

     _Syntax:_ <Mv binding spec> has the form

     ((<formals1> <init1>) ...),


     where each <init> is an expression, and <body> is zero or more
     definitions followed by a sequence of one or more expressions as
     described in section *note Procedures::.  It is an error for a
     variable to appear more than once in the set of <formals>.

     _Semantics:_ The <init>s are evaluated in the current environment
     (in some unspecified order) as if by invoking 'call-with-values',
     and the variables occurring in the <formals> are bound to fresh
     locations holding the values returned by the <init>s, where the
     <formals> are matched to the return values in the same way that the
     <formals> in a 'lambda' expression are matched to the arguments in
     a procedure call.  Then, the <body> is evaluated in the extended
     environment, and the values of the last expression of <body> are
     returned.  Each binding of a <variable> has <body> as its region.

     It is an error if the <formals> do not match the number of values
     returned by the corresponding <init>.

     (let-values (((root rem) (exact-integer-sqrt 32)))
       (* root rem))                        ==>  35


 -- syntax: let*-values <mv binding spec> <body>

     _Syntax:_ <Mv binding spec> has the form

     ((<formals> <init>) ...),


     and <body> is a sequence of zero or more definitions followed by
     one or more expressions as described in section *note Procedures::.
     In each <formals>, it is an error if any variable appears more than
     once.

     _Semantics:_ The 'let*-values' construct is similar to
     'let-values', but the <init>s are evaluated and bindings created
     sequentially from left to right, with the region of the bindings of
     each <formals> including the <init>s to its right as well as
     <body>.  Thus the second <init> is evaluated in an environment in
     which the first set of bindings is visible and initialized, and so
     on.

     (let ((a 'a) (b 'b) (x 'x) (y 'y))
       (let*-values (((a b) (values x y))
                     ((x y) (values a b)))
         (list a b x y)))                   ==> (x y x y)



File: r7rs.info,  Node: Sequencing,  Next: Iteration,  Prev: Binding constructs,  Up: Derived expression types

4.2.3 Sequencing
----------------

Both of Scheme's sequencing constructs are named 'begin', but the two
have slightly different forms and uses:

 -- syntax: begin <expression or definition> ...

     This form of 'begin' can appear as part of a <body>, or at the
     outermost level of a <program>, or at the REPL, or directly nested
     in a 'begin' that is itself of this form.  It causes the contained
     expressions and definitions to be evaluated exactly as if the
     enclosing 'begin' construct were not present.

          _Rationale:_ This form is commonly used in the output of
          macros (see section *note Macros::) which need to generate
          multiple definitions and splice them into the context in which
          they are expanded.

 -- syntax: begin <expression1> <expression2> ...

     This form of 'begin' can be used as an ordinary expression.  The
     <expression>s are evaluated sequentially from left to right, and
     the values of the last <expression> are returned.  This expression
     type is used to sequence side effects such as assignments or input
     and output.

     (define x 0)

     (and (= x 0)
          (begin (set! x 5)
                 (+ x 1)))                  ==>  6

     (begin (display "4 plus 1 equals ")
            (display (+ 4 1)))              ==>  _unspecified_
               _and prints_  4 plus 1 equals 5


Note that there is a third form of 'begin' used as a library
declaration: see section *note Library Syntax::.


File: r7rs.info,  Node: Iteration,  Next: Delayed evaluation,  Prev: Sequencing,  Up: Derived expression types

4.2.4 Iteration
---------------


 -- syntax: (do ((<variable1> <init1> <step1>)

     ...) (<test> <expression> ...) <command> ...)

     _Syntax:_ All of <init>, <step>, <test>, and <command> are
     expressions.

     _Semantics:_ A 'do' expression is an iteration construct.  It
     specifies a set of variables to be bound, how they are to be
     initialized at the start, and how they are to be updated on each
     iteration.  When a termination condition is met, the loop exits
     after evaluating the <expression>s.

     A 'do' expression is evaluated as follows: The <init> expressions
     are evaluated (in some unspecified order), the <variable>s are
     bound to fresh locations, the results of the <init> expressions are
     stored in the bindings of the <variable>s, and then the iteration
     phase begins.

     Each iteration begins by evaluating <test>; if the result is false
     (see section *note Booleans::), then the <command> expressions are
     evaluated in order for effect, the <step> expressions are evaluated
     in some unspecified order, the <variable>s are bound to fresh
     locations, the results of the <step>s are stored in the bindings of
     the <variable>s, and the next iteration begins.

     If <test> evaluates to a true value, then the <expression>s are
     evaluated from left to right and the values of the last
     <expression> are returned.  If no <expression>s are present, then
     the value of the 'do' expression is unspecified.

     The region of the binding of a <variable> consists of the entire
     'do' expression except for the <init>s.  It is an error for a
     <variable> to appear more than once in the list of 'do' variables.

     A <step> can be omitted, in which case the effect is the same as if
     '(<variable> <init> <variable>)' had been written instead of
     '(<variable> <init>)'.

     (do ((vec (make-vector 5))
          (i 0 (+ i 1)))
         ((= i 5) vec)
       (vector-set! vec i i))               ==>  #(0 1 2 3 4)

     (let ((x '(1 3 5 7 9)))
       (do ((x x (cdr x))
            (sum 0 (+ sum (car x))))
           ((null? x) sum)))                ==>  25


 -- syntax: let <variable> <bindings> <body>

     _Semantics:_ "Named 'let'" is a variant on the syntax of 'let'
     which provides a more general looping construct than 'do' and can
     also be used to express recursion.  It has the same syntax and
     semantics as ordinary 'let' except that <variable> is bound within
     <body> to a procedure whose formal arguments are the bound
     variables and whose body is <body>.  Thus the execution of <body>
     can be repeated by invoking the procedure named by <variable>.

     (let loop ((numbers '(3 -2 1 6 -5))
                (nonneg '())
                (neg '()))
       (cond ((null? numbers) (list nonneg neg))
             ((>= (car numbers) 0)
              (loop (cdr numbers)
                    (cons (car numbers) nonneg)
                    neg))
             ((< (car numbers) 0)
              (loop (cdr numbers)
                    nonneg
                    (cons (car numbers) neg)))))
               ==>  ((6 1 3) (-5 -2))



File: r7rs.info,  Node: Delayed evaluation,  Next: Dynamic bindings,  Prev: Iteration,  Up: Derived expression types

4.2.5 Delayed evaluation
------------------------

 -- lazy library syntax: delay <expression>

     _Semantics:_ The 'delay' construct is used together with the
     procedure 'force' to implement "lazy evaluation" or "call by need".
     (delay <expression>) returns an object called a "promise" which at
     some point in the future can be asked (by the 'force' procedure) to
     evaluate <expression>, and deliver the resulting value.

     The effect of <expression> returning multiple values is
     unspecified.

 -- lazy library syntax: delay-force <expression>

     _Semantics:_ The expression '(delay-force EXPRESSION)' is
     conceptually similar to '(delay (force EXPRESSION))', with the
     difference that forcing the result of 'delay-force' will in effect
     result in a tail call to '(force EXPRESSION)', while forcing the
     result of '(delay (force EXPRESSION))' might not.  Thus iterative
     lazy algorithms that might result in a long series of chains of
     'delay' and 'force' can be rewritten using 'delay-force' to prevent
     consuming unbounded space during evaluation.

 -- lazy library procedure: force promise

     The 'force' procedure forces the value of a PROMISE created by
     'delay', 'delay-force', or 'make-promise'.  If no value has been
     computed for the promise, then a value is computed and returned.
     The value of the promise must be cached (or "memoized") so that if
     it is forced a second time, the previously computed value is
     returned.  Consequently, a delayed expression is evaluated using
     the parameter values and exception handler of the call to 'force'
     which first requested its value.  If PROMISE is not a promise, it
     may be returned unchanged.

     (force (delay (+ 1 2)))                ==>  3
     (let ((p (delay (+ 1 2))))
       (list (force p) (force p)))
                                            ==>  (3 3)

     (define integers
       (letrec ((next
                 (lambda (n)
                   (delay (cons n (next (+ n 1)))))))
         (next 0)))
     (define head
       (lambda (stream) (car (force stream))))
     (define tail
       (lambda (stream) (cdr (force stream))))

     (head (tail (tail integers)))
                                            ==>  2


     The following example is a mechanical transformation of a lazy
     stream-filtering algorithm into Scheme.  Each call to a constructor
     is wrapped in 'delay', and each argument passed to a deconstructor
     is wrapped in 'force'.  The use of '(delay-force ...)' instead of
     '(delay (force ...))' around the body of the procedure ensures that
     an ever-growing sequence of pending promises does not exhaust
     available storage, because 'force' will in effect force such
     sequences iteratively.

     (define (stream-filter p? s)
       (delay-force
        (if (null? (force s))
            (delay '())
            (let ((h (car (force s)))
                  (t (cdr (force s))))
              (if (p? h)
                  (delay (cons h (stream-filter p? t)))
                  (stream-filter p? t))))))

     (head (tail (tail (stream-filter odd? integers))))
                                            ==> 5


     The following examples are not intended to illustrate good
     programming style, as 'delay', 'force', and 'delay-force' are
     mainly intended for programs written in the functional style.
     However, they do illustrate the property that only one value is
     computed for a promise, no matter how many times it is forced.

     (define count 0)
     (define p
       (delay (begin (set! count (+ count 1))
                     (if (> count x)
                         count
                         (force p)))))
     (define x 5)
     p                                      ==>  a promise
     (force p)                              ==>  6
     p                                      ==>  a promise, still
     (begin (set! x 10)
            (force p))                      ==>  6


     Various extensions to this semantics of 'delay', 'force' and
     'delay-force' are supported in some implementations:

        * Calling 'force' on an object that is not a promise may simply
          return the object.

        * It may be the case that there is no means by which a promise
          can be operationally distinguished from its forced value.
          That is, expressions like the following may evaluate to either
          #t or to #f, depending on the implementation:

          (eqv? (delay 1) 1)                ==>  _unspecified_
          (pair? (delay (cons 1 2)))        ==>  _unspecified_


        * Implementations may implement "implicit forcing," where the
          value of a promise is forced by procedures that operate only
          on arguments of a certain type, like 'cdr' and '*'.  However,
          procedures that operate uniformly on their arguments, like
          'list', must not force them.

          (+ (delay (* 3 7)) 13)            ==>  _unspecified_
          (car
            (list (delay (* 3 7)) 13))      ==> a promise


 -- lazy library procedure: promise? OBJ

     The 'promise?' procedure returns #t if its argument is a promise,
     and #f otherwise.  Note that promises are not necessarily disjoint
     from other Scheme types such as procedures.

 -- lazy library procedure: make-promise OBJ

     The 'make-promise' procedure returns a promise which, when forced,
     will return OBJ.  It is similar to 'delay', but does not delay its
     argument: it is a procedure rather than syntax.  If OBJ is already
     a promise, it is returned.


File: r7rs.info,  Node: Dynamic bindings,  Next: Exception handling,  Prev: Delayed evaluation,  Up: Derived expression types

4.2.6 Dynamic bindings
----------------------

The "dynamic extent" of a procedure call is the time between when it is
initiated and when it returns.  In Scheme,
'call-with-current-continuation' (section *note Control features::)
allows reentering a dynamic extent after its procedure call has
returned.  Thus, the dynamic extent of a call might not be a single,
continuous time period.

This sections introduces "parameter objects", which can be bound to new
values for the duration of a dynamic extent.  The set of all parameter
bindings at a given time is called the "dynamic environment".
environment

 -- procedure: make-parameter init
 -- procedure: make-parameter init converter

     Returns a newly allocated parameter object, which is a procedure
     that accepts zero arguments and returns the value associated with
     the parameter object.  Initially, this value is the value of
     '(CONVERTER INIT)', or of INIT if the conversion procedure
     CONVERTER is not specified.  The associated value can be
     temporarily changed using 'parameterize', which is described below.

     The effect of passing arguments to a parameter object is
     implementation-dependent.

 -- syntax: (parameterize ((<param1> <value1>) ...)

     hspace*1em<body>)

     _Syntax:_ Both <param1> and <value1> are expressions.

     It is an error if the value of any <param> expression is not a
     parameter object.  _Semantics:_ A 'parameterize' expression is used
     to change the values returned by specified parameter objects during
     the evaluation of the body.

     The <param> and <value> expressions are evaluated in an unspecified
     order.  The <body> is evaluated in a dynamic environment in which
     calls to the parameters return the results of passing the
     corresponding values to the conversion procedure specified when the
     parameters were created.  Then the previous values of the
     parameters are restored without passing them to the conversion
     procedure.  The results of the last expression in the <body> are
     returned as the results of the entire 'parameterize' expression.

          _Note:_ If the conversion procedure is not idempotent, the
          results of '(parameterize ((x (x))) ...)', which appears to
          bind the parameter X to its current value, might not be what
          the user expects.

     If an implementation supports multiple threads of execution, then
     'parameterize' must not change the associated values of any
     parameters in any thread other than the current thread and threads
     created inside <body>.

     Parameter objects can be used to specify configurable settings for
     a computation without the need to pass the value to every procedure
     in the call chain explicitly.

     (define radix
       (make-parameter
        10
        (lambda (x)
          (if (and (exact-integer? x) (<= 2 x 16))
              x
              (error "invalid radix")))))

     (define (f n) (number->string n (radix)))

     (f 12)                                       ==> "12"
     (parameterize ((radix 2))
       (f 12))                                    ==> "1100"
     (f 12)                                       ==> "12"

     (radix 16)                                   ==> _unspecified_

     (parameterize ((radix 0))
       (f 12))                                    ==> _error_



File: r7rs.info,  Node: Exception handling,  Next: Quasiquotation,  Prev: Dynamic bindings,  Up: Derived expression types

4.2.7 Exception handling
------------------------

 -- syntax: (guard (<variable>

     hspace*4em<cond clause1> <cond clause2> ...)hspace*2em<body>)

     _Syntax:_ Each <cond clause> is as in the specification of 'cond'.

     _Semantics:_ The <body> is evaluated with an exception handler that
     binds the raised object (see 'raise' in section *note Exceptions::)
     to <variable> and, within the scope of that binding, evaluates the
     clauses as if they were the clauses of a 'cond' expression.  That
     implicit 'cond' expression is evaluated with the continuation and
     dynamic environment of the 'guard' expression.  If every <cond
     clause>'s <test> evaluates to #f and there is no else clause, then
     'raise-continuable' is invoked on the raised object within the
     dynamic environment of the original call to 'raise' or
     'raise-continuable', except that the current exception handler is
     that of the 'guard' expression.

     See section *note Exceptions:: for a more complete discussion of
     exceptions.

     (guard (condition
              ((assq 'a condition) => cdr)
              ((assq 'b condition)))
       (raise (list (cons 'a 42))))
                                            ==> 42

     (guard (condition
              ((assq 'a condition) => cdr)
              ((assq 'b condition)))
       (raise (list (cons 'b 23))))
                                            ==> (b . 23)



File: r7rs.info,  Node: Quasiquotation,  Next: Case-lambda,  Prev: Exception handling,  Up: Derived expression types

4.2.8 Quasiquotation
--------------------

 -- syntax: quasiquote <qq template>

 -- syntax: `<qq template>

 -- auxiliary syntax: unquote

 -- auxiliary syntax: ,

 -- auxiliary syntax: unquote-splicing

 -- auxiliary syntax: ,@

     "Quasiquote" expressions are useful for constructing a list or
     vector structure when some but not all of the desired structure is
     known in advance.  If no commas appear within the <qq template>,
     the result of evaluating `<qq template> is equivalent to the result
     of evaluating '<qq template>.  If a comma appears within the <qq
     template>, however, the expression following the comma is evaluated
     ("unquoted") and its result is inserted into the structure instead
     of the comma and the expression.  If a comma appears followed
     without intervening whitespace by a commercial at-sign (@), then it
     is an error if the following expression does not evaluate to a
     list; the opening and closing parentheses of the list are then
     "stripped away" and the elements of the list are inserted in place
     of the comma at-sign expression sequence.  A comma at-sign normally
     appears only within a list or vector <qq template>.

          _Note:_ In order to unquote an identifier beginning with '@',
          it is necessary to use either an explicit 'unquote' or to put
          whitespace after the comma, to avoid colliding with the comma
          at-sign sequence.

     `(list ,(+ 1 2) 4)                     ==>  (list 3 4)
     (let ((name 'a)) `(list ,name ',name))
               ==>  (list a (quote a))
     `(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b)
               ==>  (a 3 4 5 6 b)
     `(('foo' ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons)))
               ==>  ((foo 7) . cons)
     `#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8)
               ==>  #(10 5 2 4 3 8)
     (let ((foo '(foo bar)) (@baz 'baz))
       `(list ,@foo , @baz))

               ==>  (list foo bar baz)


     Quasiquote expressions can be nested.  Substitutions are made only
     for unquoted components appearing at the same nesting level as the
     outermost quasiquote.  The nesting level increases by one inside
     each successive quasiquotation, and decreases by one inside each
     unquotation.

     `(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
               ==>  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
     (let ((name1 'x)
           (name2 'y))
       `(a `(b ,,name1 ,',name2 d) e))
               ==>  (a `(b ,x ,'y d) e)


     A quasiquote expression may return either newly allocated, mutable
     objects or literal structure for any structure that is constructed
     at run time during the evaluation of the expression.  Portions that
     do not need to be rebuilt are always literal.  Thus,

     (let ((a 3)) `((1 2) ,a ,4 ,'five 6))


     may be treated as equivalent to either of the following
     expressions:

     `((1 2) 3 4 five 6)

     (let ((a 3))
       (cons '(1 2)
             (cons a (cons 4 (cons 'five '(6))))))


     However, it is not equivalent to this expression:

     (let ((a 3)) (list (list 1 2) a 4 'five 6))


     The two notations `<qq template> and (quasiquote <qq template>) are
     identical in all respects.  ',<expression>' is identical to
     '(unquote <expression>)', and ',@<expression>' is identical to
     '(unquote-splicing <expression>)'.  The 'write' procedure may
     output either format.

     (quasiquote (list (unquote (+ 1 2)) 4))
               ==>  (list 3 4)
     '(quasiquote (list (unquote (+ 1 2)) 4))
               ==>  `(list ,(+ 1 2) 4)
          __i.e., (quasiquote (list (unquote (+ 1 2)) 4))


     It is an error if any of the identifiers 'quasiquote', 'unquote',
     or 'unquote-splicing' appear in positions within a <qq template>
     otherwise than as described above.


File: r7rs.info,  Node: Case-lambda,  Prev: Quasiquotation,  Up: Derived expression types

4.2.9 Case-lambda
-----------------

 -- case-lambda library syntax: case-lambda <clause> ...

     _Syntax:_ Each <clause> is of the form (<formals> <body>), where
     <formals> and <body> have the same syntax as in a lambda
     expression.

     _Semantics:_ A 'case-lambda' expression evaluates to a procedure
     that accepts a variable number of arguments and is lexically scoped
     in the same manner as a procedure resulting from a lambda
     expression.  When the procedure is called, the first <clause> for
     which the arguments agree with <formals> is selected, where
     agreement is specified as for the <formals> of a lambda expression.
     The variables of <formals> are bound to fresh locations, the values
     of the arguments are stored in those locations, the <body> is
     evaluated in the extended environment, and the results of <body>
     are returned as the results of the procedure call.

     It is an error for the arguments not to agree with the <formals> of
     any <clause>.

     (define range
       (case-lambda
        ((e) (range 0 e))
        ((b e) (do ((r '() (cons e r))
                    (e (- e 1) (- e 1)))
                   ((< e b) r)))))

     (range 3)                              ==> (0 1 2)
     (range 3 5)                            ==> (3 4)



File: r7rs.info,  Node: Macros,  Prev: Derived expression types,  Up: Expressions

4.3 Macros
==========

* Menu:

* Binding constructs for syntactic keywords::
* Pattern language::
* Signaling errors in macro transformers::

Scheme programs can define and use new derived expression types, called
_macros_.  Program-defined expression types have the syntax


     (<keyword> <datum> ...)


where <keyword> is an identifier that uniquely determines the expression
type.  This identifier is called the _syntactic keyword_, or simply
_keyword_, of the macro.  The number of the <datum>s, and their syntax,
depends on the expression type.

Each instance of a macro is called a _use_ of the macro.  The set of
rules that specifies how a use of a macro is transcribed into a more
primitive expression is called the _transformer_ of the macro.

The macro definition facility consists of two parts:

   * A set of expressions used to establish that certain identifiers are
     macro keywords, associate them with macro transformers, and control
     the scope within which a macro is defined, and

   * a pattern language for specifying macro transformers.

The syntactic keyword of a macro can shadow variable bindings, and local
variable bindings can shadow syntactic bindings.  Two mechanisms are
provided to prevent unintended conflicts:

   * If a macro transformer inserts a binding for an identifier
     (variable or keyword), the identifier will in effect be renamed
     throughout its scope to avoid conflicts with other identifiers.
     Note that a global variable definition may or may not introduce a
     binding; see section *note Variable definitions::.

   * If a macro transformer inserts a free reference to an identifier,
     the reference refers to the binding that was visible where the
     transformer was specified, regardless of any local bindings that
     surround the use of the macro.

In consequence, all macros defined using the pattern language are
"hygienic" and "referentially transparent" and thus preserve Scheme's
lexical scoping.  [Kohlbecker86], [ hygienic], [Bawden88],
[macrosthatwork], [syntacticabstraction]

Implementations may provide macro facilities of other types.


File: r7rs.info,  Node: Binding constructs for syntactic keywords,  Next: Pattern language,  Prev: Macros,  Up: Macros

4.3.1 Binding constructs for syntactic keywords
-----------------------------------------------

The 'let-syntax' and 'letrec-syntax' binding constructs are analogous to
'let' and 'letrec', but they bind syntactic keywords to macro
transformers instead of binding variables to locations that contain
values.  Syntactic keywords can also be bound globally or locally with
'define-syntax'; see section *note Syntax definitions::.

 -- syntax: let-syntax <bindings> <body>

     _Syntax:_ <Bindings> has the form

     ((<keyword> <transformer spec>) ...)


     Each <keyword> is an identifier, each <transformer spec> is an
     instance of 'syntax-rules', and <body> is a sequence of zero or
     more definitions followed by one or more expressions.  It is an
     error for a <keyword> to appear more than once in the list of
     keywords being bound.

     _Semantics:_ The <body> is expanded in the syntactic environment
     obtained by extending the syntactic environment of the 'let-syntax'
     expression with macros whose keywords are the <keyword>s, bound to
     the specified transformers.  Each binding of a <keyword> has <body>
     as its region.

     (let-syntax ((given-that (syntax-rules ()
                          ((given-that test stmt1 stmt2 ...)
                           (if test
                               (begin stmt1
                                      stmt2 ...))))))
       (let ((if #t))
         (given-that if (set! if 'now))
         if))                               ==>  now

     (let ((x 'outer))
       (let-syntax ((m (syntax-rules () ((m) x))))
         (let ((x 'inner))
           (m))))                           ==>  outer


 -- syntax: letrec-syntax <bindings> <body>

     _Syntax:_ Same as for 'let-syntax'.

     _Semantics:_ The <body> is expanded in the syntactic environment
     obtained by extending the syntactic environment of the
     'letrec-syntax' expression with macros whose keywords are the
     <keyword>s, bound to the specified transformers.  Each binding of a
     <keyword> has the <transformer spec>s as well as the <body> within
     its region, so the transformers can transcribe expressions into
     uses of the macros introduced by the 'letrec-syntax' expression.

     (letrec-syntax
         ((my-or (syntax-rules ()
                   ((my-or) #f)
                   ((my-or e) e)
                   ((my-or e1 e2 ...)
                    (let ((temp e1))
                      (if temp
                          temp
                          (my-or e2 ...)))))))
       (let ((x #f)
             (y 7)
             (temp 8)
             (let odd?)
             (if even?))
         (my-or x
                (let temp)
                (if y)
                y)))                        ==>  7



File: r7rs.info,  Node: Pattern language,  Next: Signaling errors in macro transformers,  Prev: Binding constructs for syntactic keywords,  Up: Macros

4.3.2 Pattern language
----------------------

A <transformer spec> has one of the following forms:

 -- syntax: (syntax-rules (<pattern literal> ...)

     hspace*1em<syntax rule> ...)

 -- syntax: (syntax-rules <ellipsis> (<pattern literal> ...)

     hspace*1em<syntax rule> ...)

 -- auxiliary syntax:

 -- auxiliary syntax: ...

     _Syntax:_ It is an error if any of the <pattern literal>s, or the
     <ellipsis> in the second form, is not an identifier.  It is also an
     error if <syntax rule> is not of the form

     (<pattern> <template>)


     The <pattern> in a <syntax rule> is a list <pattern> whose first
     element is an identifier.

     A <pattern> is either an identifier, a constant, or one of the
     following

     (<pattern> ...)
     (<pattern> <pattern> ... . <pattern>)
     (<pattern> ... <pattern> <ellipsis> <pattern> ...)
     (<pattern> ... <pattern> <ellipsis> <pattern> ...
       . <pattern>)
     #(<pattern> ...)
     #(<pattern> ... <pattern> <ellipsis> <pattern> ...)


     and a <template> is either an identifier, a constant, or one of the
     following

     (<element> ...)
     (<element> <element> ... . <template>)
     (<ellipsis> <template>)
     #(<element> ...)


     where an <element> is a <template> optionally followed by an
     <ellipsis>.  An <ellipsis> is the identifier specified in the
     second form of 'syntax-rules', or the default identifier '...'
     (three consecutive periods) otherwise.

     _Semantics:_ An instance of 'syntax-rules' produces a new macro
     transformer by specifying a sequence of hygienic rewrite rules.  A
     use of a macro whose keyword is associated with a transformer
     specified by 'syntax-rules' is matched against the patterns
     contained in the <syntax rule>s, beginning with the leftmost
     <syntax rule>.  When a match is found, the macro use is transcribed
     hygienically according to the template.

     An identifier appearing within a <pattern> can be an underscore ('
     '), a literal identifier listed in the list of <pattern literal>s,
     or the <ellipsis>.  All other identifiers appearing within a
     <pattern> are _pattern variables_.

     The keyword at the beginning of the pattern in a <syntax rule> is
     not involved in the matching and is considered neither a pattern
     variable nor a literal identifier.

     Pattern variables match arbitrary input elements and are used to
     refer to elements of the input in the template.  It is an error for
     the same pattern variable to appear more than once in a <pattern>.

     Underscores also match arbitrary input elements but are not pattern
     variables and so cannot be used to refer to those elements.  If an
     underscore appears in the <pattern literal>s list, then that takes
     precedence and underscores in the <pattern> match as literals.
     Multiple underscores can appear in a <pattern>.

     Identifiers that appear in (<pattern literal> ...) are interpreted
     as literal identifiers to be matched against corresponding elements
     of the input.  An element in the input matches a literal identifier
     if and only if it is an identifier and either both its occurrence
     in the macro expression and its occurrence in the macro definition
     have the same lexical binding, or the two identifiers are the same
     and both have no lexical binding.

     A subpattern followed by <ellipsis> can match zero or more elements
     of the input, unless <ellipsis> appears in the <pattern literal>s,
     in which case it is matched as a literal.

     More formally, an input expression E matches a pattern P if and
     only if:

        * P is an underscore (' ').

        * P is a non-literal identifier; or

        * P is a literal identifier and E is an identifier with the same
          binding; or

        * P is a list '(P_1 ... P_n)' and E is a list of n elements that
          match P_1 through P_n, respectively; or

        * P is an improper list '(P_1 P_2 ... P_n . P_n+1)' and E is a
          list or improper list of n or more elements that match P_1
          through P_n, respectively, and whose nth tail matches P_n+1;
          or

        * P is of the form '(P_1 ... P_k P_e <ellipsis> P_m+1 ... P_n)'
          where E is a proper list of n elements, the first k of which
          match P_1 through P_k, respectively, whose next m-k elements
          each match P_e, whose remaining n-m elements match P_m+1
          through P_n; or

        * P is of the form '(P_1 ... P_k P_e <ellipsis> P_m+1 ... P_n .
          P_x)' where E is a list or improper list of n elements, the
          first k of which match P_1 through P_k, whose next m-k
          elements each match P_e, whose remaining n-m elements match
          P_m+1 through P_n, and whose nth and final cdr matches P_x; or

        * P is a vector of the form '#(P_1 ... P_n)' and E is a vector
          of n elements that match P_1 through P_n; or

        * P is of the form '#(P_1 ... P_k P_e <ellipsis> P_m+1 ... P_n)'
          where E is a vector of n elements the first k of which match
          P_1 through P_k, whose next m-k elements each match P_e, and
          whose remaining n-m elements match P_m+1 through P_n; or

        * P is a constant and E is equal to P in the sense of the
          'equal?' procedure.

     It is an error to use a macro keyword, within the scope of its
     binding, in an expression that does not match any of the patterns.

     When a macro use is transcribed according to the template of the
     matching <syntax rule>, pattern variables that occur in the
     template are replaced by the elements they match in the input.
     Pattern variables that occur in subpatterns followed by one or more
     instances of the identifier <ellipsis> are allowed only in
     subtemplates that are followed by as many instances of <ellipsis>.
     They are replaced in the output by all of the elements they match
     in the input, distributed as indicated.  It is an error if the
     output cannot be built up as specified.

     Identifiers that appear in the template but are not pattern
     variables or the identifier <ellipsis> are inserted into the output
     as literal identifiers.  If a literal identifier is inserted as a
     free identifier then it refers to the binding of that identifier
     within whose scope the instance of 'syntax-rules' appears.  If a
     literal identifier is inserted as a bound identifier then it is in
     effect renamed to prevent inadvertent captures of free identifiers.

     A template of the form '(<ellipsis> <template>)' is identical to
     <template>, except that ellipses within the template have no
     special meaning.  That is, any ellipses contained within <template>
     are treated as ordinary identifiers.  In particular, the template
     '(<ellipsis> <ellipsis>)' produces a single <ellipsis>.  This
     allows syntactic abstractions to expand into code containing
     ellipses.

     (define-syntax be-like-begin
       (syntax-rules ()
         ((be-like-begin name)
          (define-syntax name
            (syntax-rules ()
              ((name expr (... ...))
               (begin expr (... ...))))))))

     (be-like-begin sequence)
     (sequence 1 2 3 4)                     ==> 4


     As an example, if 'let' and 'cond' are defined as in section *note
     Derived expression type:: then they are hygienic (as required) and
     the following is not an error.

     (let ((=> #f))
       (cond (#t => 'ok)))                  ==> ok


     The macro transformer for 'cond' recognizes '=>' as a local
     variable, and hence an expression, and not as the base identifier
     '=>', which the macro transformer treats as a syntactic keyword.
     Thus the example expands into

     (let ((=> #f))
       (if #t (begin => 'ok)))


     instead of

     (let ((=> #f))
       (let ((temp #t))
         (if temp ('ok temp))))


     which would result in an invalid procedure call.


File: r7rs.info,  Node: Signaling errors in macro transformers,  Prev: Pattern language,  Up: Macros

4.3.3 Signaling errors in macro transformers
--------------------------------------------

 -- syntax: (syntax-error <message> <args> ...)

     'syntax-error' behaves similarly to 'error' (*note Exceptions::)
     except that implementations with an expansion pass separate from
     evaluation should signal an error as soon as 'syntax-error' is
     expanded.  This can be used as a 'syntax-rules' <template> for a
     <pattern> that is an invalid use of the macro, which can provide
     more descriptive error messages.  <message> is a string literal,
     and <args> arbitrary expressions providing additional information.
     Applications cannot count on being able to catch syntax errors with
     exception handlers or guards.

     (define-syntax simple-let
       (syntax-rules ()
         ((  (head ... ((x . y) val) . tail)
             body1 body2 ...)
          (syntax-error
           "expected an identifier but got"
           (x . y)))
         ((  ((name val) ...) body1 body2 ...)
          ((lambda (name ...) body1 body2 ...)
            val ...))))



File: r7rs.info,  Node: Program structure,  Next: Standard procedures,  Prev: Expressions,  Up: Top

5 Program structure
*******************

* Menu:

* Programs::
* Import declarations::
* Variable definitions::
* Syntax definitions::
* Record-type definitions::
* Libraries::
* The REPL::


File: r7rs.info,  Node: Programs,  Next: Import declarations,  Prev: Program structure,  Up: Program structure

5.1 Programs
============

A Scheme program consists of one or more import declarations followed by
a sequence of expressions and definitions.  Import declarations specify
the libraries on which a program or library depends; a subset of the
identifiers exported by the libraries are made available to the program.
Expressions are described in chapter *note Expressions::.  Definitions
are either variable definitions, syntax definitions, or record-type
definitions, all of which are explained in this chapter.  They are valid
in some, but not all, contexts where expressions are allowed,
specifically at the outermost level of a <program> and at the beginning
of a <body>.

At the outermost level of a program, (begin <expression or definition1>
...) is equivalent to the sequence of expressions and definitions in the
'begin'.  Similarly, in a <body>, (begin <definition1> ...) is
equivalent to the sequence <definition1> ....  Macros can expand into
such 'begin' forms.  For the formal definition, see *note Sequencing::.

Import declarations and definitions cause bindings to be created in the
global environment or modify the value of existing global bindings.  The
initial environment of a program is empty, so at least one import
declaration is needed to introduce initial bindings.

Expressions occurring at the outermost level of a program do not create
any bindings.  They are executed in order when the program is invoked or
loaded, and typically perform some kind of initialization.

Programs and libraries are typically stored in files, although in some
implementations they can be entered interactively into a running Scheme
system.  Other paradigms are possible.  Implementations which store
libraries in files should document the mapping from the name of a
library to its location in the file system.


File: r7rs.info,  Node: Import declarations,  Next: Variable definitions,  Prev: Programs,  Up: Program structure

5.2 Import declarations
=======================

An import declaration takes the following form:


     (import <import-set> ...)


An import declaration provides a way to import identifiers exported by a
library.  Each <import set> names a set of bindings from a library and
possibly specifies local names for the imported bindings.  It takes one
of the following forms:

   * <library name>
   * (only <import set> <identifier> ...)
   * (except <import set> <identifier> ...)
   * (prefix <import set> <identifier>)
   * (rename <import set>
   * hspace*4em(<identifier1> <identifier2>) ...)

In the first form, all of the identifiers in the named library's export
clauses are imported with the same names (or the exported names if
exported with 'rename').  The additional <import set> forms modify this
set as follows:

   * 'only' produces a subset of the given <import set> including only
     the listed identifiers (after any renaming).  It is an error if any
     of the listed identifiers are not found in the original set.

   * 'except' produces a subset of the given <import set>, excluding the
     listed identifiers (after any renaming).  It is an error if any of
     the listed identifiers are not found in the original set.

   * 'rename' modifies the given <import set>, replacing each instance
     of <identifier1> with <identifier2>.  It is an error if any of the
     listed <identifier1>s are not found in the original set.

   * 'prefix' automatically renames all identifiers in the given <import
     set>, prefixing each with the specified <identifier>.

In a program or library declaration, it is an error to import the same
identifier more than once with different bindings, or to redefine or
mutate an imported binding with a definition or with 'set!', or to refer
to an identifier before it is imported.  However, a REPL should permit
these actions.


File: r7rs.info,  Node: Variable definitions,  Next: Syntax definitions,  Prev: Import declarations,  Up: Program structure

5.3 Variable definitions
========================

* Menu:

* Top level definitions::
* Internal definitions::
* Multiple-value definitions::

A variable definition binds one or more identifiers and specifies an
initial value for each of them.  The simplest kind of variable
definition takes one of the following forms:

   * (define <variable> <expression>)

   * (define (<variable> <formals>) <body>)

     <Formals> are either a sequence of zero or more variables, or a
     sequence of one or more variables followed by a space-delimited
     period and another variable (as in a lambda expression).  This form
     is equivalent to


          (define <variable>
            (lambda (<formals>) <body>)).


   * (define (<variable> . <formal>) <body>)

     <Formal> is a single variable.  This form is equivalent to


          (define <variable>
            (lambda <formal> <body>)).



File: r7rs.info,  Node: Top level definitions,  Next: Internal definitions,  Prev: Variable definitions,  Up: Variable definitions

5.3.1 Top level definitions
---------------------------

At the outermost level of a program, a definition


     (define <variable> <expression>)


has essentially the same effect as the assignment expression


     (set! <variable> <expression>)


if <variable> is bound to a non-syntax value.  However, if <variable> is
not bound, or is a syntactic keyword, then the definition will bind
<variable> to a new location before performing the assignment, whereas
it would be an error to perform a 'set!' on an unbound variable.


     (define add3
       (lambda (x) (+ x 3)))
     (add3 3)                               ==>  6
     (define first car)
     (first '(1 2))                         ==>  1



File: r7rs.info,  Node: Internal definitions,  Next: Multiple-value definitions,  Prev: Top level definitions,  Up: Variable definitions

5.3.2 Internal definitions
--------------------------

Definitions can occur at the beginning of a <body> (that is, the body of
a 'lambda', 'let', 'let*', 'letrec', 'letrec*', 'let-values',
'let*-values', 'let-syntax', 'letrec-syntax', 'parameterize', 'guard',
or 'case-lambda').  Note that such a body might not be apparent until
after expansion of other syntax.  Such definitions are known as
_internal definitions_ as opposed to the global definitions described
above.  The variables defined by internal definitions are local to the
<body>.  That is, <variable> is bound rather than assigned, and the
region of the binding is the entire <body>.  For example,


     (let ((x 5))
       (define foo (lambda (y) (bar x y)))
       (define bar (lambda (a b) (+ (* a b) a)))
       (foo (+ x 3)))                       ==>  45


An expanded <body> containing internal definitions can always be
converted into a completely equivalent 'letrec*' expression.  For
example, the 'let' expression in the above example is equivalent to


     (let ((x 5))
       (letrec* ((foo (lambda (y) (bar x y)))
                 (bar (lambda (a b) (+ (* a b) a))))
         (foo (+ x 3))))


Just as for the equivalent 'letrec*' expression, it is an error if it is
not possible to evaluate each <expression> of every internal definition
in a <body> without assigning or referring to the value of the
corresponding <variable> or the <variable> of any of the definitions
that follow it in <body>.

It is an error to define the same identifier more than once in the same
<body>.

Wherever an internal definition can occur, (begin <definition1> ...) is
equivalent to the sequence of definitions that form the body of the
'begin'.


File: r7rs.info,  Node: Multiple-value definitions,  Prev: Internal definitions,  Up: Variable definitions

5.3.3 Multiple-value definitions
--------------------------------

Another kind of definition is provided by 'define-values', which creates
multiple definitions from a single expression returning multiple values.
It is allowed wherever 'define' is allowed.

 -- syntax: define-values <formals> <expression>

     It is an error if a variable appears more than once in the set of
     <formals>.

     _Semantics:_ <Expression> is evaluated, and the <formals> are bound
     to the return values in the same way that the <formals> in a
     'lambda' expression are matched to the arguments in a procedure
     call.

     (define-values (x y) (exact-integer-sqrt 17))
     (list x y)                             ==> (4 1)

     (let ()
       (define-values (x y) (values 1 2))
       (+ x y))                             ==> 3



File: r7rs.info,  Node: Syntax definitions,  Next: Record-type definitions,  Prev: Variable definitions,  Up: Program structure

5.4 Syntax definitions
======================

Syntax definitions have this form:

(define-syntax <keyword> <transformer spec>)

<Keyword> is an identifier, and the <transformer spec> is an instance of
'syntax-rules'.  Like variable definitions, syntax definitions can
appear at the outermost level or nested within a 'body'.

If the 'define-syntax' occurs at the outermost level, then the global
syntactic environment is extended by binding the <keyword> to the
specified transformer, but previous expansions of any global binding for
<keyword> remain unchanged.  Otherwise, it is an "internal syntax
definition", and is local to the <body> in which it is defined.  Any use
of a syntax keyword before its corresponding definition is an error.  In
particular, a use that precedes an inner definition will not apply an
outer definition.


     (let ((x 1) (y 2))
       (define-syntax swap!
         (syntax-rules ()
           ((swap! a b)
            (let ((tmp a))
              (set! a b)
              (set! b tmp)))))
       (swap! x y)
       (list x y))                          ==> (2 1)


Macros can expand into definitions in any context that permits them.
However, it is an error for a definition to define an identifier whose
binding has to be known in order to determine the meaning of the
definition itself, or of any preceding definition that belongs to the
same group of internal definitions.  Similarly, it is an error for an
internal definition to define an identifier whose binding has to be
known in order to determine the boundary between the internal
definitions and the expressions of the body it belongs to.  For example,
the following are errors:


     (define define 3)

     (begin (define begin list))

     (let-syntax
         ((foo (syntax-rules ()
                 ((foo (proc args ...) body ...)
                  (define proc
                    (lambda (args ...)
                      body ...))))))
       (let ((x 3))
         (foo (plus x y) (+ x y))
         (define foo x)
         (plus foo x)))



File: r7rs.info,  Node: Record-type definitions,  Next: Libraries,  Prev: Syntax definitions,  Up: Program structure

5.5 Record-type definitions
===========================

"Record-type definitions" are used to introduce new data types, called
"record types".  Like other definitions, they can appear either at the
outermost level or in a body.  The values of a record type are called
"records" and are aggregations of zero or more "fields", each of which
holds a single location.  A predicate, a constructor, and field
accessors and mutators are defined for each record type.

 -- syntax: (define-record-type <name>

     hspace*4em<constructor> <pred> <field> ...)

     _Syntax:_ <name> and <pred> are identifiers.  The <constructor> is
     of the form

     (<constructor name> <field name> ...)


     and each <field> is either of the form

     (<field name> <accessor name>)


     or of the form

     (<field name> <accessor name> <modifier name>)


     It is an error for the same identifier to occur more than once as a
     field name.  It is also an error for the same identifier to occur
     more than once as an accessor or mutator name.

     The 'define-record-type' construct is generative: each use creates
     a new record type that is distinct from all existing types,
     including Scheme's predefined types and other record types -- even
     record types of the same name or structure.

     An instance of 'define-record-type' is equivalent to the following
     definitions:

        * <name> is bound to a representation of the record type itself.
          This may be a run-time object or a purely syntactic
          representation.  The representation is not utilized in this
          report, but it serves as a means to identify the record type
          for use by further language extensions.

        * <constructor name> is bound to a procedure that takes as many
          arguments as there are <field name>s in the (<constructor
          name> ...) subexpression and returns a new record of type
          <name>.  Fields whose names are listed with <constructor name>
          have the corresponding argument as their initial value.  The
          initial values of all other fields are unspecified.  It is an
          error for a field name to appear in <constructor> but not as a
          <field name>.

        * <pred> is bound to a predicate that returns #t when given a
          value returned by the procedure bound to <constructor name>
          and #f for everything else.

        * Each <accessor name> is bound to a procedure that takes a
          record of type <name> and returns the current value of the
          corresponding field.  It is an error to pass an accessor a
          value which is not a record of the appropriate type.

        * Each <modifier name> is bound to a procedure that takes a
          record of type <name> and a value which becomes the new value
          of the corresponding field; an unspecified value is returned.
          It is an error to pass a modifier a first argument which is
          not a record of the appropriate type.

     For instance, the following record-type definition

     (define-record-type <pare>
       (kons x y)
       pare?
       (x kar set-kar!)
       (y kdr))


     defines 'kons' to be a constructor, 'kar' and 'kdr' to be
     accessors, 'set-kar!' to be a modifier, and 'pare?' to be a
     predicate for instances of '<pare>'.

       (pare? (kons 1 2))                   ==> #t
       (pare? (cons 1 2))                   ==> #f
       (kar (kons 1 2))                     ==> 1
       (kdr (kons 1 2))                     ==> 2
       (let ((k (kons 1 2)))
         (set-kar! k 3)
         (kar k))                           ==> 3



File: r7rs.info,  Node: Libraries,  Next: The REPL,  Prev: Record-type definitions,  Up: Program structure

5.6 Libraries
=============

* Menu:

* Library Syntax::
* Library example::

Libraries provide a way to organize Scheme programs into reusable parts
with explicitly defined interfaces to the rest of the program.  This
section defines the notation and semantics for libraries.


File: r7rs.info,  Node: Library Syntax,  Next: Library example,  Prev: Libraries,  Up: Libraries

5.6.1 Library Syntax
--------------------

A library definition takes the following form:


     (define-library <library name>
       <library declaration> ...)


<library name> is a list whose members are identifiers and exact
non-negative integers.  It is used to identify the library uniquely when
importing from other programs or libraries.  Libraries whose first
identifier is 'scheme' are reserved for use by this report and future
versions of this report.  Libraries whose first identifier is 'srfi' are
reserved for libraries implementing Scheme Requests for Implementation.
It is inadvisable, but not an error, for identifiers in library names to
contain any of the characters '| \? * < " : > + [ ] /' or control
characters after escapes are expanded.

A <library declaration> is any of:

   * (export <export spec> ...)

   * (import <import set> ...)

   * (begin <command or definition> ...)

   * (include <filename1> <filename2> ...)

   * (include-ci <filename1> <filename2> ...)

   * (include-library-declarations <filename1> <filename2> ...)

   * (cond-expand <ce-clause1> <ce-clause2> ...)

An 'export' declaration specifies a list of identifiers which can be
made visible to other libraries or programs.  An <export spec> takes one
of the following forms:

   * <identifier>
   * (rename <identifier1> <identifier2>)

In an <export spec>, an <identifier> names a single binding defined
within or imported into the library, where the external name for the
export is the same as the name of the binding within the library.  A
'rename' spec exports the binding defined within or imported into the
library and named by <identifier1> in each (<identifier1> <identifier2>)
pairing, using <identifier2> as the external name.

An 'import' declaration provides a way to import the identifiers
exported by another library.  It has the same syntax and semantics as an
import declaration used in a program or at the REPL (see section *note
import::).

The 'begin', 'include', and 'include-ci' declarations are used to
specify the body of the library.  They have the same syntax and
semantics as the corresponding expression types.  This form of 'begin'
is analogous to, but not the same as, the two types of 'begin' defined
in section *note Sequencing::.

The 'include-library-declarations' declaration is similar to 'include'
except that the contents of the file are spliced directly into the
current library definition.  This can be used, for example, to share the
same 'export' declaration among multiple libraries as a simple form of
library interface.

The 'cond-expand' declaration has the same syntax and semantics as the
'cond-expand' expression type, except that it expands to spliced-in
library declarations rather than expressions enclosed in 'begin'.

One possible implementation of libraries is as follows: After all
'cond-expand' library declarations are expanded, a new environment is
constructed for the library consisting of all imported bindings.  The
expressions from all 'begin', 'include' and 'include-ci' library
declarations are expanded in that environment in the order in which they
occur in the library.  Alternatively, 'cond-expand' and 'import'
declarations may be processed in left to right order interspersed with
the processing of other declarations, with the environment growing as
imported bindings are added to it by each 'import' declaration.

When a library is loaded, its expressions are executed in textual order.
If a library's definitions are referenced in the expanded form of a
program or library body, then that library must be loaded before the
expanded program or library body is evaluated.  This rule applies
transitively.  If a library is imported by more than one program or
library, it may possibly be loaded additional times.

Similarly, during the expansion of a library '(foo)', if any syntax
keywords imported from another library '(bar)' are needed to expand the
library, then the library '(bar)' must be expanded and its syntax
definitions evaluated before the expansion of '(foo)'.

Regardless of the number of times that a library is loaded, each program
or library that imports bindings from a library must do so from a single
loading of that library, regardless of the number of import declarations
in which it appears.  That is, '(import (only (foo) a))' followed by
'(import (only (foo) b))' has the same effect as '(import (only (foo) a
b))'.


File: r7rs.info,  Node: Library example,  Prev: Library Syntax,  Up: Libraries

5.6.2 Library example
---------------------

The following example shows how a program can be divided into libraries
plus a relatively small main program [life].  If the main program is
entered into a REPL, it is not necessary to import the base library.


     (define-library (example grid)
       (export make rows cols ref each
               (rename put! set!))
       (import (scheme base))
       (begin
         ;; Create an NxM grid.
         (define (make n m)
           (let ((grid (make-vector n)))
             (do ((i 0 (+ i 1)))
                 ((= i n) grid)
               (let ((v (make-vector m #false)))
                 (vector-set! grid i v)))))
         (define (rows grid)
           (vector-length grid))
         (define (cols grid)
           (vector-length (vector-ref grid 0)))
         ;; Return #false if out of range.
         (define (ref grid n m)
           (and (< -1 n (rows grid))
                (< -1 m (cols grid))
                (vector-ref (vector-ref grid n) m)))
         (define (put! grid n m v)
           (vector-set! (vector-ref grid n) m v))
         (define (each grid proc)
           (do ((j 0 (+ j 1)))
               ((= j (rows grid)))
             (do ((k 0 (+ k 1)))
                 ((= k (cols grid)))
               (proc j k (ref grid j k)))))))

     (define-library (example life)
       (export life)
       (import (except (scheme base) set!)
               (scheme write)
               (example grid))
       (begin
         (define (life-count grid i j)
           (define (count i j)
             (if (ref grid i j) 1 0))
           (+ (count (- i 1) (- j 1))
              (count (- i 1) j)
              (count (- i 1) (+ j 1))
              (count i (- j 1))
              (count i (+ j 1))
              (count (+ i 1) (- j 1))
              (count (+ i 1) j)
              (count (+ i 1) (+ j 1))))
         (define (life-alive? grid i j)
           (case (life-count grid i j)
             ((3) #true)
             ((2) (ref grid i j))
             (else #false)))
         (define (life-print grid)
           (display "\x1B;[1H\x1B;[J")  ; clear vt100
           (each grid
            (lambda (i j v)
              (display (if v "*" " "))
              (when (= j (- (cols grid) 1))
                (newline)))))
         (define (life grid iterations)
           (do ((i 0 (+ i 1))
                (grid0 grid grid1)
                (grid1 (make (rows grid) (cols grid))
                       grid0))
               ((= i iterations))
             (each grid0
              (lambda (j k v)
                (let ((a (life-alive? grid0 j k)))
                  (set! grid1 j k a))))
             (life-print grid1)))))

     ;; Main program.
     (import (scheme base)
             (only (example life) life)
             (rename (prefix (example grid) grid-)
                     (grid-make make-grid)))

     ;; Initialize a grid with a glider.
     (define grid (make-grid 24 24))
     (grid-set! grid 1 1 #true)
     (grid-set! grid 2 2 #true)
     (grid-set! grid 3 0 #true)
     (grid-set! grid 3 1 #true)
     (grid-set! grid 3 2 #true)

     ;; Run for 80 iterations.
     (life grid 80)




File: r7rs.info,  Node: The REPL,  Prev: Libraries,  Up: Program structure

5.7 The REPL
============

Implementations may provide an interactive session called a "REPL"
(Read-Eval-Print Loop), where import declarations, expressions and
definitions can be entered and evaluated one at a time.  For convenience
and ease of use, the global Scheme environment in a REPL must not be
empty, but must start out with at least the bindings provided by the
base library.  This library includes the core syntax of Scheme and
generally useful procedures that manipulate data.  For example, the
variable 'abs' is bound to a procedure of one argument that computes the
absolute value of a number, and the variable '+' is bound to a procedure
that computes sums.  The full list of '(scheme base)' bindings can be
found in Appendix *note Standard Libraries::.

Implementations may provide an initial REPL environment which behaves as
if all possible variables are bound to locations, most of which contain
unspecified values.  Top level REPL definitions in such an
implementation are truly equivalent to assignments, unless the
identifier is defined as a syntax keyword.

An implementation may provide a mode of operation in which the REPL
reads its input from a file.  Such a file is not, in general, the same
as a program, because it can contain import declarations in places other
than the beginning.


File: r7rs.info,  Node: Standard procedures,  Next: Formal syntax and semantics,  Prev: Program structure,  Up: Top

6 Standard procedures
*********************

* Menu:

* Equivalence predicates::
* Numbers::
* Booleans::
* Pairs and lists::
* Symbols::
* Characters::
* Strings::
* Vectors::
* Bytevectors::
* Control features::
* Exceptions::
* Environments and evaluation::
* Input and output::
* System interface::

This chapter describes Scheme's built-in procedures.

The procedures 'force', 'promise?', and 'make-promise' are intimately
associated with the expression types 'delay' and 'delay-force', and are
described with them in section *note Delayed evaluation::.  In the same
way, the procedure 'make-parameter' is intimately associated with the
expression type 'parameterize', and is described with it in section
*note Dynamic bindings::.

A program can use a global variable definition to bind any variable.  It
may subsequently alter any such binding by an assignment (see section
*note Assignments::).  These operations do not modify the behavior of
any procedure defined in this report or imported from a library (see
section *note Libraries::).  Altering any global binding that has not
been introduced by a definition has an unspecified effect on the
behavior of the procedures defined in this chapter.

When a procedure is said to return a "newly allocated" object, it means
that the locations in the object are fresh.


File: r7rs.info,  Node: Equivalence predicates,  Next: Numbers,  Prev: Standard procedures,  Up: Standard procedures

6.1 Equivalence predicates
==========================

A "predicate" is a procedure that always returns a boolean value (#t or
#f).  An "equivalence predicate" is the computational analogue of a
mathematical equivalence relation; it is symmetric, reflexive, and
transitive.  Of the equivalence predicates described in this section,
'eq?' is the finest or most discriminating, 'equal?' is the coarsest,
and 'eqv?' is slightly less discriminating than 'eq?'.

 -- procedure: eqv? obj1 obj2

     The 'eqv?' procedure defines a useful equivalence relation on
     objects.  Briefly, it returns #t if OBJ1 and OBJ2 are normally
     regarded as the same object.  This relation is left slightly open
     to interpretation, but the following partial specification of
     'eqv?' holds for all implementations of Scheme.

     The 'eqv?' procedure returns #t if:

        * OBJ1 and OBJ2 are both #t or both #f.

        * OBJ1 and OBJ2 are both symbols and are the same symbol
          according to the 'symbol=?' procedure (section *note
          Symbols::).

        * OBJ1 and OBJ2 are both exact numbers and are numerically equal
          (in the sense of '=').

        * OBJ1 and OBJ2 are both inexact numbers such that they are
          numerically equal (in the sense of '=') and they yield the
          same results (in the sense of 'eqv?') when passed as arguments
          to any other procedure that can be defined as a finite
          composition of Scheme's standard arithmetic procedures,
          provided it does not result in a NaN value.

        * OBJ1 and OBJ2 are both characters and are the same character
          according to the 'char=?' procedure (section *note
          Characters::).

        * OBJ1 and OBJ2 are both the empty list.

        * OBJ1 and OBJ2 are pairs, vectors, bytevectors, records, or
          strings that denote the same location in the store (section
          *note Storage model::).

        * OBJ1 and OBJ2 are procedures whose location tags are equal
          (section *note Procedures::).

     The 'eqv?' procedure returns #f if:

        * OBJ1 and OBJ2 are of different types (section *note
          Disjointness of types::).

        * one of OBJ1 and OBJ2 is #t but the other is #f.

        * OBJ1 and OBJ2 are symbols but are not the same symbol
          according to the 'symbol=?' procedure (section *note
          Symbols::).

        * one of OBJ1 and OBJ2 is an exact number but the other is an
          inexact number.

        * OBJ1 and OBJ2 are both exact numbers and are numerically
          unequal (in the sense of '=').

        * OBJ1 and OBJ2 are both inexact numbers such that either they
          are numerically unequal (in the sense of '='), or they do not
          yield the same results (in the sense of 'eqv?') when passed as
          arguments to any other procedure that can be defined as a
          finite composition of Scheme's standard arithmetic procedures,
          provided it does not result in a NaN value.  As an exception,
          the behavior of 'eqv?' is unspecified when both OBJ1 and OBJ2
          are NaN.

        * OBJ1 and OBJ2 are characters for which the 'char=?' procedure
          returns #f.

        * one of OBJ1 and OBJ2 is the empty list but the other is not.

        * OBJ1 and OBJ2 are pairs, vectors, bytevectors, records, or
          strings that denote distinct locations.

        * OBJ1 and OBJ2 are procedures that would behave differently
          (return different values or have different side effects) for
          some arguments.

     (eqv? 'a 'a)                           ==>  #t
     (eqv? 'a 'b)                           ==>  #f
     (eqv? 2 2)                             ==>  #t
     (eqv? 2 2.0)                           ==>  #f
     (eqv? '() '())                         ==>  #t
     (eqv? 100000000 100000000)             ==>  #t
     (eqv? 0.0 +nan.0)                      ==>  #f
     (eqv? (cons 1 2) (cons 1 2))           ==>  #f
     (eqv? (lambda () 1)
           (lambda () 2))                   ==>  #f
     (let ((p (lambda (x) x)))
       (eqv? p p))                          ==>  #t
     (eqv? #f 'nil)                         ==>  #f


     The following examples illustrate cases in which the above rules do
     not fully specify the behavior of 'eqv?'.  All that can be said
     about such cases is that the value returned by 'eqv?' must be a
     boolean.

     (eqv? "" "")                           ==>  _unspecified_
     (eqv? '#() '#())                       ==>  _unspecified_
     (eqv? (lambda (x) x)
           (lambda (x) x))                  ==>  _unspecified_
     (eqv? (lambda (x) x)
           (lambda (y) y))                  ==>  _unspecified_
     (eqv? 1.0e0 1.0f0)                     ==>  _unspecified_
     (eqv? +nan.0 +nan.0)                   ==>  _unspecified_


     Note that '(eqv? 0.0 -0.0)' will return #f if negative zero is
     distinguished, and #t if negative zero is not distinguished.

     The next set of examples shows the use of 'eqv?' with procedures
     that have local state.  The 'gen-counter' procedure must return a
     distinct procedure every time, since each procedure has its own
     internal counter.  The 'gen-loser' procedure, however, returns
     operationally equivalent procedures each time, since the local
     state does not affect the value or side effects of the procedures.
     However, 'eqv?' may or may not detect this equivalence.

     (define gen-counter
       (lambda ()
         (let ((n 0))
           (lambda () (set! n (+ n 1)) n))))
     (let ((g (gen-counter)))
       (eqv? g g))                          ==>  #t
     (eqv? (gen-counter) (gen-counter))
                                            ==>  #f
     (define gen-loser
       (lambda ()
         (let ((n 0))
           (lambda () (set! n (+ n 1)) 27))))
     (let ((g (gen-loser)))
       (eqv? g g))                          ==>  #t
     (eqv? (gen-loser) (gen-loser))
                                            ==>  _unspecified_

     (letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
              (g (lambda () (if (eqv? f g) 'both 'g))))
       (eqv? f g))
                                            ==>  _unspecified_

     (letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
              (g (lambda () (if (eqv? f g) 'g 'both))))
       (eqv? f g))
                                            ==>  #f


     Since it is an error to modify constant objects (those returned by
     literal expressions), implementations may share structure between
     constants where appropriate.  Thus the value of 'eqv?' on constants
     is sometimes implementation-dependent.

     (eqv? '(a) '(a))                       ==>  _unspecified_
     (eqv? "a" "a")                         ==>  _unspecified_
     (eqv? '(b) (cdr '(a b)))               ==>  _unspecified_
     (let ((x '(a)))
       (eqv? x x))                          ==>  #t


     The above definition of 'eqv?' allows implementations latitude in
     their treatment of procedures and literals: implementations may
     either detect or fail to detect that two procedures or two literals
     are equivalent to each other, and can decide whether or not to
     merge representations of equivalent objects by using the same
     pointer or bit pattern to represent both.

          _Note:_ If inexact numbers are represented as IEEE binary
          floating-point numbers, then an implementation of 'eqv?' that
          simply compares equal-sized inexact numbers for bitwise
          equality is correct by the above definition.

 -- procedure: eq? obj1 obj2

     The 'eq?' procedure is similar to 'eqv?' except that in some cases
     it is capable of discerning distinctions finer than those
     detectable by 'eqv?'.  It must always return #f when 'eqv?' also
     would, but may return #f in some cases where 'eqv?' would return
     #t.

     On symbols, booleans, the empty list, pairs, and records, and also
     on non-empty strings, vectors, and bytevectors, 'eq?' and 'eqv?'
     are guaranteed to have the same behavior.  On procedures, 'eq?'
     must return true if the arguments' location tags are equal.  On
     numbers and characters, 'eq?''s behavior is
     implementation-dependent, but it will always return either true or
     false.  On empty strings, empty vectors, and empty bytevectors,
     'eq?' may also behave differently from 'eqv?'.

     (eq? 'a 'a)                            ==>  #t
     (eq? '(a) '(a))                        ==>  _unspecified_
     (eq? (list 'a) (list 'a))              ==>  #f
     (eq? "a" "a")                          ==>  _unspecified_
     (eq? "" "")                            ==>  _unspecified_
     (eq? '() '())                          ==>  #t
     (eq? 2 2)                              ==>  _unspecified_
     (eq? #\A #\A)                          ==>  _unspecified_
     (eq? car car)                          ==>  #t
     (let ((n (+ 2 3)))
       (eq? n n))                           ==>  _unspecified_
     (let ((x '(a)))
       (eq? x x))                           ==>  #t
     (let ((x '#()))
       (eq? x x))                           ==>  #t
     (let ((p (lambda (x) x)))
       (eq? p p))                           ==>  #t


          _Rationale:_ It will usually be possible to implement 'eq?'
          much more efficiently than 'eqv?', for example, as a simple
          pointer comparison instead of as some more complicated
          operation.  One reason is that it is not always possible to
          compute 'eqv?' of two numbers in constant time, whereas 'eq?'
          implemented as pointer comparison will always finish in
          constant time.

 -- procedure: equal? obj1 obj2

     The 'equal?' procedure, when applied to pairs, vectors, strings and
     bytevectors, recursively compares them, returning #t when the
     unfoldings of its arguments into (possibly infinite) trees are
     equal (in the sense of 'equal?') as ordered trees, and #f
     otherwise.  It returns the same as 'eqv?' when applied to booleans,
     symbols, numbers, characters, ports, procedures, and the empty
     list.  If two objects are 'eqv?', they must be 'equal?' as well.
     In all other cases, 'equal?' may return either #t or #f.

     Even if its arguments are circular data structures, 'equal?' must
     always terminate.

     (equal? 'a 'a)                         ==>  #t
     (equal? '(a) '(a))                     ==>  #t
     (equal? '(a (b) c)
             '(a (b) c))                    ==>  #t
     (equal? "abc" "abc")                   ==>  #t
     (equal? 2 2)                           ==>  #t
     (equal? (make-vector 5 'a)
             (make-vector 5 'a))            ==>  #t
     (equal? '#1=(a b . #1#)
             '#2=(a b a b . #2#))           ==>  #t
     (equal? (lambda (x) x)
             (lambda (y) y))                ==>  _unspecified_


          _Note:_ A rule of thumb is that objects are generally 'equal?'
          if they print the same.


File: r7rs.info,  Node: Numbers,  Next: Booleans,  Prev: Equivalence predicates,  Up: Standard procedures

6.2 Numbers
===========

* Menu:

* Numerical types::
* Exactness::
* Implementation restrictions::
* Implementation extensions::
* Syntax of numerical constants::
* Numerical operations::
* Numerical input and output::

It is important to distinguish between mathematical numbers, the Scheme
numbers that attempt to model them, the machine representations used to
implement the Scheme numbers, and notations used to write numbers.  This
report uses the types number, complex, real, rational, and integer to
refer to both mathematical numbers and Scheme numbers.


File: r7rs.info,  Node: Numerical types,  Next: Exactness,  Prev: Numbers,  Up: Numbers

6.2.1 Numerical types
---------------------

Mathematically, numbers are arranged into a tower of subtypes in which
each level is a subset of the level above it:

         number
          complex number
          real number
          rational number
          integer

For example, 3 is an integer.  Therefore 3 is also a rational, a real,
and a complex number.  The same is true of the Scheme numbers that model
3.  For Scheme numbers, these types are defined by the predicates
'number?', 'complex?', 'real?', 'rational?', and 'integer?'.

There is no simple relationship between a number's type and its
representation inside a computer.  Although most implementations of
Scheme will offer at least two different representations of 3, these
different representations denote the same integer.

Scheme's numerical operations treat numbers as abstract data, as
independent of their representation as possible.  Although an
implementation of Scheme may use multiple internal representations of
numbers, this ought not to be apparent to a casual programmer writing
simple programs.


File: r7rs.info,  Node: Exactness,  Next: Implementation restrictions,  Prev: Numerical types,  Up: Numbers

6.2.2 Exactness
---------------

It is useful to distinguish between numbers that are represented exactly
and those that might not be.  For example, indexes into data structures
must be known exactly, as must some polynomial coefficients in a
symbolic algebra system.  On the other hand, the results of measurements
are inherently inexact, and irrational numbers may be approximated by
rational and therefore inexact approximations.  In order to catch uses
of inexact numbers where exact numbers are required, Scheme explicitly
distinguishes exact from inexact numbers.  This distinction is
orthogonal to the dimension of type.

A Scheme number is exact if it was written as an exact constant or was
derived from exact numbers using only exact operations.  A number is
inexact if it was written as an inexact constant, if it was derived
using inexact ingredients, or if it was derived using inexact
operations.  Thus inexactness is a contagious property of a number.  In
particular, an "exact complex number" has an exact real part and an
exact imaginary part; all other complex numbers are "inexact complex
numbers".  complex numbers

If two implementations produce exact results for a computation that did
not involve inexact intermediate results, the two ultimate results will
be mathematically equal.  This is generally not true of computations
involving inexact numbers since approximate methods such as
floating-point arithmetic may be used, but it is the duty of each
implementation to make the result as close as practical to the
mathematically ideal result.

Rational operations such as '+' should always produce exact results when
given exact arguments.  If the operation is unable to produce an exact
result, then it may either report the violation of an implementation
restriction or it may silently coerce its result to an inexact value.
However, '(/ 3 4)' must not return the mathematically incorrect value
'0'.  See section *note Implementation restrictions::.

Except for 'exact', the operations described in this section must
generally return inexact results when given any inexact arguments.  An
operation may, however, return an exact result if it can prove that the
value of the result is unaffected by the inexactness of its arguments.
For example, multiplication of any number by an exact zero may produce
an exact zero result, even if the other argument is inexact.

Specifically, the expression '(* 0 +inf.0)' may return '0', or '+nan.0',
or report that inexact numbers are not supported, or report that
non-rational real numbers are not supported, or fail silently or noisily
in other implementation-specific ways.


File: r7rs.info,  Node: Implementation restrictions,  Next: Implementation extensions,  Prev: Exactness,  Up: Numbers

6.2.3 Implementation restrictions
---------------------------------

Implementations of Scheme are not required to implement the whole tower
of subtypes given in section *note Numerical types::, but they must
implement a coherent subset consistent with both the purposes of the
implementation and the spirit of the Scheme language.  For example,
implementations in which all numbers are real, or in which non-real
numbers are always inexact, or in which exact numbers are always
integer, are still quite useful.

Implementations may also support only a limited range of numbers of any
type, subject to the requirements of this section.  The supported range
for exact numbers of any type may be different from the supported range
for inexact numbers of that type.  For example, an implementation that
uses IEEE binary double-precision floating-point numbers to represent
all its inexact real numbers may also support a practically unbounded
range of exact integers and rationals while limiting the range of
inexact reals (and therefore the range of inexact integers and
rationals) to the dynamic range of the IEEE binary double format.
Furthermore, the gaps between the representable inexact integers and
rationals are likely to be very large in such an implementation as the
limits of this range are approached.

An implementation of Scheme must support exact integers throughout the
range of numbers permitted as indexes of lists, vectors, bytevectors,
and strings or that result from computing the length of one of these.
The 'length', 'vector-length', 'bytevector-length', and 'string-length'
procedures must return an exact integer, and it is an error to use
anything but an exact integer as an index.  Furthermore, any integer
constant within the index range, if expressed by an exact integer
syntax, must be read as an exact integer, regardless of any
implementation restrictions that apply outside this range.  Finally, the
procedures listed below will always return exact integer results
provided all their arguments are exact integers and the mathematically
expected results are representable as exact integers within the
implementation:


     -                     *
     +                     abs
     ceiling               denominator
     exact-integer-sqrt    expt
     floor                 floor/
     floor-quotient        floor-remainder
     gcd                   lcm
     max                   min
     modulo                numerator
     quotient              rationalize
     remainder             round
     square                truncate
     truncate/             truncate-quotient
     truncate-remainder


It is recommended, but not required, that implementations support exact
integers and exact rationals of practically unlimited size and
precision, and to implement the above procedures and the '/' procedure
in such a way that they always return exact results when given exact
arguments.  If one of these procedures is unable to deliver an exact
result when given exact arguments, then it may either report a violation
of an implementation restriction or it may silently coerce its result to
an inexact number; such a coercion can cause an error later.
Nevertheless, implementations that do not provide exact rational numbers
should return inexact rational numbers rather than reporting an
implementation restriction.

An implementation may use floating-point and other approximate
representation strategies for inexact numbers.  This report recommends,
but does not require, that implementations that use floating-point
representations follow the IEEE 754 standard, and that implementations
using other representations should match or exceed the precision
achievable using these floating-point standards [IEEE]. In particular,
the description of transcendental functions in IEEE 754-2008 should be
followed by such implementations, particularly with respect to
infinities and NaNs.

Although Scheme allows a variety of written notations for numbers, any
particular implementation may support only some of them.  For example,
an implementation in which all numbers are real need not support the
rectangular and polar notations for complex numbers.  If an
implementation encounters an exact numerical constant that it cannot
represent as an exact number, then it may either report a violation of
an implementation restriction or it may silently represent the constant
by an inexact number.


File: r7rs.info,  Node: Implementation extensions,  Next: Syntax of numerical constants,  Prev: Implementation restrictions,  Up: Numbers

6.2.4 Implementation extensions
-------------------------------

Implementations may provide more than one representation of
floating-point numbers with differing precisions.  In an implementation
which does so, an inexact result must be represented with at least as
much precision as is used to express any of the inexact arguments to
that operation.  Although it is desirable for potentially inexact
operations such as 'sqrt' to produce exact answers when applied to exact
arguments, if an exact number is operated upon so as to produce an
inexact result, then the most precise representation available must be
used.  For example, the value of '(sqrt 4)' should be '2', but in an
implementation that provides both single and double precision floating
point numbers it may be the latter but must not be the former.

It is the programmer's responsibility to avoid using inexact number
objects with magnitude or significand too large to be represented in the
implementation.

In addition, implementations may distinguish special numbers called
positive infinity, negative infinity, NaN, and negative zero.

Positive infinity is regarded as an inexact real (but not rational)
number that represents an indeterminate value greater than the numbers
represented by all rational numbers.  Negative infinity is regarded as
an inexact real (but not rational) number that represents an
indeterminate value less than the numbers represented by all rational
numbers.

Adding or multiplying an infinite value by any finite real value results
in an appropriately signed infinity; however, the sum of positive and
negative infinities is a NaN. Positive infinity is the reciprocal of
zero, and negative infinity is the reciprocal of negative zero.  The
behavior of the transcendental functions is sensitive to infinity in
accordance with IEEE 754.

A NaN is regarded as an inexact real (but not rational) number so
indeterminate that it might represent any real value, including positive
or negative infinity, and might even be greater than positive infinity
or less than negative infinity.  An implementation that does not support
non-real numbers may use NaN to represent non-real values like '(sqrt
-1.0)' and '(asin 2.0)'.

A NaN always compares false to any number, including a NaN. An
arithmetic operation where one operand is NaN returns NaN, unless the
implementation can prove that the result would be the same if the NaN
were replaced by any rational number.  Dividing zero by zero results in
NaN unless both zeros are exact.

Negative zero is an inexact real value written '-0.0' and is distinct
(in the sense of 'eqv?') from '0.0'.  A Scheme implementation is not
required to distinguish negative zero.  If it does, however, the
behavior of the transcendental functions is sensitive to the distinction
in accordance with IEEE 754.  Specifically, in a Scheme implementing
both complex numbers and negative zero, the branch cut of the complex
logarithm function is such that '(imag-part (log -1.0-0.0i))' is -pi
rather than pi.

Furthermore, the negation of negative zero is ordinary zero and vice
versa.  This implies that the sum of two or more negative zeros is
negative, and the result of subtracting (positive) zero from a negative
zero is likewise negative.  However, numerical comparisons treat
negative zero as equal to zero.

Note that both the real and the imaginary parts of a complex number can
be infinities, NaNs, or negative zero.


File: r7rs.info,  Node: Syntax of numerical constants,  Next: Numerical operations,  Prev: Implementation extensions,  Up: Numbers

6.2.5 Syntax of numerical constants
-----------------------------------

The syntax of the written representations for numbers is described
formally in section *note Lexical structure::.  Note that case is not
significant in numerical constants.

A number can be written in binary, octal, decimal, or hexadecimal by the
use of a radix prefix.  The radix prefixes are '#b' (binary), '#o'
(octal), '#d' (decimal), and '#x' (hexadecimal).  With no radix prefix,
a number is assumed to be expressed in decimal.

A numerical constant can be specified to be either exact or inexact by a
prefix.  The prefixes are '#e' for exact, and '#i' for inexact.  An
exactness prefix can appear before or after any radix prefix that is
used.  If the written representation of a number has no exactness
prefix, the constant is inexact if it contains a decimal point or an
exponent.  Otherwise, it is exact.

In systems with inexact numbers of varying precisions it can be useful
to specify the precision of a constant.  For this purpose,
implementations may accept numerical constants written with an exponent
marker that indicates the desired precision of the inexact
representation.  If so, the letter 's', 'f', 'd', or 'l', meaning SHORT,
SINGLE, DOUBLE, or LONG precision, respectively, can be used in place of
'e'.  The default precision has at least as much precision as DOUBLE,
but implementations may allow this default to be set by the user.


     3.14159265358979F0
            Round to single -- 3.141593
     0.6L0
            Extend to long -- .600000000000000


The numbers positive infinity, negative infinity, and NaN are written
'+inf.0', '-inf.0' and '+nan.0' respectively.  NaN may also be written
'-nan.0'.  The use of signs in the written representation does not
necessarily reflect the underlying sign of the NaN value, if any.
Implementations are not required to support these numbers, but if they
do, they must do so in general conformance with IEEE 754.  However,
implementations are not required to support signaling NaNs, nor to
provide a way to distinguish between different NaNs.

There are two notations provided for non-real complex numbers: the
"rectangular notation" A'+'B'i', where A is the real part and B is the
imaginary part; and the "polar notation" R'@'theta, where R is the
magnitude and theta is the phase (angle) in radians.  These are related
by the equation a+bi = r costheta + (r sintheta) i.  All of A, B, R, and
theta are real numbers.


File: r7rs.info,  Node: Numerical operations,  Next: Numerical input and output,  Prev: Syntax of numerical constants,  Up: Numbers

6.2.6 Numerical operations
--------------------------

The reader is referred to section *note Entry format:: for a summary of
the naming conventions used to specify restrictions on the types of
arguments to numerical routines.  The examples used in this section
assume that any numerical constant written using an exact notation is
indeed represented as an exact number.  Some examples also assume that
certain numerical constants written using an inexact notation can be
represented without loss of accuracy; the inexact constants were chosen
so that this is likely to be true in implementations that use IEEE
binary doubles to represent inexact numbers.

 -- procedure: number? obj
 -- procedure: complex? obj
 -- procedure: real? obj
 -- procedure: rational? obj
 -- procedure: integer? obj

     These numerical type predicates can be applied to any kind of
     argument, including non-numbers.  They return #t if the object is
     of the named type, and otherwise they return #f.  In general, if a
     type predicate is true of a number then all higher type predicates
     are also true of that number.  Consequently, if a type predicate is
     false of a number, then all lower type predicates are also false of
     that number.

     If Z is a complex number, then '(real? Z)' is true if and only if
     '(zero? (imag-part Z))' is true.  If X is an inexact real number,
     then '(integer? X)' is true if and only if '(= X (round X))'.

     The numbers '+inf.0', '-inf.0', and '+nan.0' are real but not
     rational.

     (complex? 3+4i)                        ==>  #t
     (complex? 3)                           ==>  #t
     (real? 3)                              ==>  #t
     (real? -2.5+0i)                        ==>  #t
     (real? -2.5+0.0i)                      ==>  #f
     (real? #e1e10)                         ==>  #t
     (real? +inf.0)                         ==>  #t
     (real? +nan.0)                         ==>  #t
     (rational? -inf.0)                     ==>  #f
     (rational? 3.5)                        ==>  #t
     (rational? 6/10)                       ==>  #t
     (rational? 6/3)                        ==>  #t
     (integer? 3+0i)                        ==>  #t
     (integer? 3.0)                         ==>  #t
     (integer? 8/4)                         ==>  #t


          _Note:_ The behavior of these type predicates on inexact
          numbers is unreliable, since any inaccuracy might affect the
          result.

          _Note:_ In many implementations the 'complex?' procedure will
          be the same as 'number?', but unusual implementations may
          represent some irrational numbers exactly or may extend the
          number system to support some kind of non-complex numbers.

 -- procedure: exact? Z
 -- procedure: inexact? Z

     These numerical predicates provide tests for the exactness of a
     quantity.  For any Scheme number, precisely one of these predicates
     is true.

     (exact? 3.0)                           ==>  #f
     (exact? #e3.0)                         ==>  #t
     (inexact? 3.)                          ==>  #t


 -- procedure: exact-integer? Z

     Returns #t if Z is both exact and an integer; otherwise returns #f.

     (exact-integer? 32)                    ==> #t
     (exact-integer? 32.0)                  ==> #f
     (exact-integer? 32/5)                  ==> #f


 -- inexact library procedure: finite? Z

     The 'finite?' procedure returns #t on all real numbers except
     '+inf.0', '-inf.0', and '+nan.0', and on complex numbers if their
     real and imaginary parts are both finite.  Otherwise it returns #f.

     (finite? 3)                            ==>  #t
     (finite? +inf.0)                       ==>  #f
     (finite? 3.0+inf.0i)                   ==>  #f


 -- inexact library procedure: infinite? Z

     The 'infinite?' procedure returns #t on the real numbers '+inf.0'
     and '-inf.0', and on complex numbers if their real or imaginary
     parts or both are infinite.  Otherwise it returns #f.

     (infinite? 3)                          ==>  #f
     (infinite? +inf.0)                     ==>  #t
     (infinite? +nan.0)                     ==>  #f
     (infinite? 3.0+inf.0i)                 ==>  #t


 -- inexact library procedure: nan? Z

     The 'nan?' procedure returns #t on '+nan.0', and on complex numbers
     if their real or imaginary parts or both are '+nan.0'.  Otherwise
     it returns #f.

     (nan? +nan.0)                          ==>  #t
     (nan? 32)                              ==>  #f
     (nan? +nan.0+5.0i)                     ==>  #t
     (nan? 1+2i)                            ==>  #f


 -- procedure: = z1 z2 z3 ...
 -- procedure: < x1 x2 x3 ...
 -- procedure: > x1 x2 x3 ...
 -- procedure: <= x1 x2 x3 ...
 -- procedure: >= x1 x2 x3 ...

     These procedures return #t if their arguments are (respectively):
     equal, monotonically increasing, monotonically decreasing,
     monotonically non-decreasing, or monotonically non-increasing, and
     #f otherwise.  If any of the arguments are '+nan.0', all the
     predicates return #f.  They do not distinguish between inexact zero
     and inexact negative zero.

     These predicates are required to be transitive.

          _Note:_ The implementation approach of converting all
          arguments to inexact numbers if any argument is inexact is not
          transitive.  For example, let 'big' be '(expt 2 1000)', and
          assume that 'big' is exact and that inexact numbers are
          represented by 64-bit IEEE binary floating point numbers.
          Then '(= (- big 1) (inexact big))' and '(= (inexact big) (+
          big 1))' would both be true with this approach, because of the
          limitations of IEEE representations of large integers, whereas
          '(= (- big 1) (+ big 1))' is false.  Converting inexact values
          to exact numbers that are the same (in the sense of '=') to
          them will avoid this problem, though special care must be
          taken with infinities.

          _Note:_ While it is not an error to compare inexact numbers
          using these predicates, the results are unreliable because a
          small inaccuracy can affect the result; this is especially
          true of '=' and 'zero?'.  When in doubt, consult a numerical
          analyst.

 -- procedure: zero? Z
 -- procedure: positive? X
 -- procedure: negative? X
 -- procedure: odd? N
 -- procedure: even? N

     These numerical predicates test a number for a particular property,
     returning #t or #f.  See note above.

 -- procedure: max x1 x2 ...
 -- procedure: min x1 x2 ...

     These procedures return the maximum or minimum of their arguments.

     (max 3 4)                              ==>  4    ; exact
     (max 3.9 4)                            ==>  4.0  ; inexact


          _Note:_ If any argument is inexact, then the result will also
          be inexact (unless the procedure can prove that the inaccuracy
          is not large enough to affect the result, which is possible
          only in unusual implementations).  If 'min' or 'max' is used
          to compare numbers of mixed exactness, and the numerical value
          of the result cannot be represented as an inexact number
          without loss of accuracy, then the procedure may report a
          violation of an implementation restriction.

 -- procedure: + z1 ...
 -- procedure: * z1 ...

     These procedures return the sum or product of their arguments.

     (+ 3 4)                                ==>  7
     (+ 3)                                  ==>  3
     (+)                                    ==>  0
     (* 4)                                  ==>  4
     (*)                                    ==>  1


 -- procedure: - Z
 -- procedure: - z1 z2 ...
 -- procedure: / Z
 -- procedure: / z1 z2 ...

     With two or more arguments, these procedures return the difference
     or quotient of their arguments, associating to the left.  With one
     argument, however, they return the additive or multiplicative
     inverse of their argument.

     It is an error if any argument of '/' other than the first is an
     exact zero.  If the first argument is an exact zero, an
     implementation may return an exact zero unless one of the other
     arguments is a NaN.

     (- 3 4)                                ==>  -1
     (- 3 4 5)                              ==>  -6
     (- 3)                                  ==>  -3
     (/ 3 4 5)                              ==>  3/20
     (/ 3)                                  ==>  1/3


 -- procedure: abs x

     The 'abs' procedure returns the absolute value of its argument.

     (abs -7)                               ==>  7


 -- procedure: floor/ n1 n2
 -- procedure: floor-quotient n1 n2
 -- procedure: floor-remainder n1 n2
 -- procedure: truncate/ n1 n2
 -- procedure: truncate-quotient n1 n2
 -- procedure: truncate-remainder n1 n2

     These procedures implement number-theoretic (integer) division.  It
     is an error if N2 is zero.  The procedures ending in '/' return two
     integers; the other procedures return an integer.  All the
     procedures compute a quotient N_Q and remainder N_R such that N1 =
     N2 N_Q + N_R.  For each of the division operators, there are three
     procedures defined as follows:

     (<operator>/ N1 N2)                    ==> N_Q N_R
     (<operator>-quotient N1 N2)            ==> N_Q
     (<operator>-remainder N1 N2)           ==> N_R


     The remainder N_R is determined by the choice of integer N_Q: N_R =
     N1 - N2 N_Q.  Each set of operators uses a different choice of N_Q:

          floor
               N_Q = lfloorN1 / N2rfloor
          truncate
               N_Q = texttruncate(N1 / N2)

     For any of the operators, and for integers N1 and N2 with N2 not
     equal to 0,

          (= N1 (+ (* N2 (<operator>-quotient N1 N2))
                (<operator>-remainder N1 N2)))
                                            ==>  #t


     provided all numbers involved in that computation are exact.

     Examples:

     (floor/ 5 2)                           ==> 2 1
     (floor/ -5 2)                          ==> -3 1
     (floor/ 5 -2)                          ==> -3 -1
     (floor/ -5 -2)                         ==> 2 -1
     (truncate/ 5 2)                        ==> 2 1
     (truncate/ -5 2)                       ==> -2 -1
     (truncate/ 5 -2)                       ==> -2 1
     (truncate/ -5 -2)                      ==> 2 -1
     (truncate/ -5.0 -2)                    ==> 2.0 -1.0


 -- procedure: quotient n1 n2
 -- procedure: remainder n1 n2
 -- procedure: modulo n1 n2

     The 'quotient' and 'remainder' procedures are equivalent to
     'truncate-quotient' and 'truncate-remainder', respectively, and
     'modulo' is equivalent to 'floor-remainder'.

          _Note:_ These procedures are provided for backward
          compatibility with earlier versions of this report.

 -- procedure: gcd n1 ...
 -- procedure: lcm n1 ...

     These procedures return the greatest common divisor or least common
     multiple of their arguments.  The result is always non-negative.

     (gcd 32 -36)                           ==>  4
     (gcd)                                  ==>  0
     (lcm 32 -36)                           ==>  288
     (lcm 32.0 -36)                         ==>  288.0  ; inexact
     (lcm)                                  ==>  1


 -- procedure: numerator Q
 -- procedure: denominator Q

     These procedures return the numerator or denominator of their
     argument; the result is computed as if the argument was represented
     as a fraction in lowest terms.  The denominator is always positive.
     The denominator of 0 is defined to be 1.

     (numerator (/ 6 4))                    ==>  3
     (denominator (/ 6 4))                  ==>  2
     (denominator
       (inexact (/ 6 4)))                   ==> 2.0


 -- procedure: floor x
 -- procedure: ceiling x
 -- procedure: truncate x
 -- procedure: round x

     These procedures return integers.  The 'floor' procedure returns
     the largest integer not larger than X.  The 'ceiling' procedure
     returns the smallest integer not smaller than X, 'truncate' returns
     the integer closest to X whose absolute value is not larger than
     the absolute value of X, and 'round' returns the closest integer to
     X, rounding to even when X is halfway between two integers.

          _Rationale:_ The 'round' procedure rounds to even for
          consistency with the default rounding mode specified by the
          IEEE 754 IEEE floating-point standard.

          _Note:_ If the argument to one of these procedures is inexact,
          then the result will also be inexact.  If an exact value is
          needed, the result can be passed to the 'exact' procedure.  If
          the argument is infinite or a NaN, then it is returned.

     (floor -4.3)                           ==>  -5.0
     (ceiling -4.3)                         ==>  -4.0
     (truncate -4.3)                        ==>  -4.0
     (round -4.3)                           ==>  -4.0

     (floor 3.5)                            ==>  3.0
     (ceiling 3.5)                          ==>  4.0
     (truncate 3.5)                         ==>  3.0
     (round 3.5)                            ==>  4.0  ; inexact

     (round 7/2)                            ==>  4    ; exact
     (round 7)                              ==>  7


 -- procedure: rationalize x y

     The 'rationalize' procedure returns the _simplest_ rational number
     differing from X by no more than Y.  A rational number r_1 is
     _simpler_ than another rational number r_2 if r_1 = p_1/q_1 and r_2
     = p_2/q_2 (in lowest terms) and |p_1|<= |p_2| and |q_1| <= |q_2|.
     Thus 3/5 is simpler than 4/7.  Although not all rationals are
     comparable in this ordering (consider 2/7 and 3/5), any interval
     contains a rational number that is simpler than every other
     rational number in that interval (the simpler 2/5 lies between 2/7
     and 3/5).  Note that 0 = 0/1 is the simplest rational of all.

     (rationalize
       (exact .3) 1/10)                     ==> 1/3    ; exact
     (rationalize .3 1/10)                  ==> #i1/3  ; inexact


 -- inexact library procedure: exp Z
 -- inexact library procedure: log Z
 -- inexact library procedure: log z1 z2
 -- inexact library procedure: sin Z
 -- inexact library procedure: cos Z
 -- inexact library procedure: tan Z
 -- inexact library procedure: asin Z
 -- inexact library procedure: acos Z
 -- inexact library procedure: atan Z
 -- inexact library procedure: atan Y X

     These procedures compute the usual transcendental functions.  The
     'log' procedure computes the natural logarithm of Z (not the base
     ten logarithm) if a single argument is given, or the base-Z2
     logarithm of Z1 if two arguments are given.  The 'asin', 'acos',
     and 'atan' procedures compute arcsine (sin^-1), arc-cosine
     (cos^-1), and arctangent (tan^-1), respectively.  The two-argument
     variant of 'atan' computes (angle (make-rectangular X Y)) (see
     below), even in implementations that don't support complex numbers.

     In general, the mathematical functions log, arcsine, arc-cosine,
     and arctangent are multiply defined.  The value of log z is defined
     to be the one whose imaginary part lies in the range from -pi
     (inclusive if '-0.0' is distinguished, exclusive otherwise) to pi
     (inclusive).  The value of log 0 is mathematically undefined.  With
     log defined this way, the values of sin^-1 z, cos^-1 z, and tan^-1
     z are according to the following formulae:

                 sin^-1 z = -i log (i z + sqrt1 - z^2)

                     cos^-1 z = pi / 2 - sin^-1 z

          tan^-1 z = (log (1 + i z) - log (1 - i z)) / (2 i)

     However, '(log 0.0)' returns '-inf.0' (and '(log -0.0)' returns
     '-inf.0+pii') if the implementation supports infinities (and
     '-0.0').

     The range of ('atan' Y X) is as in the following table.  The
     asterisk (*) indicates that the entry applies to implementations
     that distinguish minus zero.

               y condition x condition range of result r
          hline
               y = 0.0 x > 0.0 0.0
          ast
               y = +0.0 x > 0.0 +0.0
          ast
               y = -0.0 x > 0.0 -0.0
               y > 0.0 x > 0.0 0.0 < r < fracpi2
               y > 0.0 x = 0.0 fracpi2
               y > 0.0 x < 0.0 fracpi2 < r < pi
               y = 0.0 x < 0 pi
          ast
               y = +0.0 x < 0.0 pi
          ast
               y = -0.0 x < 0.0 -pi
               y < 0.0 x < 0.0 -pi< r< -fracpi2
               y < 0.0 x = 0.0 -fracpi2
               y < 0.0 x > 0.0 -fracpi2 < r< 0.0
               y = 0.0 x = 0.0 undefined
          ast
               y = +0.0 x = +0.0 +0.0
          ast
               y = -0.0 x = +0.0 -0.0
          ast
               y = +0.0 x = -0.0 pi
          ast
               y = -0.0 x = -0.0 -pi
          ast
               y = +0.0 x = 0 fracpi2
          ast
               y = -0.0 x = 0 -fracpi2

     The above specification follows [CLtL], which in turn cites
     [Penfield81]; refer to these sources for more detailed discussion
     of branch cuts, boundary conditions, and implementation of these
     functions.  When it is possible, these procedures produce a real
     result from a real argument.

 -- procedure: square Z

     Returns the square of Z.  This is equivalent to ('*' Z Z).

     (square 42)                            ==> 1764
     (square 2.0)                           ==> 4.0


 -- inexact library procedure: sqrt Z

     Returns the principal square root of Z.  The result will have
     either a positive real part, or a zero real part and a non-negative
     imaginary part.

     (sqrt 9)                               ==> 3
     (sqrt -1)                              ==> +i


 -- procedure: exact-integer-sqrt k

     Returns two non-negative exact integers s and r where K = s^2 + r
     and K < (s+1)^2.

     (exact-integer-sqrt 4)                 ==> 2 0
     (exact-integer-sqrt 5)                 ==> 2 1


 -- procedure: expt z1 z2

     Returns Z1 raised to the power Z2.  For nonzero Z1, this is

                        z_1^z_2 = e^z_2 log z_1

     The value of 0^z is 1 if '(zero? z)', 0 if '(real-part z)' is
     positive, and an error otherwise.  Similarly for 0.0^z, with
     inexact results.

 -- complex library procedure: make-rectangular x1 x2
 -- complex library procedure: make-polar x3 x4
 -- complex library procedure: real-part Z
 -- complex library procedure: imag-part Z
 -- complex library procedure: magnitude Z
 -- complex library procedure: angle Z

     Let X1, X2, X3, and X4 be real numbers and Z be a complex number
     such that

                      Z = X1 + X2i = X3 . e^i x_4

     Then all of

     (make-rectangular X1 X2)               ==> Z
     (make-polar X3 X4)                     ==> Z
     (real-part Z)                          ==> X1
     (imag-part Z)                          ==> X2
     (magnitude Z)                          ==> |X3|
     (angle Z)                              ==> x_angle


     are true, where -pi <= x_angle <= pi with x_angle = X4 + 2pi n for
     some integer n.

     The 'make-polar' procedure may return an inexact complex number
     even if its arguments are exact.  The 'real-part' and 'imag-part'
     procedures may return exact real numbers when applied to an inexact
     complex number if the corresponding argument passed to
     'make-rectangular' was exact.

          _Rationale:_ The 'magnitude' procedure is the same as 'abs'
          for a real argument, but 'abs' is in the base library, whereas
          'magnitude' is in the optional complex library.

 -- procedure: inexact Z
 -- procedure: exact Z

     The procedure 'inexact' returns an inexact representation of Z.
     The value returned is the inexact number that is numerically
     closest to the argument.  For inexact arguments, the result is the
     same as the argument.  For exact complex numbers, the result is a
     complex number whose real and imaginary parts are the result of
     applying 'inexact' to the real and imaginary parts of the argument,
     respectively.  If an exact argument has no reasonably close inexact
     equivalent (in the sense of '='), then a violation of an
     implementation restriction may be reported.

     The procedure 'exact' returns an exact representation of Z.  The
     value returned is the exact number that is numerically closest to
     the argument.  For exact arguments, the result is the same as the
     argument.  For inexact non-integral real arguments, the
     implementation may return a rational approximation, or may report
     an implementation violation.  For inexact complex arguments, the
     result is a complex number whose real and imaginary parts are the
     result of applying 'exact' to the real and imaginary parts of the
     argument, respectively.  If an inexact argument has no reasonably
     close exact equivalent, (in the sense of '='), then a violation of
     an implementation restriction may be reported.

     These procedures implement the natural one-to-one correspondence
     between exact and inexact integers throughout an
     implementation-dependent range.  See section *note Implementation
     restrictions::.

          _Note:_ These procedures were known in R^{5}RS as
          'exact->inexact' and 'inexact->exact', respectively, but they
          have always accepted arguments of any exactness.  The new
          names are clearer and shorter, as well as being compatible
          with R^{6}RS.





File: r7rs.info,  Node: Numerical input and output,  Prev: Numerical operations,  Up: Numbers

6.2.7 Numerical input and output
--------------------------------

 -- procedure: number->string z
 -- procedure: number->string z radix

     It is an error if RADIX is not one of 2, 8, 10, or 16.  The
     procedure 'number->string' takes a number and a radix and returns
     as a string an external representation of the given number in the
     given radix such that

     (let ((number NUMBER)
           (radix RADIX))
       (eqv? number
             (string->number (number->string number
                                             radix)
                             radix)))


     is true.  It is an error if no possible result makes this
     expression true.  If omitted, RADIX defaults to 10.

     If Z is inexact, the radix is 10, and the above expression can be
     satisfied by a result that contains a decimal point, then the
     result contains a decimal point and is expressed using the minimum
     number of digits (exclusive of exponent and trailing zeroes) needed
     to make the above expression true [howtoprint], [howtoread];
     otherwise the format of the result is unspecified.

     The result returned by 'number->string' never contains an explicit
     radix prefix.

          _Note:_ The error case can occur only when Z is not a complex
          number or is a complex number with a non-rational real or
          imaginary part.

          _Rationale:_ If Z is an inexact number and the radix is 10,
          then the above expression is normally satisfied by a result
          containing a decimal point.  The unspecified case allows for
          infinities, NaNs, and unusual representations.

 -- procedure: string->number string
 -- procedure: string->number string radix

     Returns a number of the maximally precise representation expressed
     by the given STRING.  It is an error if RADIX is not 2, 8, 10, or
     16.  If supplied, RADIX is a default radix that will be overridden
     if an explicit radix prefix is present in STRING (e.g.  "#o177").
     If RADIX is not supplied, then the default radix is 10.  If STRING
     is not a syntactically valid notation for a number, or would result
     in a number that the implementation cannot represent, then
     'string->number' returns #f.  An error is never signaled due to the
     content of STRING.

     (string->number "100")                 ==>  100
     (string->number "100" 16)              ==>  256
     (string->number "1e2")                 ==>  100.0


          _Note:_ The domain of 'string->number' may be restricted by
          implementations in the following ways.  If all numbers
          supported by an implementation are real, then 'string->number'
          is permitted to return #f whenever STRING uses the polar or
          rectangular notations for complex numbers.  If all numbers are
          integers, then 'string->number' may return #f whenever the
          fractional notation is used.  If all numbers are exact, then
          'string->number' may return #f whenever an exponent marker or
          explicit exactness prefix is used.  If all inexact numbers are
          integers, then 'string->number' may return #f whenever a
          decimal point is used.

          The rules used by a particular implementation for
          'string->number' must also be applied to 'read' and to the
          routine that reads programs, in order to maintain consistency
          between internal numeric processing, I/O, and the processing
          of programs.  As a consequence, the R^{5}RS permission to
          return #f when STRING has an explicit radix prefix has been
          withdrawn.


File: r7rs.info,  Node: Booleans,  Next: Pairs and lists,  Prev: Numbers,  Up: Standard procedures

6.3 Booleans
============

The standard boolean objects for true and false are written as #t and
#f.  Alternatively, they can be written #true and #false, respectively.
What really matters, though, are the objects that the Scheme conditional
expressions ('if', 'cond', 'and', 'or', 'when', 'unless', 'do') treat as
true or false.  The phrase "a true value" (or sometimes just "true")
means any object treated as true by the conditional expressions, and the
phrase "a false value" (or "false") means any object treated as false by
the conditional expressions.

Of all the Scheme values, only #f counts as false in conditional
expressions.  All other Scheme values, including #t, count as true.

     _Note:_ Unlike some other dialects of Lisp, Scheme distinguishes #f
     and the empty list from each other and from the symbol 'nil'.

Boolean constants evaluate to themselves, so they do not need to be
quoted in programs.


     #t                                     ==>  #t
     #f                                     ==>  #f
     '#f                                    ==>  #f


 -- procedure: not obj

     The 'not' procedure returns #t if OBJ is false, and returns #f
     otherwise.

     (not #t)                               ==>  #f
     (not 3)                                ==>  #f
     (not (list 3))                         ==>  #f
     (not #f)                               ==>  #t
     (not '())                              ==>  #f
     (not (list))                           ==>  #f
     (not 'nil)                             ==>  #f


 -- procedure: boolean? obj

     The 'boolean?' predicate returns #t if OBJ is either #t or #f and
     returns #f otherwise.

     (boolean? #f)                          ==>  #t
     (boolean? 0)                           ==>  #f
     (boolean? '())                         ==>  #f


 -- procedure: boolean=? boolean1 boolean2 boolean3 ...

     Returns #t if all the arguments are #t or all are #f.


File: r7rs.info,  Node: Pairs and lists,  Next: Symbols,  Prev: Booleans,  Up: Standard procedures

6.4 Pairs and lists
===================

A "pair" (sometimes called a "dotted pair") is a record structure with
two fields called the car and cdr fields (for historical reasons).
Pairs are created by the procedure 'cons'.  The car and cdr fields are
accessed by the procedures 'car' and 'cdr'.  The car and cdr fields are
assigned by the procedures 'set-car!' and 'set-cdr!'.

Pairs are used primarily to represent lists.  A "list" can be defined
recursively as either the empty list or a pair whose cdr is a list.
More precisely, the set of lists is defined as the smallest set X such
that

   * The empty list is in X.
   * If LIST is in X, then any pair whose cdr field contains LIST is
     also in X.

The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose
car is the first element and whose cdr is a pair whose car is the second
element and whose cdr is the empty list.  The length of a list is the
number of elements, which is the same as the number of pairs.

The empty list is a special object of its own type.  It is not a pair,
it has no elements, and its length is zero.

     _Note:_ The above definitions imply that all lists have finite
     length and are terminated by the empty list.

The most general notation (external representation) for Scheme pairs is
the "dotted" notation '(C1 . C2)' where C1 is the value of the car field
and C2 is the value of the cdr field.  For example '(4 . 5)' is a pair
whose car is 4 and whose cdr is 5.  Note that '(4 . 5)' is the external
representation of a pair, not an expression that evaluates to a pair.

A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list is written ().  For example,


     (a b c d e)


and


     (a . (b . (c . (d . (e . ())))))


are equivalent notations for a list of symbols.

A chain of pairs not ending in the empty list is called an "improper
list".  Note that an improper list is not a list.  The list and dotted
notations can be combined to represent improper lists:


     (a b c . d)


is equivalent to


     (a . (b . (c . d)))


Whether a given pair is a list depends upon what is stored in the cdr
field.  When the 'set-cdr!' procedure is used, an object can be a list
one moment and not the next:


     (define x (list 'a 'b 'c))
     (define y x)
     y                                      ==>  (a b c)
     (list? y)                              ==>  #t
     (set-cdr! x 4)                         ==>  _unspecified_
     x                                      ==>  (a . 4)
     (eqv? x y)                             ==>  #t
     y                                      ==>  (a . 4)
     (list? y)                              ==>  #f
     (set-cdr! x x)                         ==>  _unspecified_
     (list? x)                              ==>  #f


Within literal expressions and representations of objects read by the
'read' procedure, the forms '<datum>, `<datum>, ,<datum>, and ,@<datum>
denote two-element lists whose first elements are the symbols 'quote',
'quasiquote', 'unquote', and 'unquote-splicing', respectively.  The
second element in each case is <datum>.  This convention is supported so
that arbitrary Scheme programs can be represented as lists.  That is,
according to Scheme's grammar, every <expression> is also a <datum> (see
section *note External representation::).  Among other things, this
permits the use of the 'read' procedure to parse Scheme programs.  See
section *note External representations::.

 -- procedure: pair? obj

     The 'pair?' predicate returns #t if OBJ is a pair, and otherwise
     returns #f.

     (pair? '(a . b))                       ==>  #t
     (pair? '(a b c))                       ==>  #t
     (pair? '())                            ==>  #f
     (pair? '#(a b))                        ==>  #f


 -- procedure: cons obj1 obj2

     Returns a newly allocated pair whose car is OBJ1 and whose cdr is
     OBJ2.  The pair is guaranteed to be different (in the sense of
     'eqv?') from every existing object.

     (cons 'a '())                          ==>  (a)
     (cons '(a) '(b c d))                   ==>  ((a) b c d)
     (cons "a" '(b c))                      ==>  ("a" b c)
     (cons 'a 3)                            ==>  (a . 3)
     (cons '(a b) 'c)                       ==>  ((a b) . c)


 -- procedure: car pair

     Returns the contents of the car field of PAIR.  Note that it is an
     error to take the car of the empty list.

     (car '(a b c))                         ==>  a
     (car '((a) b c d))                     ==>  (a)
     (car '(1 . 2))                         ==>  1
     (car '())                              ==>  _error_


 -- procedure: cdr pair

     Returns the contents of the cdr field of PAIR.  Note that it is an
     error to take the cdr of the empty list.

     (cdr '((a) b c d))                     ==>  (b c d)
     (cdr '(1 . 2))                         ==>  2
     (cdr '())                              ==>  _error_


 -- procedure: set-car! pair obj

     Stores OBJ in the car field of PAIR.

     (define (f) (list 'not-a-constant-list))
     (define (g) '(constant-list))
     (set-car! (f) 3)                       ==>  _unspecified_
     (set-car! (g) 3)                       ==>  _error_


 -- procedure: set-cdr! pair obj

     Stores OBJ in the cdr field of PAIR.

 -- procedure: caar pair
 -- procedure: cadr pair
 -- procedure: cdar pair
 -- procedure: cddr pair

     These procedures are compositions of 'car' and 'cdr' as follows:

     (define (caar x) (car (car x)))
     (define (cadr x) (car (cdr x)))
     (define (cdar x) (cdr (car x)))
     (define (cddr x) (cdr (cdr x)))


 -- cxr library procedure: caaar pair
 -- cxr library procedure: caadr pair

 --          ...:          ...

 -- cxr library procedure: cdddar pair
 -- cxr library procedure: cddddr pair

     These twenty-four procedures are further compositions of 'car' and
     'cdr' on the same principles.  For example, 'caddr' could be
     defined by

     (define caddr (lambda (x) (car (cdr (cdr x))))).


     Arbitrary compositions up to four deep are provided.

 -- procedure: null? obj

     Returns #t if OBJ is the empty list, otherwise returns #f.

 -- procedure: list? obj

     Returns #t if OBJ is a list.  Otherwise, it returns #f.  By
     definition, all lists have finite length and are terminated by the
     empty list.

             (list? '(a b c))               ==>  #t
             (list? '())                    ==>  #t
             (list? '(a . b))               ==>  #f
             (let ((x (list 'a)))
               (set-cdr! x x)
               (list? x))                   ==>  #f


 -- procedure: make-list k
 -- procedure: make-list k fill

     Returns a newly allocated list of K elements.  If a second argument
     is given, then each element is initialized to FILL.  Otherwise the
     initial contents of each element is unspecified.

     (make-list 2 3)                        ==>   (3 3)


 -- procedure: list OBJ ...

     Returns a newly allocated list of its arguments.

     (list 'a (+ 3 4) 'c)                   ==>  (a 7 c)
     (list)                                 ==>  ()


 -- procedure: length list

     Returns the length of LIST.

     (length '(a b c))                      ==>  3
     (length '(a (b) (c d e)))              ==>  3
     (length '())                           ==>  0


 -- procedure: append list ...

     The last argument, if there is one, can be of any type.  Returns a
     list consisting of the elements of the first LIST followed by the
     elements of the other LISTs.  If there are no arguments, the empty
     list is returned.  If there is exactly one argument, it is
     returned.  Otherwise the resulting list is always newly allocated,
     except that it shares structure with the last argument.  An
     improper list results if the last argument is not a proper list.

     (append '(x) '(y))                     ==>  (x y)
     (append '(a) '(b c d))                 ==>  (a b c d)
     (append '(a (b)) '((c)))               ==>  (a (b) (c))


     (append '(a b) '(c . d))               ==>  (a b c . d)
     (append '() 'a)                        ==>  a


 -- procedure: reverse list

     Returns a newly allocated list consisting of the elements of LIST
     in reverse order.

     (reverse '(a b c))                     ==>  (c b a)
     (reverse '(a (b c) d (e (f))))
               ==>  ((e (f)) d (b c) a)


 -- procedure: list-tail list K

     It is an error if LIST has fewer than K elements.  Returns the
     sublist of LIST obtained by omitting the first K elements.  The
     'list-tail' procedure could be defined by

     (define list-tail
       (lambda (x k)
         (if (zero? k)
             x
             (list-tail (cdr x) (- k 1)))))


 -- procedure: list-ref list K

     The LIST argument can be circular, but it is an error if LIST has K
     or fewer elements.  Returns the Kth element of LIST.  (This is the
     same as the car of (list-tail LIST K).)

     (list-ref '(a b c d) 2)                 ==>  c
     (list-ref '(a b c d)
               (exact (round 1.8)))
               ==>  c


 -- procedure: list-set! list k obj

     It is an error if K is not a valid index of LIST.  The 'list-set!'
     procedure stores OBJ in element K of LIST.

     (let ((ls (list 'one 'two 'five!)))
       (list-set! ls 2 'three)
       ls)
               ==>  (one two three)

     (list-set! '(0 1 2) 1 "oops")
               ==>  _error_  ; constant list


 -- procedure: memq obj list
 -- procedure: memv obj list
 -- procedure: member obj list
 -- procedure: member obj list compare

     These procedures return the first sublist of LIST whose car is OBJ,
     where the sublists of LIST are the non-empty lists returned by
     (list-tail LIST K) for K less than the length of LIST.  If OBJ does
     not occur in LIST, then #f (not the empty list) is returned.  The
     'memq' procedure uses 'eq?' to compare OBJ with the elements of
     LIST, while 'memv' uses 'eqv?' and 'member' uses COMPARE, if given,
     and 'equal?' otherwise.

     (memq 'a '(a b c))                     ==>  (a b c)
     (memq 'b '(a b c))                     ==>  (b c)
     (memq 'a '(b c d))                     ==>  #f
     (memq (list 'a) '(b (a) c))            ==>  #f
     (member (list 'a)
             '(b (a) c))                    ==>  ((a) c)
     (member "B"
             '("a" "b" "c")
             string-ci=?)                   ==>  ("b" "c")
     (memq 101 '(100 101 102))              ==>  _unspecified_
     (memv 101 '(100 101 102))              ==>  (101 102)


 -- procedure: assq obj alist
 -- procedure: assv obj alist
 -- procedure: assoc obj alist
 -- procedure: assoc obj alist compare

     It is an error if ALIST (for "association list") is not a list of
     pairs.  These procedures find the first pair in ALIST whose car
     field is OBJ, and returns that pair.  If no pair in ALIST has OBJ
     as its car, then #f (not the empty list) is returned.  The 'assq'
     procedure uses 'eq?' to compare OBJ with the car fields of the
     pairs in ALIST, while 'assv' uses 'eqv?' and 'assoc' uses COMPARE
     if given and 'equal?' otherwise.

     (define e '((a 1) (b 2) (c 3)))
     (assq 'a e)                            ==>  (a 1)
     (assq 'b e)                            ==>  (b 2)
     (assq 'd e)                            ==>  #f
     (assq (list 'a) '(((a)) ((b)) ((c))))
                                            ==>  #f
     (assoc (list 'a) '(((a)) ((b)) ((c))))
                                            ==>  ((a))
     (assoc 2.0 '((1 1) (2 4) (3 9)) =)
                                            ==> (2 4)
     (assq 5 '((2 3) (5 7) (11 13)))
                                            ==>  _unspecified_
     (assv 5 '((2 3) (5 7) (11 13)))
                                            ==>  (5 7)


          _Rationale:_ Although they are often used as predicates,
          'memq', 'memv', 'member', 'assq', 'assv', and 'assoc' do not
          have question marks in their names because they return
          potentially useful values rather than just #t or #f.

 -- procedure: list-copy obj

     Returns a newly allocated copy of the given OBJ if it is a list.
     Only the pairs themselves are copied; the cars of the result are
     the same (in the sense of 'eqv?') as the cars of LIST.  If OBJ is
     an improper list, so is the result, and the final cdrs are the same
     in the sense of 'eqv?'.  An OBJ which is not a list is returned
     unchanged.  It is an error if OBJ is a circular list.

     (define a '(1 8 2 8)) ; a may be immutable
     (define b (list-copy a))
     (set-car! b 3)        ; b is mutable
     b                                      ==> (3 8 2 8)
     a                                      ==> (1 8 2 8)



File: r7rs.info,  Node: Symbols,  Next: Characters,  Prev: Pairs and lists,  Up: Standard procedures

6.5 Symbols
===========

Symbols are objects whose usefulness rests on the fact that two symbols
are identical (in the sense of 'eqv?') if and only if their names are
spelled the same way.  For instance, they can be used the way enumerated
values are used in other languages.

The rules for writing a symbol are exactly the same as the rules for
writing an identifier; see sections *note Identifiers:: and *note
Lexical structure::.

It is guaranteed that any symbol that has been returned as part of a
literal expression, or read using the 'read' procedure, and subsequently
written out using the 'write' procedure, will read back in as the
identical symbol (in the sense of 'eqv?').

     _Note:_ Some implementations have values known as "uninterned
     symbols," which defeat write/read invariance, and also violate the
     rule that two symbols are the same if and only if their names are
     spelled the same.  This report does not specify the behavior of
     implementation-dependent extensions.

 -- procedure: symbol? obj

     Returns #t if OBJ is a symbol, otherwise returns #f.

     (symbol? 'foo)                         ==>  #t
     (symbol? (car '(a b)))                 ==>  #t
     (symbol? "bar")                        ==>  #f
     (symbol? 'nil)                         ==>  #t
     (symbol? '())                          ==>  #f
     (symbol? #f)                           ==>  #f


 -- procedure: symbol=? symbol1 symbol2 symbol3 ...

     Returns #t if all the arguments all have the same names in the
     sense of 'string=?'.

          _Note:_ The definition above assumes that none of the
          arguments are uninterned symbols.

 -- procedure: symbol->string symbol

     Returns the name of SYMBOL as a string, but without adding escapes.
     It is an error to apply mutation procedures like 'string-set!' to
     strings returned by this procedure.

     (symbol->string 'flying-fish)
                                            ==>  "flying-fish"
     (symbol->string 'Martin)               ==>  "Martin"
     (symbol->string
        (string->symbol "Malvina"))
                                            ==>  "Malvina"


 -- procedure: string->symbol string

     Returns the symbol whose name is STRING.  This procedure can create
     symbols with names containing special characters that would require
     escaping when written, but does not interpret escapes in its input.

     (string->symbol "mISSISSIppi")
               ==>
       mISSISSIppi
     (eqv? 'bitBlt (string->symbol "bitBlt"))
               ==>  #t
     (eqv? 'LollyPop
          (string->symbol
            (symbol->string 'LollyPop)))
               ==>  #t
     (string=? "K. Harper, M.D."
               (symbol->string
                 (string->symbol "K. Harper, M.D.")))
               ==>  #t



File: r7rs.info,  Node: Characters,  Next: Strings,  Prev: Symbols,  Up: Standard procedures

6.6 Characters
==============

Characters are objects that represent printed characters such as letters
and digits.  All Scheme implementations must support at least the ASCII
character repertoire: that is, Unicode characters U+0000 through U+007F.
Implementations may support any other Unicode characters they see fit,
and may also support non-Unicode characters as well.  Except as
otherwise specified, the result of applying any of the following
procedures to a non-Unicode character is implementation-dependent.

Characters are written using the notation #\<character> or #\<character
name> or #\x<hex scalar value>.

The following character names must be supported by all implementations
with the given values.  Implementations may add other names provided
they cannot be interpreted as hex scalar values preceded by 'x'.

     #\alarm
          ; U+0007
     #\backspace
          ; U+0008
     #\delete
          ; U+007F
     #\escape
          ; U+001B
     #\newline
          ; the linefeed character, U+000A
     #\null
          ; the null character, U+0000
     #\return
          ; the return character, U+000D
     #\space
          ; the preferred way to write a space
     #\tab
          ; the tab character, U+0009

Here are some additional examples:

     #\a
          ; lower case letter
     #\A
          ; upper case letter
     #\(
          ; left parenthesis
     #\ 
          ; the space character
     #\x03BB
          ; lambda (if character is supported)
     #\iota
          ; iota (if character and name are supported)

Case is significant in #\<character>, and in #\<character name>, but not
in '#\x'<hex scalar value>.  If <character> in #\<character> is
alphabetic, then any character immediately following <character> cannot
be one that can appear in an identifier.  This rule resolves the
ambiguous case where, for example, the sequence of characters "#\ space"
could be taken to be either a representation of the space character or a
representation of the character "#\ s" followed by a representation of
the symbol "pace."

Characters written in the #\ notation are self-evaluating.  That is,
they do not have to be quoted in programs.

Some of the procedures that operate on characters ignore the difference
between upper case and lower case.  The procedures that ignore case have
"-ci" (for "case insensitive") embedded in their names.

 -- procedure: char? obj

     Returns #t if OBJ is a character, otherwise returns #f.

 -- procedure: char=? char1 char2 char3 ...
 -- procedure: char<? char1 char2 char3 ...
 -- procedure: char>? char1 char2 char3 ...
 -- procedure: char<=? char1 char2 char3 ...
 -- procedure: char>=? char1 char2 char3 ...

     These procedures return #t if the results of passing their
     arguments to 'char->integer' are respectively equal, monotonically
     increasing, monotonically decreasing, monotonically non-decreasing,
     or monotonically non-increasing.

     These predicates are required to be transitive.

 -- char library procedure: char-ci=? char1 char2 char3 ...
 -- char library procedure: char-ci<? char1 char2 char3 ...
 -- char library procedure: char-ci>? char1 char2 char3 ...
 -- char library procedure: char-ci<=? char1 char2 char3 ...
 -- char library procedure: char-ci>=? char1 char2 char3 ...

     These procedures are similar to 'char=?' et cetera, but they treat
     upper case and lower case letters as the same.  For example,
     '(char-ci=? #\A #\a)' returns #t.

     Specifically, these procedures behave as if 'char-foldcase' were
     applied to their arguments before they were compared.

 -- char library procedure: char-alphabetic? char
 -- char library procedure: char-numeric? char
 -- char library procedure: char-whitespace? char
 -- char library procedure: char-upper-case? letter
 -- char library procedure: char-lower-case? letter

     These procedures return #t if their arguments are alphabetic,
     numeric, whitespace, upper case, or lower case characters,
     respectively, otherwise they return #f.

     Specifically, they must return #t when applied to characters with
     the Unicode properties Alphabetic, Numeric Type=Decimal, White
     Space, Uppercase, and Lowercase respectively, and #f when applied
     to any other Unicode characters.  Note that many Unicode characters
     are alphabetic but neither upper nor lower case.

 -- char library procedure: digit-value char

     This procedure returns the numeric value (0 to 9) of its argument
     if it is a numeric digit (that is, if 'char-numeric?' returns #t),
     or #f on any other character.

     (digit-value #\3)                      ==> 3
     (digit-value #\x0664)                  ==> 4
     (digit-value #\x0AE6)                  ==> 0
     (digit-value #\x0EA6)                  ==> #f


 -- procedure: char->integer char
 -- procedure: integer->char N

     Given a Unicode character, 'char->integer' returns an exact integer
     between 0 and #xD7FF or between #xE000 and #x10FFFF which is equal
     to the Unicode scalar value of that character.  Given a non-Unicode
     character, it returns an exact integer greater than #x10FFFF.  This
     is true independent of whether the implementation uses the Unicode
     representation internally.

     Given an exact integer that is the value returned by a character
     when 'char->integer' is applied to it, 'integer->char' returns that
     character.

 -- char library procedure: char-upcase char
 -- char library procedure: char-downcase char
 -- char library procedure: char-foldcase char

     The 'char-upcase' procedure, given an argument that is the
     lowercase part of a Unicode casing pair, returns the uppercase
     member of the pair, provided that both characters are supported by
     the Scheme implementation.  Note that language-sensitive casing
     pairs are not used.  If the argument is not the lowercase member of
     such a pair, it is returned.

     The 'char-downcase' procedure, given an argument that is the
     uppercase part of a Unicode casing pair, returns the lowercase
     member of the pair, provided that both characters are supported by
     the Scheme implementation.  Note that language-sensitive casing
     pairs are not used.  If the argument is not the uppercase member of
     such a pair, it is returned.

     The 'char-foldcase' procedure applies the Unicode simple
     case-folding algorithm to its argument and returns the result.
     Note that language-sensitive folding is not used.  If the character
     that results from folding is not supported by the implementation,
     the argument is returned.  See UAX #44 [uax44] (part of the Unicode
     Standard) for details.

     Note that many Unicode lowercase characters do not have uppercase
     equivalents.


File: r7rs.info,  Node: Strings,  Next: Vectors,  Prev: Characters,  Up: Standard procedures

6.7 Strings
===========

Strings are sequences of characters.  Strings are written as sequences
of characters enclosed within quotation marks ('"').  Within a string
literal, various escape sequences represent characters other than
themselves.  Escape sequences always start with a backslash (\):

   * '\a' : alarm, U+0007
   * '\b' : backspace, U+0008
   * '\t' : character tabulation, U+0009
   * '\n' : linefeed, U+000A
   * '\r' : return, U+000D
   * '\'" : double quote, U+0022
   * '\\' : backslash, U+005C
   * '\|' : vertical line, U+007C
   * '\<intraline whitespace>*<line ending> <intraline whitespace>*' :
     nothing
   * '\x<hex scalar value>;' : specified character (note the terminating
     semi-colon).

The result is unspecified if any other character in a string occurs
after a backslash.

Except for a line ending, any character outside of an escape sequence
stands for itself in the string literal.  A line ending which is
preceded by '\<intraline whitespace>' expands to nothing (along with any
trailing intraline whitespace), and can be used to indent strings for
improved legibility.  Any other line ending has the same effect as
inserting a '\n' character into the string.

Examples:


     "The word \"recursion\" has many meanings."
     "Another example:\ntwo lines of text"
     "Here's text \
        containing just one line"
     "\x03B1; is named GREEK SMALL LETTER ALPHA."


The _length_ of a string is the number of characters that it contains.
This number is an exact, non-negative integer that is fixed when the
string is created.  The "valid indexes" of a string are the exact
non-negative integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.

Some of the procedures that operate on strings ignore the difference
between upper and lower case.  The names of the versions that ignore
case end with "'-ci'" (for "case insensitive").

Implementations may forbid certain characters from appearing in strings.
However, with the exception of #\null, ASCII characters must not be
forbidden.  For example, an implementation might support the entire
Unicode repertoire, but only allow characters U+0001 to U+00FF (the
Latin-1 repertoire without #\null) in strings.

It is an error to pass such a forbidden character to 'make-string',
'string', 'string-set!', or 'string-fill!', as part of the list passed
to 'list->string', or as part of the vector passed to 'vector->string'
(see section *note Vectors::), or in UTF-8 encoded form within a
bytevector passed to 'utf8->string' (see section *note Bytevectors::).
It is also an error for a procedure passed to 'string-map' (see section
*note Control features::) to return a forbidden character, or for
'read-string' (see section *note Input::) to attempt to read one.

 -- procedure: string? obj

     Returns #t if OBJ is a string, otherwise returns #f.

 -- procedure: make-string K
 -- procedure: make-string K char

     The 'make-string' procedure returns a newly allocated string of
     length K.  If CHAR is given, then all the characters of the string
     are initialized to CHAR, otherwise the contents of the string are
     unspecified.

 -- procedure: string char ...

     Returns a newly allocated string composed of the arguments.  It is
     analogous to 'list'.

 -- procedure: string-length string

     Returns the number of characters in the given STRING.

 -- procedure: string-ref string K

     It is an error if K is not a valid index of STRING.  The
     'string-ref' procedure returns character K of STRING using
     zero-origin indexing.
There is no requirement for this procedure to execute in constant time.

 -- procedure: string-set! string k char

     It is an error if K is not a valid index of STRING.  The
     'string-set!' procedure stores CHAR in element K of STRING.  There
     is no requirement for this procedure to execute in constant time.

     (define (f) (make-string 3 #\*))
     (define (g) "***")
     (string-set! (f) 0 #\?)                ==>  _unspecified_
     (string-set! (g) 0 #\?)                ==>  _error_
     (string-set! (symbol->string 'immutable)
                  0
                  #\?)                      ==>  _error_


 -- procedure: string=? string1 string2 string3 ...

     Returns #t if all the strings are the same length and contain
     exactly the same characters in the same positions, otherwise
     returns #f.

 -- char library procedure: string-ci=? string1 string2 string3 ...

     Returns #t if, after case-folding, all the strings are the same
     length and contain the same characters in the same positions,
     otherwise returns #f.  Specifically, these procedures behave as if
     'string-foldcase' were applied to their arguments before comparing
     them.

 -- procedure: string<? string1 string2 string3 ...
 -- char library procedure: string-ci<? string1 string2 string3 ...
 -- procedure: string>? string1 string2 string3 ...
 -- char library procedure: string-ci>? string1 string2 string3 ...
 -- procedure: string<=? string1 string2 string3 ...
 -- char library procedure: string-ci<=? string1 string2 string3 ...
 -- procedure: string>=? string1 string2 string3 ...
 -- char library procedure: string-ci>=? string1 string2 string3 ...

     These procedures return #t if their arguments are (respectively):
     monotonically increasing, monotonically decreasing, monotonically
     non-decreasing, or monotonically non-increasing.

     These predicates are required to be transitive.

     These procedures compare strings in an implementation-defined way.
     One approach is to make them the lexicographic extensions to
     strings of the corresponding orderings on characters.  In that
     case, 'string<?' would be the lexicographic ordering on strings
     induced by the ordering 'char<?' on characters, and if the two
     strings differ in length but are the same up to the length of the
     shorter string, the shorter string would be considered to be
     lexicographically less than the longer string.  However, it is also
     permitted to use the natural ordering imposed by the
     implementation's internal representation of strings, or a more
     complex locale-specific ordering.

     In all cases, a pair of strings must satisfy exactly one of
     'string<?', 'string=?', and 'string>?', and must satisfy
     'string<=?' if and only if they do not satisfy 'string>?' and
     'string>=?' if and only if they do not satisfy 'string<?'.

     The "-ci" procedures behave as if they applied 'string-foldcase' to
     their arguments before invoking the corresponding procedures
     without "-ci".

 -- char library procedure: string-upcase string
 -- char library procedure: string-downcase string
 -- char library procedure: string-foldcase string

     These procedures apply the Unicode full string uppercasing,
     lowercasing, and case-folding algorithms to their arguments and
     return the result.  In certain cases, the result differs in length
     from the argument.  If the result is equal to the argument in the
     sense of 'string=?', the argument may be returned.  Note that
     language-sensitive mappings and foldings are not used.

     The Unicode Standard prescribes special treatment of the Greek
     letter Sigma, whose normal lower-case form is sigma but which
     becomes varsigma at the end of a word.  See UAX #44 [uax44] (part
     of the Unicode Standard) for details.  However, implementations of
     'string-downcase' are not required to provide this behavior, and
     may choose to change Sigma to sigma in all cases.

 -- procedure: substring string start end

     The 'substring' procedure returns a newly allocated string formed
     from the characters of STRING beginning with index START and ending
     with index END.  This is equivalent to calling 'string-copy' with
     the same arguments, but is provided for backward compatibility and
     stylistic flexibility.

 -- procedure: string-append STRING ...

     Returns a newly allocated string whose characters are the
     concatenation of the characters in the given strings.

 -- procedure: string->list string
 -- procedure: string->list string start
 -- procedure: string->list string start end
 -- procedure: list->string list

     It is an error if any element of LIST is not a character.  The
     'string->list' procedure returns a newly allocated list of the
     characters of STRING between START and END.  'list->string' returns
     a newly allocated string formed from the elements in the list LIST.
     In both procedures, order is preserved.  'string->list' and
     'list->string' are inverses so far as 'equal?' is concerned.

 -- procedure: string-copy string
 -- procedure: string-copy string start
 -- procedure: string-copy string start end

     Returns a newly allocated copy of the part of the given STRING
     between START and END.

 -- procedure: string-copy! to at from
 -- procedure: string-copy! to at from start
 -- procedure: string-copy! to at from start end

     It is an error if AT is less than zero or greater than the length
     of TO.  It is also an error if '(- (string-length TO) AT)' is less
     than '(- END START)'.  Copies the characters of string FROM between
     START and END to string TO, starting at AT.  The order in which
     characters are copied is unspecified, except that if the source and
     destination overlap, copying takes place as if the source is first
     copied into a temporary string and then into the destination.  This
     can be achieved without allocating storage by making sure to copy
     in the correct direction in such circumstances.

     (define a "12345")
     (define b (string-copy "abcde"))
     (string-copy! b 1 a 0 2)
     b                                      ==> "a12de"


 -- procedure: string-fill! string fill
 -- procedure: string-fill! string fill start
 -- procedure: string-fill! string fill start end

     It is an error if FILL is not a character.

     The 'string-fill!' procedure stores FILL in the elements of STRING
     between START and END.


File: r7rs.info,  Node: Vectors,  Next: Bytevectors,  Prev: Strings,  Up: Standard procedures

6.8 Vectors
===========

Vectors are heterogeneous structures whose elements are indexed by
integers.  A vector typically occupies less space than a list of the
same length, and the average time needed to access a randomly chosen
element is typically less for the vector than for the list.

The _length_ of a vector is the number of elements that it contains.
This number is a non-negative integer that is fixed when the vector is
created.  The _valid indexes_ of a vector are the exact non-negative
integers less than the length of the vector.  The first element in a
vector is indexed by zero, and the last element is indexed by one less
than the length of the vector.

Vectors are written using the notation #(OBJ ...).  For example, a
vector of length 3 containing the number zero in element 0, the list '(2
2 2 2)' in element 1, and the string '"Anna"' in element 2 can be
written as follows:


     #(0 (2 2 2 2) "Anna")


Vector constants are self-evaluating, so they do not need to be quoted
in programs.

 -- procedure: vector? obj

     Returns #t if OBJ is a vector; otherwise returns #f.

 -- procedure: make-vector k
 -- procedure: make-vector k fill

     Returns a newly allocated vector of K elements.  If a second
     argument is given, then each element is initialized to FILL.
     Otherwise the initial contents of each element is unspecified.

 -- procedure: vector obj ...

     Returns a newly allocated vector whose elements contain the given
     arguments.  It is analogous to 'list'.

     (vector 'a 'b 'c)                      ==>  #(a b c)


 -- procedure: vector-length vector

     Returns the number of elements in VECTOR as an exact integer.

 -- procedure: vector-ref vector k

     It is an error if K is not a valid index of VECTOR.  The
     'vector-ref' procedure returns the contents of element K of VECTOR.

     (vector-ref '#(1 1 2 3 5 8 13 21)
                 5)
               ==>  8
     (vector-ref '#(1 1 2 3 5 8 13 21)
                 (exact
                  (round (* 2 (acos -1)))))
               ==> 13


 -- procedure: vector-set! vector k obj

     It is an error if K is not a valid index of VECTOR.  The
     'vector-set!' procedure stores OBJ in element K of VECTOR.

     (let ((vec (vector 0 '(2 2 2 2) "Anna")))
       (vector-set! vec 1 '("Sue" "Sue"))
       vec)
               ==>  #(0 ("Sue" "Sue") "Anna")

     (vector-set! '#(0 1 2) 1 "doe")
               ==>  _error_  ; constant vector


 -- procedure: vector->list vector
 -- procedure: vector->list vector start
 -- procedure: vector->list vector start end
 -- procedure: list->vector list

     The 'vector->list' procedure returns a newly allocated list of the
     objects contained in the elements of VECTOR between START and END.
     The 'list->vector' procedure returns a newly created vector
     initialized to the elements of the list LIST.

     In both procedures, order is preserved.

     (vector->list '#(dah dah didah))
               ==>  (dah dah didah)
     (vector->list '#(dah dah didah) 1 2)
               ==> (dah)
     (list->vector '(dididit dah))
               ==>  #(dididit dah)


 -- procedure: vector->string vector
 -- procedure: vector->string vector start
 -- procedure: vector->string vector start end
 -- procedure: string->vector string
 -- procedure: string->vector string start
 -- procedure: string->vector string start end

     It is an error if any element of VECTOR between START and END is
     not a character.  The 'vector->string' procedure returns a newly
     allocated string of the objects contained in the elements of VECTOR
     between START and END.  The 'string->vector' procedure returns a
     newly created vector initialized to the elements of the string
     STRING between START and END.

     In both procedures, order is preserved.

     (string->vector "ABC")                 ==>   #(#\A #\B #\C)
     (vector->string
       #(#\1 #\2 #\3)
     )
                           ==> "123"


 -- procedure: vector-copy vector
 -- procedure: vector-copy vector start
 -- procedure: vector-copy vector start end

     Returns a newly allocated copy of the elements of the given VECTOR
     between START and END.  The elements of the new vector are the same
     (in the sense of 'eqv?') as the elements of the old.

     (define a #(1 8 2 8)) ; a may be immutable
     (define b (vector-copy a))
     (vector-set! b 0 3)   ; b is mutable
     b                                      ==> #(3 8 2 8)
     (define c (vector-copy b 1 3))
     c                                      ==> #(8 2)


 -- procedure: vector-copy! to at from
 -- procedure: vector-copy! to at from start
 -- procedure: vector-copy! to at from start end

     It is an error if AT is less than zero or greater than the length
     of TO.  It is also an error if '(- (vector-length TO) AT)' is less
     than '(- END START)'.  Copies the elements of vector FROM between
     START and END to vector TO, starting at AT.  The order in which
     elements are copied is unspecified, except that if the source and
     destination overlap, copying takes place as if the source is first
     copied into a temporary vector and then into the destination.  This
     can be achieved without allocating storage by making sure to copy
     in the correct direction in such circumstances.

     (define a (vector 1 2 3 4 5))
     (define b (vector 10 20 30 40 50))
     (vector-copy! b 1 a 0 2)
     b                                      ==> #(10 1 2 40 50)


 -- procedure: vector-append VECTOR ...

     Returns a newly allocated vector whose elements are the
     concatenation of the elements of the given vectors.

     (vector-append #(a b c) #(d e f))
               ==> #(a b c d e f)


 -- procedure: vector-fill! vector fill
 -- procedure: vector-fill! vector fill start
 -- procedure: vector-fill! vector fill start end

     The 'vector-fill!' procedure stores FILL in the elements of VECTOR
     between START and END.

     (define a (vector 1 2 3 4 5))
     (vector-fill! a 'smash 2 4)
     a
               ==> #(1 2 smash smash 5)



File: r7rs.info,  Node: Bytevectors,  Next: Control features,  Prev: Vectors,  Up: Standard procedures

6.9 Bytevectors
===============

"Bytevectors" represent blocks of binary data.  They are fixed-length
sequences of bytes, where a "byte" is an exact integer in the range from
0 to 255 inclusive.  A bytevector is typically more space-efficient than
a vector containing the same values.

The _length_ of a bytevector is the number of elements that it contains.
This number is a non-negative integer that is fixed when the bytevector
is created.  The _valid indexes_ of a bytevector are the exact
non-negative integers less than the length of the bytevector, starting
at index zero as with vectors.

Bytevectors are written using the notation #u8(BYTE ...).  For example,
a bytevector of length 3 containing the byte 0 in element 0, the byte 10
in element 1, and the byte 5 in element 2 can be written as follows:


     #u8(0 10 5)


Bytevector constants are self-evaluating, so they do not need to be
quoted in programs.

 -- procedure: bytevector? obj

     Returns #t if OBJ is a bytevector.  Otherwise, #f is returned.

 -- procedure: make-bytevector k
 -- procedure: make-bytevector k byte

     The 'make-bytevector' procedure returns a newly allocated
     bytevector of length K.  If BYTE is given, then all elements of the
     bytevector are initialized to BYTE, otherwise the contents of each
     element are unspecified.

     (make-bytevector 2 12)                 ==> #u8(12 12)


 -- procedure: bytevector BYTE ...

     Returns a newly allocated bytevector containing its arguments.

     (bytevector 1 3 5 1 3 5)               ==>  #u8(1 3 5 1 3 5)
     (bytevector)                           ==>  #u8()


 -- procedure: bytevector-length bytevector

     Returns the length of BYTEVECTOR in bytes as an exact integer.

 -- procedure: bytevector-u8-ref bytevector k

     It is an error if K is not a valid index of BYTEVECTOR.  Returns
     the Kth byte of BYTEVECTOR.

     (bytevector-u8-ref '#u8(1 1 2 3 5 8 13 21)
                 5)
               ==>  8


 -- procedure: bytevector-u8-set! bytevector k byte

     It is an error if K is not a valid index of BYTEVECTOR.  Stores
     BYTE as the Kth byte of BYTEVECTOR.

     (let ((bv (bytevector 1 2 3 4)))
       (bytevector-u8-set! bv 1 3)
       bv)
               ==> #u8(1 3 3 4)


 -- procedure: bytevector-copy bytevector
 -- procedure: bytevector-copy bytevector start
 -- procedure: bytevector-copy bytevector start end

     Returns a newly allocated bytevector containing the bytes in
     BYTEVECTOR between START and END.

     (define a #u8(1 2 3 4 5))
     (bytevector-copy a 2 4))               ==> #u8(3 4)


 -- procedure: bytevector-copy! to at from
 -- procedure: bytevector-copy! to at from start
 -- procedure: bytevector-copy! to at from start end

     It is an error if AT is less than zero or greater than the length
     of TO.  It is also an error if '(- (bytevector-length TO) AT)' is
     less than '(- END START)'.  Copies the bytes of bytevector FROM
     between START and END to bytevector TO, starting at AT.  The order
     in which bytes are copied is unspecified, except that if the source
     and destination overlap, copying takes place as if the source is
     first copied into a temporary bytevector and then into the
     destination.  This can be achieved without allocating storage by
     making sure to copy in the correct direction in such circumstances.

     (define a (bytevector 1 2 3 4 5))
     (define b (bytevector 10 20 30 40 50))
     (bytevector-copy! b 1 a 0 2)
     b                                      ==> #u8(10 1 2 40 50)


          _Note:_ This procedure appears in R^{6}RS, but places the
          source before the destination, contrary to other such
          procedures in Scheme.

 -- procedure: bytevector-append BYTEVECTOR ...

     Returns a newly allocated bytevector whose elements are the
     concatenation of the elements in the given bytevectors.

     (bytevector-append #u8(0 1 2) #u8(3 4 5))
               ==> #u8(0 1 2 3 4 5)


 -- procedure: utf8->string bytevector
 -- procedure: utf8->string bytevector start
 -- procedure: utf8->string bytevector start end
 -- procedure: string->utf8 string
 -- procedure: string->utf8 string start
 -- procedure: string->utf8 string start end

     It is an error for BYTEVECTOR to contain invalid UTF-8 byte
     sequences.  These procedures translate between strings and
     bytevectors that encode those strings using the UTF-8 encoding.
     The 'utf8->string' procedure decodes the bytes of a bytevector
     between START and END and returns the corresponding string; the
     'string->utf8' procedure encodes the characters of a string between
     START and END and returns the corresponding bytevector.

     (utf8->string #u8(#x41))               ==> "A"
     (string->utf8 "lambda")                   ==> #u8(#xCE #xBB)



File: r7rs.info,  Node: Control features,  Next: Exceptions,  Prev: Bytevectors,  Up: Standard procedures

6.10 Control features
=====================

This section describes various primitive procedures which control the
flow of program execution in special ways.  Procedures in this section
that invoke procedure arguments always do so in the same dynamic
environment as the call of the original procedure.  The 'procedure?'
predicate is also described here.

 -- procedure: procedure? obj

     Returns #t if OBJ is a procedure, otherwise returns #f.

     (procedure? car)                       ==>  #t
     (procedure? 'car)                      ==>  #f
     (procedure? (lambda (x) (* x x)))
                                            ==>  #t
     (procedure? '(lambda (x) (* x x)))
                                            ==>  #f
     (call-with-current-continuation procedure?)
                                            ==>  #t


 -- procedure: apply proc arg1 ... args

     The 'apply' procedure calls PROC with the elements of the list
     '(append (list ARG1 ...) ARGS)' as the actual arguments.

     (apply + (list 3 4))                   ==>  7

     (define compose
       (lambda (f g)
         (lambda args
           (f (apply g args)))))

     ((compose sqrt *) 12 75)               ==>  30


 -- procedure: map proc list1 list2 ...

     It is an error if PROC does not accept as many arguments as there
     are lists and return a single value.  The 'map' procedure applies
     PROC element-wise to the elements of the LISTs and returns a list
     of the results, in order.  If more than one LIST is given and not
     all lists have the same length, 'map' terminates when the shortest
     list runs out.  The LISTs can be circular, but it is an error if
     all of them are circular.  It is an error for PROC to mutate any of
     the lists.  The dynamic order in which PROC is applied to the
     elements of the LISTs is unspecified.  If multiple returns occur
     from 'map', the values returned by earlier returns are not mutated.

     (map cadr '((a b) (d e) (g h)))
               ==>  (b e h)

     (map (lambda (n) (expt n n))
          '(1 2 3 4 5))
               ==>  (1 4 27 256 3125)

     (map + '(1 2 3) '(4 5 6 7))            ==>  (5 7 9)

     (let ((count 0))
       (map (lambda (ignored)
              (set! count (+ count 1))
              count)
            '(a b)))                        ==>  (1 2) OR (2 1)


 -- procedure: string-map proc string1 string2 ...

     It is an error if PROC does not accept as many arguments as there
     are strings and return a single character.  The 'string-map'
     procedure applies PROC element-wise to the elements of the STRINGs
     and returns a string of the results, in order.  If more than one
     STRING is given and not all strings have the same length,
     'string-map' terminates when the shortest string runs out.  The
     dynamic order in which PROC is applied to the elements of the
     STRINGs is unspecified.  If multiple returns occur from
     'string-map', the values returned by earlier returns are not
     mutated.

     (string-map char-foldcase "AbdEgH")
               ==>  "abdegh"

     (string-map
      (lambda (c)
        (integer->char (+ 1 (char->integer c))))
      "HAL")
               ==>  "IBM"

     (string-map
      (lambda (c k)
        ((if (eqv? k #\u) char-upcase char-downcase)
         c))
      "studlycaps xxx"
      "ululululul")
               ==>   "StUdLyCaPs"


 -- procedure: vector-map proc vector1 vector2 ...

     It is an error if PROC does not accept as many arguments as there
     are vectors and return a single value.  The 'vector-map' procedure
     applies PROC element-wise to the elements of the VECTORs and
     returns a vector of the results, in order.  If more than one VECTOR
     is given and not all vectors have the same length, 'vector-map'
     terminates when the shortest vector runs out.  The dynamic order in
     which PROC is applied to the elements of the VECTORs is
     unspecified.  If multiple returns occur from 'vector-map', the
     values returned by earlier returns are not mutated.

     (vector-map cadr '#((a b) (d e) (g h)))
               ==>  #(b e h)

     (vector-map (lambda (n) (expt n n))
                 '#(1 2 3 4 5))
               ==>  #(1 4 27 256 3125)

     (vector-map + '#(1 2 3) '#(4 5 6 7))
               ==>  #(5 7 9)

     (let ((count 0))
       (vector-map
        (lambda (ignored)
          (set! count (+ count 1))
          count)
        '#(a b)))                           ==>  #(1 2) OR #(2 1)


 -- procedure: for-each proc list1 list2 ...

     It is an error if PROC does not accept as many arguments as there
     are lists.  The arguments to 'for-each' are like the arguments to
     'map', but 'for-each' calls PROC for its side effects rather than
     for its values.  Unlike 'map', 'for-each' is guaranteed to call
     PROC on the elements of the LISTs in order from the first
     element(s) to the last, and the value returned by 'for-each' is
     unspecified.  If more than one LIST is given and not all lists have
     the same length, 'for-each' terminates when the shortest list runs
     out.  The LISTs can be circular, but it is an error if all of them
     are circular.

     It is an error for PROC to mutate any of the lists.

     (let ((v (make-vector 5)))
       (for-each (lambda (i)
                   (vector-set! v i (* i i)))
                 '(0 1 2 3 4))
       v)                                   ==>  #(0 1 4 9 16)


 -- procedure: string-for-each proc string1 string2 ...

     It is an error if PROC does not accept as many arguments as there
     are strings.  The arguments to 'string-for-each' are like the
     arguments to 'string-map', but 'string-for-each' calls PROC for its
     side effects rather than for its values.  Unlike 'string-map',
     'string-for-each' is guaranteed to call PROC on the elements of the
     STRINGs in order from the first element(s) to the last, and the
     value returned by 'string-for-each' is unspecified.  If more than
     one STRING is given and not all strings have the same length,
     'string-for-each' terminates when the shortest string runs out.  It
     is an error for PROC to mutate any of the strings.

     (let ((v '()))
       (string-for-each
        (lambda (c) (set! v (cons (char->integer c) v)))
        "abcde")
       v)                                   ==>  (101 100 99 98 97)


 -- procedure: vector-for-each proc vector1 vector2 ...

     It is an error if PROC does not accept as many arguments as there
     are vectors.  The arguments to 'vector-for-each' are like the
     arguments to 'vector-map', but 'vector-for-each' calls PROC for its
     side effects rather than for its values.  Unlike 'vector-map',
     'vector-for-each' is guaranteed to call PROC on the elements of the
     VECTORs in order from the first element(s) to the last, and the
     value returned by 'vector-for-each' is unspecified.  If more than
     one VECTOR is given and not all vectors have the same length,
     'vector-for-each' terminates when the shortest vector runs out.  It
     is an error for PROC to mutate any of the vectors.

     (let ((v (make-list 5)))
       (vector-for-each
        (lambda (i) (list-set! v i (* i i)))
        '#(0 1 2 3 4))
       v)                                   ==>  (0 1 4 9 16)


 -- procedure: call-with-current-continuation proc
 -- procedure: call/cc proc

     It is an error if PROC does not accept one argument.  The procedure
     'call-with-current-continuation' (or its equivalent abbreviation
     'call/cc') packages the current continuation (see the rationale
     below) as an "escape procedure" and passes it as an argument to
     PROC.  The escape procedure is a Scheme procedure that, if it is
     later called, will abandon whatever continuation is in effect at
     that later time and will instead use the continuation that was in
     effect when the escape procedure was created.  Calling the escape
     procedure will cause the invocation of BEFORE and AFTER thunks
     installed using 'dynamic-wind'.

     The escape procedure accepts the same number of arguments as the
     continuation to the original call to
     call-with-current-continuation.  Most continuations take only one
     value.  Continuations created by the 'call-with-values' procedure
     (including the initialization expressions of 'define-values',
     'let-values', and 'let*-values' expressions), take the number of
     values that the consumer expects.  The continuations of all
     non-final expressions within a sequence of expressions, such as in
     'lambda', 'case-lambda', 'begin', 'let', 'let*', 'letrec',
     'letrec*', 'let-values', 'let*-values', 'let-syntax',
     'letrec-syntax', 'parameterize', 'guard', 'case', 'cond', 'when',
     and 'unless' expressions, take an arbitrary number of values
     because they discard the values passed to them in any event.  The
     effect of passing no values or more than one value to continuations
     that were not created in one of these ways is unspecified.

     The escape procedure that is passed to PROC has unlimited extent
     just like any other procedure in Scheme.  It can be stored in
     variables or data structures and can be called as many times as
     desired.  However, like the 'raise' and 'error' procedures, it
     never returns to its caller.

     The following examples show only the simplest ways in which
     'call-with-current-continuation' is used.  If all real uses were as
     simple as these examples, there would be no need for a procedure
     with the power of 'call-with-current-continuation'.

     (call-with-current-continuation
       (lambda (exit)
         (for-each (lambda (x)
                     (if (negative? x)
                         (exit x)))
                   '(54 0 37 -3 245 19))
         #t))                               ==>  -3

     (define list-length
       (lambda (obj)
         (call-with-current-continuation
           (lambda (return)
             (letrec ((r
                       (lambda (obj)
                         (cond ((null? obj) 0)
                               ((pair? obj)
                                (+ (r (cdr obj)) 1))
                               (else (return #f))))))
               (r obj))))))

     (list-length '(1 2 3 4))               ==>  4

     (list-length '(a b . c))               ==>  #f


          _Rationale:_

          A common use of 'call-with-current-continuation' is for
          structured, non-local exits from loops or procedure bodies,
          but in fact 'call-with-current-continuation' is useful for
          implementing a wide variety of advanced control structures.
          In fact, 'raise' and 'guard' provide a more structured
          mechanism for non-local exits.

          Whenever a Scheme expression is evaluated there is a
          "continuation" wanting the result of the expression.  The
          continuation represents an entire (default) future for the
          computation.  If the expression is evaluated at the REPL, for
          example, then the continuation might take the result, print it
          on the screen, prompt for the next input, evaluate it, and so
          on forever.  Most of the time the continuation includes
          actions specified by user code, as in a continuation that will
          take the result, multiply it by the value stored in a local
          variable, add seven, and give the answer to the REPL's
          continuation to be printed.  Normally these ubiquitous
          continuations are hidden behind the scenes and programmers do
          not think much about them.  On rare occasions, however, a
          programmer needs to deal with continuations explicitly.  The
          'call-with-current-continuation' procedure allows Scheme
          programmers to do that by creating a procedure that acts just
          like the current continuation.

 -- procedure: values obj ...

     Delivers all of its arguments to its continuation.  The values
     procedure might be defined as follows:

     (define (values . things)
       (call-with-current-continuation
         (lambda (cont) (apply cont things))))


 -- procedure: call-with-values producer consumer

     Calls its PRODUCER argument with no arguments and a continuation
     that, when passed some values, calls the CONSUMER procedure with
     those values as arguments.  The continuation for the call to
     CONSUMER is the continuation of the call to call-with-values.

     (call-with-values (lambda () (values 4 5))
                       (lambda (a b) b))
                                                        ==>  5

     (call-with-values * -)                             ==>  -1


 -- procedure: dynamic-wind before thunk after

     Calls THUNK without arguments, returning the result(s) of this
     call.  BEFORE and AFTER are called, also without arguments, as
     required by the following rules.  Note that, in the absence of
     calls to continuations captured using
     'call-with-current-continuation', the three arguments are called
     once each, in order.  BEFORE is called whenever execution enters
     the dynamic extent of the call to THUNK and AFTER is called
     whenever it exits that dynamic extent.  The dynamic extent of a
     procedure call is the period between when the call is initiated and
     when it returns.  The BEFORE and AFTER thunks are called in the
     same dynamic environment as the call to 'dynamic-wind'.  In Scheme,
     because of 'call-with-current-continuation', the dynamic extent of
     a call is not always a single, connected time period.  It is
     defined as follows:

        * The dynamic extent is entered when execution of the body of
          the called procedure begins.

        * The dynamic extent is also entered when execution is not
          within the dynamic extent and a continuation is invoked that
          was captured (using 'call-with-current-continuation') during
          the dynamic extent.

        * It is exited when the called procedure returns.

        * It is also exited when execution is within the dynamic extent
          and a continuation is invoked that was captured while not
          within the dynamic extent.

     If a second call to 'dynamic-wind' occurs within the dynamic extent
     of the call to THUNK and then a continuation is invoked in such a
     way that the AFTERs from these two invocations of 'dynamic-wind'
     are both to be called, then the AFTER associated with the second
     (inner) call to 'dynamic-wind' is called first.

     If a second call to 'dynamic-wind' occurs within the dynamic extent
     of the call to THUNK and then a continuation is invoked in such a
     way that the BEFOREs from these two invocations of 'dynamic-wind'
     are both to be called, then the BEFORE associated with the first
     (outer) call to 'dynamic-wind' is called first.

     If invoking a continuation requires calling the BEFORE from one
     call to 'dynamic-wind' and the AFTER from another, then the AFTER
     is called first.

     The effect of using a captured continuation to enter or exit the
     dynamic extent of a call to BEFORE or AFTER is unspecified.

     (let ((path '())
           (c #f))
       (let ((add (lambda (s)
                    (set! path (cons s path)))))
         (dynamic-wind
           (lambda () (add 'connect))
           (lambda ()
             (add (call-with-current-continuation
                    (lambda (c0)
                      (set! c c0)
                      'talk1))))
           (lambda () (add 'disconnect)))
         (if (< (length path) 4)
             (c 'talk2)
             (reverse path))))

               ==> (connect talk1 disconnect
                    connect talk2 disconnect)



File: r7rs.info,  Node: Exceptions,  Next: Environments and evaluation,  Prev: Control features,  Up: Standard procedures

6.11 Exceptions
===============

This section describes Scheme's exception-handling and exception-raising
procedures.  For the concept of Scheme exceptions, see section *note
Error situations and unspecified behavior::.  See also *note guard:: for
the 'guard' syntax.

"Exception handler"s are one-argument procedures that determine the
action the program takes when an exceptional situation is signaled.  The
system implicitly maintains a current exception handler in the dynamic
environment.

The program raises an exception by invoking the current exception
handler, passing it an object encapsulating information about the
exception.  Any procedure accepting one argument can serve as an
exception handler and any object can be used to represent an exception.

 -- procedure: with-exception-handler HANDLER THUNK

     It is an error if HANDLER does not accept one argument.  It is also
     an error if THUNK does not accept zero arguments.  The
     'with-exception-handler' procedure returns the results of invoking
     THUNK.  HANDLER is installed as the current exception handler in
     the dynamic environment used for the invocation of THUNK.

     (call-with-current-continuation
      (lambda (k)
       (with-exception-handler
        (lambda (x)
         (display "condition: ")
         (write x)
         (newline)
         (k 'exception))
        (lambda ()
         (+ 1 (raise 'an-error))))))
                                            ==> exception
               _and prints_  condition: an-error

     (with-exception-handler
      (lambda (x)
       (display "something went wrong\n"))
      (lambda ()
       (+ 1 (raise 'an-error))))
               _prints_  something went wrong


     After printing, the second example then raises another exception.

 -- procedure: raise OBJ

     Raises an exception by invoking the current exception handler on
     OBJ.  The handler is called with the same dynamic environment as
     that of the call to 'raise', except that the current exception
     handler is the one that was in place when the handler being called
     was installed.  If the handler returns, a secondary exception is
     raised in the same dynamic environment as the handler.  The
     relationship between OBJ and the object raised by the secondary
     exception is unspecified.

 -- procedure: raise-continuable OBJ

     Raises an exception by invoking the current exception handler on
     OBJ.  The handler is called with the same dynamic environment as
     the call to 'raise-continuable', except that: (1) the current
     exception handler is the one that was in place when the handler
     being called was installed, and (2) if the handler being called
     returns, then it will again become the current exception handler.
     If the handler returns, the values it returns become the values
     returned by the call to 'raise-continuable'.


     (with-exception-handler
       (lambda (con)
         (cond
           ((string? con)
            (display con))
           (else
            (display "a warning has been issued")))
         42)
       (lambda ()
         (+ (raise-continuable "should be a number")
            23)))
        prints: should be a number
                                            ==> 65


 -- procedure: error MESSAGE OBJ ...

     MESSAGE should be a string.  Raises an exception as if by calling
     'raise' on a newly allocated implementation-defined object which
     encapsulates the information provided by MESSAGE, as well as any
     OBJs, known as the "irritants".  The procedure 'error-object?' must
     return #t on such objects.

     (define (null-list? l)
       (cond ((pair? l) #f)
             ((null? l) #t)
             (else
               (error
                 "null-list?: argument out of domain"
                 l))))


 -- procedure: error-object? obj

     Returns #t if OBJ is an object created by 'error' or one of an
     implementation-defined set of objects.  Otherwise, it returns #f.
     The objects used to signal errors, including those which satisfy
     the predicates 'file-error?' and 'read-error?', may or may not
     satisfy 'error-object?'.

 -- procedure: error-object-message error-object

     Returns the message encapsulated by ERROR-OBJECT.

 -- procedure: error-object-irritants error-object

     Returns a list of the irritants encapsulated by ERROR-OBJECT.

 -- procedure: read-error? obj
 -- procedure: file-error? obj

     Error type predicates.  Returns #t if OBJ is an object raised by
     the 'read' procedure or by the inability to open an input or output
     port on a file, respectively.  Otherwise, it returns #f.


File: r7rs.info,  Node: Environments and evaluation,  Next: Input and output,  Prev: Exceptions,  Up: Standard procedures

6.12 Environments and evaluation
================================

 -- eval library procedure: environment list1 ...

     This procedure returns a specifier for the environment that results
     by starting with an empty environment and then importing each LIST,
     considered as an import set, into it.  (See section *note
     Libraries:: for a description of import sets.)  The bindings of the
     environment represented by the specifier are immutable, as is the
     environment itself.

 -- r5rs library procedure: scheme-report-environment version

     If VERSION is equal to '5', corresponding to R^{5}RS,
     'scheme-report-environment' returns a specifier for an environment
     that contains only the bindings defined in the R^{5}RS library.
     Implementations must support this value of VERSION.

     Implementations may also support other values of VERSION, in which
     case they return a specifier for an environment containing bindings
     corresponding to the specified version of the report.  If VERSION
     is neither '5' nor another value supported by the implementation,
     an error is signaled.

     The effect of defining or assigning (through the use of 'eval') an
     identifier bound in a 'scheme-report-environment' (for example
     'car') is unspecified.  Thus both the environment and the bindings
     it contains may be immutable.

 -- r5rs library procedure: null-environment version

     If VERSION is equal to '5', corresponding to R^{5}RS, the
     'null-environment' procedure returns a specifier for an environment
     that contains only the bindings for all syntactic keywords defined
     in the R^{5}RS library.  Implementations must support this value of
     VERSION.

     Implementations may also support other values of VERSION, in which
     case they return a specifier for an environment containing
     appropriate bindings corresponding to the specified version of the
     report.  If VERSION is neither '5' nor another value supported by
     the implementation, an error is signaled.

     The effect of defining or assigning (through the use of 'eval') an
     identifier bound in a 'scheme-report-environment' (for example
     'car') is unspecified.  Thus both the environment and the bindings
     it contains may be immutable.

 -- repl library procedure: interaction-environment

     This procedure returns a specifier for a mutable environment that
     contains an implementation-defined set of bindings, typically a
     superset of those exported by '(scheme base)'.  The intent is that
     this procedure will return the environment in which the
     implementation would evaluate expressions entered by the user into
     a REPL.

 -- eval library procedure: eval expr-or-def environment-specifier

     If EXPR-OR-DEF is an expression, it is evaluated in the specified
     environment and its values are returned.  If it is a definition,
     the specified identifier(s) are defined in the specified
     environment, provided the environment is not immutable.
     Implementations may extend 'eval' to allow other objects.

     (eval '(* 7 3) (environment '(scheme base)))
                                                        ==>  21

     (let ((f (eval '(lambda (f x) (f x x))
                    (null-environment 5))))
       (f + 10))
                                                        ==>  20
     (eval '(define foo 32)
           (environment '(scheme base)))
                                                        ==>  error is signaled



File: r7rs.info,  Node: Input and output,  Next: System interface,  Prev: Environments and evaluation,  Up: Standard procedures

6.13 Input and output
=====================

* Menu:

* Ports::
* Input::
* Output::


File: r7rs.info,  Node: Ports,  Next: Input,  Prev: Input and output,  Up: Input and output

6.13.1 Ports
------------

Ports represent input and output devices.  To Scheme, an input port is a
Scheme object that can deliver data upon command, while an output port
is a Scheme object that can accept data.  Whether the input and output
port types are disjoint is implementation-dependent.

Different _port types_ operate on different data.  Scheme
implementations are required to support _textual ports_ and _binary
ports_, but may also provide other port types.

A textual port supports reading or writing of individual characters from
or to a backing store containing characters using 'read-char' and
'write-char' below, and it supports operations defined in terms of
characters, such as 'read' and 'write'.

A binary port supports reading or writing of individual bytes from or to
a backing store containing bytes using 'read-u8' and 'write-u8' below,
as well as operations defined in terms of bytes.  Whether the textual
and binary port types are disjoint is implementation-dependent.

Ports can be used to access files, devices, and similar things on the
host system on which the Scheme program is running.

 -- procedure: call-with-port port proc

     It is an error if PROC does not accept one argument.  The
     'call-with-port' procedure calls PROC with PORT as an argument.  If
     PROC returns, then the port is closed automatically and the values
     yielded by the PROC are returned.  If PROC does not return, then
     the port must not be closed automatically unless it is possible to
     prove that the port will never again be used for a read or write
     operation.

          _Rationale:_ Because Scheme's escape procedures have unlimited
          extent, it is possible to escape from the current continuation
          but later to resume it.  If implementations were permitted to
          close the port on any escape from the current continuation,
          then it would be impossible to write portable code using both
          'call-with-current-continuation' and 'call-with-port'.

 -- file library procedure: call-with-input-file string proc
 -- file library procedure: call-with-output-file string proc

     It is an error if PROC does not accept one argument.  These
     procedures obtain a textual port obtained by opening the named file
     for input or output as if by 'open-input-file' or
     'open-output-file'.  The port and PROC are then passed to a
     procedure equivalent to 'call-with-port'.

 -- procedure: input-port? obj
 -- procedure: output-port? obj
 -- procedure: textual-port? obj
 -- procedure: binary-port? obj
 -- procedure: port? obj

     These procedures return #t if OBJ is an input port, output port,
     textual port, binary port, or any kind of port, respectively.
     Otherwise they return #f.

 -- procedure: input-port-open? port
 -- procedure: output-port-open? port

     Returns #t if PORT is still open and capable of performing input or
     output, respectively, and #f otherwise.

 -- procedure: current-input-port
 -- procedure: current-output-port
 -- procedure: current-error-port

     Returns the current default input port, output port, or error port
     (an output port), respectively.  These procedures are parameter
     objects, which can be overridden with 'parameterize' (see section
     *note Dynamic bindings::).  The initial bindings for these are
     implementation-defined textual ports.

 -- file library procedure: with-input-from-file string thunk
 -- file library procedure: with-output-to-file string thunk

     The file is opened for input or output as if by 'open-input-file'
     or 'open-output-file', and the new port is made to be the value
     returned by 'current-input-port' or 'current-output-port' (as used
     by (read), (write OBJ), and so forth).  The THUNK is then called
     with no arguments.  When the THUNK returns, the port is closed and
     the previous default is restored.  It is an error if THUNK does not
     accept zero arguments.  Both procedures return the values yielded
     by THUNK.  If an escape procedure is used to escape from the
     continuation of these procedures, they behave exactly as if the
     current input or output port had been bound dynamically with
     'parameterize'.

 -- file library procedure: open-input-file string
 -- file library procedure: open-binary-input-file string

     Takes a STRING for an existing file and returns a textual input
     port or binary input port that is capable of delivering data from
     the file.  If the file does not exist or cannot be opened, an error
     that satisfies 'file-error?' is signaled.

 -- file library procedure: open-output-file string
 -- file library procedure: open-binary-output-file string

     Takes a STRING naming an output file to be created and returns a
     textual output port or binary output port that is capable of
     writing data to a new file by that name.

     If a file with the given name already exists, the effect is
     unspecified.  If the file cannot be opened, an error that satisfies
     'file-error?' is signaled.

 -- procedure: close-port port
 -- procedure: close-input-port port
 -- procedure: close-output-port port

     Closes the resource associated with PORT, rendering the PORT
     incapable of delivering or accepting data.  It is an error to apply
     the last two procedures to a port which is not an input or output
     port, respectively.  Scheme implementations may provide ports which
     are simultaneously input and output ports, such as sockets; the
     'close-input-port' and 'close-output-port' procedures can then be
     used to close the input and output sides of the port independently.

     These routines have no effect if the port has already been closed.

 -- procedure: open-input-string string

     Takes a string and returns a textual input port that delivers
     characters from the string.  If the string is modified, the effect
     is unspecified.

 -- procedure: open-output-string

     Returns a textual output port that will accumulate characters for
     retrieval by 'get-output-string'.

 -- procedure: get-output-string port

     It is an error if PORT was not created with 'open-output-string'.
     Returns a string consisting of the characters that have been output
     to the port so far in the order they were output.  If the result
     string is modified, the effect is unspecified.

     (parameterize
         ((current-output-port
           (open-output-string)))
         (display "piece")
         (display " by piece ")
         (display "by piece.")
         (newline)
         (get-output-string (current-output-port)))

               ==> "piece by piece by piece.\n"


 -- procedure: open-input-bytevector bytevector

     Takes a bytevector and returns a binary input port that delivers
     bytes from the bytevector.

 -- procedure: open-output-bytevector

     Returns a binary output port that will accumulate bytes for
     retrieval by 'get-output-bytevector'.

 -- procedure: get-output-bytevector port

     It is an error if PORT was not created with
     'open-output-bytevector'.  Returns a bytevector consisting of the
     bytes that have been output to the port so far in the order they
     were output.


File: r7rs.info,  Node: Input,  Next: Output,  Prev: Ports,  Up: Input and output

6.13.2 Input
------------

If PORT is omitted from any input procedure, it defaults to the value
returned by '(current-input-port)'.  It is an error to attempt an input
operation on a closed port.

 





 -- read library procedure: read
 -- read library procedure: read port

     The 'read' procedure converts external representations of Scheme
     objects into the objects themselves.  That is, it is a parser for
     the non-terminal <datum> (see sections *note External
     representation:: and *note Pairs and lists::).  It returns the next
     object parsable from the given textual input PORT, updating PORT to
     point to the first character past the end of the external
     representation of the object.

     Implementations may support extended syntax to represent record
     types or other types that do not have datum representations.

     If an end of file is encountered in the input before any characters
     are found that can begin an object, then an end-of-file object is
     returned.  The port remains open, and further attempts to read will
     also return an end-of-file object.  If an end of file is
     encountered after the beginning of an object's external
     representation, but the external representation is incomplete and
     therefore not parsable, an error that satisfies 'read-error?' is
     signaled.

 -- procedure: read-char
 -- procedure: read-char port

     Returns the next character available from the textual input PORT,
     updating the PORT to point to the following character.  If no more
     characters are available, an end-of-file object is returned.

 -- procedure: peek-char
 -- procedure: peek-char port

     Returns the next character available from the textual input PORT,
     but _without_ updating the PORT to point to the following
     character.  If no more characters are available, an end-of-file
     object is returned.

          _Note:_ The value returned by a call to 'peek-char' is the
          same as the value that would have been returned by a call to
          'read-char' with the same PORT.  The only difference is that
          the very next call to 'read-char' or 'peek-char' on that PORT
          will return the value returned by the preceding call to
          'peek-char'.  In particular, a call to 'peek-char' on an
          interactive port will hang waiting for input whenever a call
          to 'read-char' would have hung.

 -- procedure: read-line
 -- procedure: read-line port

     Returns the next line of text available from the textual input
     PORT, updating the PORT to point to the following character.  If an
     end of line is read, a string containing all of the text up to (but
     not including) the end of line is returned, and the port is updated
     to point just past the end of line.  If an end of file is
     encountered before any end of line is read, but some characters
     have been read, a string containing those characters is returned.
     If an end of file is encountered before any characters are read, an
     end-of-file object is returned.  For the purpose of this procedure,
     an end of line consists of either a linefeed character, a carriage
     return character, or a sequence of a carriage return character
     followed by a linefeed character.  Implementations may also
     recognize other end of line characters or sequences.

 -- procedure: eof-object? obj

     Returns #t if OBJ is an end-of-file object, otherwise returns #f.
     The precise set of end-of-file objects will vary among
     implementations, but in any case no end-of-file object will ever be
     an object that can be read in using 'read'.

 -- procedure: eof-object

     Returns an end-of-file object, not necessarily unique.

 -- procedure: char-ready?
 -- procedure: char-ready? port

     Returns #t if a character is ready on the textual input PORT and
     returns #f otherwise.  If 'char-ready' returns #t then the next
     'read-char' operation on the given PORT is guaranteed not to hang.
     If the PORT is at end of file then 'char-ready?' returns #t.

          _Rationale:_ The 'char-ready?' procedure exists to make it
          possible for a program to accept characters from interactive
          ports without getting stuck waiting for input.  Any input
          editors associated with such ports must ensure that characters
          whose existence has been asserted by 'char-ready?' cannot be
          removed from the input.  If 'char-ready?' were to return #f at
          end of file, a port at end of file would be indistinguishable
          from an interactive port that has no ready characters.

 -- procedure: read-string k
 -- procedure: read-string k port

     Reads the next K characters, or as many as are available before the
     end of file, from the textual input PORT into a newly allocated
     string in left-to-right order and returns the string.  If no
     characters are available before the end of file, an end-of-file
     object is returned.

 -- procedure: read-u8
 -- procedure: read-u8 port

     Returns the next byte available from the binary input PORT,
     updating the PORT to point to the following byte.  If no more bytes
     are available, an end-of-file object is returned.

 -- procedure: peek-u8
 -- procedure: peek-u8 port

     Returns the next byte available from the binary input PORT, but
     _without_ updating the PORT to point to the following byte.  If no
     more bytes are available, an end-of-file object is returned.

 -- procedure: u8-ready?
 -- procedure: u8-ready? port

     Returns #t if a byte is ready on the binary input PORT and returns
     #f otherwise.  If 'u8-ready?' returns #t then the next 'read-u8'
     operation on the given PORT is guaranteed not to hang.  If the PORT
     is at end of file then 'u8-ready?' returns #t.

 -- procedure: read-bytevector k
 -- procedure: read-bytevector k port

     Reads the next K bytes, or as many as are available before the end
     of file, from the binary input PORT into a newly allocated
     bytevector in left-to-right order and returns the bytevector.  If
     no bytes are available before the end of file, an end-of-file
     object is returned.

 -- procedure: read-bytevector! bytevector
 -- procedure: read-bytevector! bytevector port
 -- procedure: read-bytevector! bytevector port start
 -- procedure: read-bytevector! bytevector port start end

     Reads the next end - start bytes, or as many as are available
     before the end of file, from the binary input PORT into BYTEVECTOR
     in left-to-right order beginning at the START position.  If END is
     not supplied, reads until the end of BYTEVECTOR has been reached.
     If START is not supplied, reads beginning at position 0.  Returns
     the number of bytes read.  If no bytes are available, an
     end-of-file object is returned.


File: r7rs.info,  Node: Output,  Prev: Input,  Up: Input and output

6.13.3 Output
-------------

If PORT is omitted from any output procedure, it defaults to the value
returned by '(current-output-port)'.  It is an error to attempt an
output operation on a closed port.






 -- write library procedure: write obj
 -- write library procedure: write obj port

     Writes a representation of OBJ to the given textual output PORT.
     Strings that appear in the written representation are enclosed in
     quotation marks, and within those strings backslash and quotation
     mark characters are escaped by backslashes.  Symbols that contain
     non-ASCII characters are escaped with vertical lines.  Character
     objects are written using the '#\' notation.

     If OBJ contains cycles which would cause an infinite loop using the
     normal written representation, then at least the objects that form
     part of the cycle must be represented using datum labels as
     described in section *note Datum labels::.  Datum labels must not
     be used if there are no cycles.

     Implementations may support extended syntax to represent record
     types or other types that do not have datum representations.

     The 'write' procedure returns an unspecified value.

 -- write library procedure: write-shared obj
 -- write library procedure: write-shared obj port

     The 'write-shared' procedure is the same as 'write', except that
     shared structure must be represented using datum labels for all
     pairs and vectors that appear more than once in the output.

 -- write library procedure: write-simple obj
 -- write library procedure: write-simple obj port

     The 'write-simple' procedure is the same as 'write', except that
     shared structure is never represented using datum labels.  This can
     cause 'write-simple' not to terminate if OBJ contains circular
     structure.

 -- write library procedure: display obj
 -- write library procedure: display obj port

     Writes a representation of OBJ to the given textual output PORT.
     Strings that appear in the written representation are output as if
     by 'write-string' instead of by 'write'.  Symbols are not escaped.
     Character objects appear in the representation as if written by
     'write-char' instead of by 'write'.

     The 'display' representation of other objects is unspecified.
     However, 'display' must not loop forever on self-referencing pairs,
     vectors, or records.  Thus if the normal 'write' representation is
     used, datum labels are needed to represent cycles as in 'write'.

     Implementations may support extended syntax to represent record
     types or other types that do not have datum representations.

     The 'display' procedure returns an unspecified value.

          _Rationale:_ The 'write' procedure is intended for producing
          machine-readable output and 'display' for producing
          human-readable output.

 -- procedure: newline
 -- procedure: newline port

     Writes an end of line to textual output PORT.  Exactly how this is
     done differs from one operating system to another.  Returns an
     unspecified value.

 -- procedure: write-char char
 -- procedure: write-char char port

     Writes the character CHAR (not an external representation of the
     character) to the given textual output PORT and returns an
     unspecified value.

 -- procedure: write-string string
 -- procedure: write-string string port
 -- procedure: write-string string port start
 -- procedure: write-string string port start end

     Writes the characters of STRING from START to END in left-to-right
     order to the textual output PORT.

 -- procedure: write-u8 byte
 -- procedure: write-u8 byte port

     Writes the BYTE to the given binary output PORT and returns an
     unspecified value.

 -- procedure: write-bytevector bytevector
 -- procedure: write-bytevector bytevector port
 -- procedure: write-bytevector bytevector port start
 -- procedure: write-bytevector bytevector port start end

     Writes the bytes of BYTEVECTOR from START to END in left-to-right
     order to the binary output PORT.

 -- procedure: flush-output-port
 -- procedure: flush-output-port port

     Flushes any buffered output from the buffer of output-port to the
     underlying file or device and returns an unspecified value.


File: r7rs.info,  Node: System interface,  Prev: Input and output,  Up: Standard procedures

6.14 System interface
=====================

Questions of system interface generally fall outside of the domain of
this report.  However, the following operations are important enough to
deserve description here.

 -- load library procedure: load filename
 -- load library procedure: load filename environment-specifier

     It is an error if FILENAME is not a string.  An
     implementation-dependent operation is used to transform FILENAME
     into the name of an existing file containing Scheme source code.
     The 'load' procedure reads expressions and definitions from the
     file and evaluates them sequentially in the environment specified
     by ENVIRONMENT-SPECIFIER.  If ENVIRONMENT-SPECIFIER is omitted,
     '(interaction-environment)' is assumed.

     It is unspecified whether the results of the expressions are
     printed.  The 'load' procedure does not affect the values returned
     by 'current-input-port' and 'current-output-port'.  It returns an
     unspecified value.

          _Rationale:_ For portability, 'load' must operate on source
          files.  Its operation on other kinds of files necessarily
          varies among implementations.

 -- file library procedure: file-exists? filename

     It is an error if FILENAME is not a string.  The 'file-exists?'
     procedure returns #t if the named file exists at the time the
     procedure is called, and #f otherwise.

 -- file library procedure: delete-file filename

     It is an error if FILENAME is not a string.  The 'delete-file'
     procedure deletes the named file if it exists and can be deleted,
     and returns an unspecified value.  If the file does not exist or
     cannot be deleted, an error that satisfies 'file-error?' is
     signaled.

 -- process-context library procedure: command-line

     Returns the command line passed to the process as a list of
     strings.  The first string corresponds to the command name, and is
     implementation-dependent.  It is an error to mutate any of these
     strings.

 -- process-context library procedure: exit
 -- process-context library procedure: exit obj

     Runs all outstanding dynamic-wind AFTER procedures, terminates the
     running program, and communicates an exit value to the operating
     system.  If no argument is supplied, or if OBJ is #t, the 'exit'
     procedure should communicate to the operating system that the
     program exited normally.  If OBJ is #f, the 'exit' procedure should
     communicate to the operating system that the program exited
     abnormally.  Otherwise, 'exit' should translate OBJ into an
     appropriate exit value for the operating system, if possible.

     The 'exit' procedure must not signal an exception or return to its
     continuation.

          _Note:_ Because of the requirement to run handlers, this
          procedure is not just the operating system's exit procedure.

 -- process-context library procedure: emergency-exit
 -- process-context library procedure: emergency-exit obj

     Terminates the program without running any outstanding dynamic-wind
     AFTER procedures and communicates an exit value to the operating
     system in the same manner as 'exit'.

          _Note:_ The 'emergency-exit' procedure corresponds to the '
          exit' procedure in Windows and Posix.

 -- process-context library procedure: get-environment-variable name

     Many operating systems provide each running process with an
     "environment" consisting of "environment variables".  (This
     environment is not to be confused with the Scheme environments that
     can be passed to 'eval': see section *note Environments and
     evaluation::.)  Both the name and value of an environment variable
     are strings.  The procedure 'get-environment-variable' returns the
     value of the environment variable NAME, or #f if the named
     environment variable is not found.  It may use locale information
     to encode the name and decode the value of the environment
     variable.  It is an error if 'get-environment-variable' can't
     decode the value.  It is also an error to mutate the resulting
     string.

     (get-environment-variable "PATH")
               ==> "/usr/local/bin:/usr/bin:/bin"


 -- process-context library procedure: get-environment-variables

     Returns the names and values of all the environment variables as an
     alist, where the car of each entry is the name of an environment
     variable and the cdr is its value, both as strings.  The order of
     the list is unspecified.  It is an error to mutate any of these
     strings or the alist itself.

     (get-environment-variables)
               ==> (("USER" . "root") ("HOME" . "/"))


 -- time library procedure: current-second

     Returns an inexact number representing the current time on the
     International Atomic Time (TAI) scale.  The value 0.0 represents
     midnight on January 1, 1970 TAI (equivalent to 8.000082 seconds
     before midnight Universal Time) and the value 1.0 represents one
     TAI second later.  Neither high accuracy nor high precision are
     required; in particular, returning Coordinated Universal Time plus
     a suitable constant might be the best an implementation can do.

     As of 2018, a TAI-UTC offset table can be found at [TAI].

 -- time library procedure: current-jiffy

     Returns the number of "jiffies" as an exact integer that have
     elapsed since an arbitrary, implementation-defined epoch.  A jiffy
     is an implementation-defined fraction of a second which is defined
     by the return value of the 'jiffies-per-second' procedure.  The
     starting epoch is guaranteed to be constant during a run of the
     program, but may vary between runs.

          _Rationale:_ Jiffies are allowed to be
          implementation-dependent so that 'current-jiffy' can execute
          with minimum overhead.  It should be very likely that a
          compactly represented integer will suffice as the returned
          value.  Any particular jiffy size will be inappropriate for
          some implementations: a microsecond is too long for a very
          fast machine, while a much smaller unit would force many
          implementations to return integers which have to be allocated
          for most calls, rendering 'current-jiffy' less useful for
          accurate timing measurements.

 -- time library procedure: jiffies-per-second

     Returns an exact integer representing the number of jiffies per SI
     second.  This value is an implementation-specified constant.

     (define (time-length)
       (let ((list (make-list 100000))
             (start (current-jiffy)))
         (length list)
         (/ (- (current-jiffy) start)
            (jiffies-per-second))))


 -- procedure: features

     Returns a list of the feature identifiers which 'cond-expand'
     treats as true.  It is an error to modify this list.  Here is an
     example of what 'features' might return:

     (features)                             ==>
       (r7rs ratios exact-complex full-unicode
        gnu-linux little-endian
        fantastic-scheme
        fantastic-scheme-1.0
        space-ship-control-system)



File: r7rs.info,  Node: Formal syntax and semantics,  Next: Standard Libraries,  Prev: Standard procedures,  Up: Top

7 Formal syntax and semantics
*****************************

* Menu:

* Formal syntax::
* Formal semantics::
* Derived expression type::

This chapter provides formal descriptions of what has already been
described informally in previous chapters of this report.


File: r7rs.info,  Node: Formal syntax,  Next: Formal semantics,  Prev: Formal syntax and semantics,  Up: Formal syntax and semantics

7.1 Formal syntax
=================

* Menu:

* Lexical structure::
* External representation::
* Expression::
* Quasiquotations::
* Transformers::
* Programs and definitions::
* Librarie::

This section provides a formal syntax for Scheme written in an extended
BNF.

All spaces in the grammar are for legibility.  Case is not significant
except in the definitions of <letter>, <character name> and <mnemonic
escape>; for example, '#x1A' and '#X1a' are equivalent, but 'foo' and
'Foo' and '#\space' and '#\Space' are distinct.  <empty> stands for the
empty string.

The following extensions to BNF are used to make the description more
concise: <thing>* means zero or more occurrences of <thing>; and
<thing>+ means at least one <thing>.


File: r7rs.info,  Node: Lexical structure,  Next: External representation,  Prev: Formal syntax,  Up: Formal syntax

7.1.1 Lexical structure
-----------------------

This section describes how individual tokens (identifiers, numbers,
etc.)  are formed from sequences of characters.  The following sections
describe how expressions and programs are formed from sequences of
tokens.

<Intertoken space> can occur on either side of any token, but not within
a token.

Identifiers that do not begin with a vertical line are terminated by a
<delimiter> or by the end of the input.  So are dot, numbers,
characters, and booleans.  Identifiers that begin with a vertical line
are terminated by another vertical line.

The following four characters from the ASCII repertoire are reserved for
future extensions to the language: [ ] { }

In addition to the identifier characters of the ASCII repertoire
specified below, Scheme implementations may permit any additional
repertoire of non-ASCII Unicode characters to be employed in
identifiers, provided that each such character has a Unicode general
category of Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Pd, Pc, Po, Sc,
Sm, Sk, So, or Co, or is U+200C or U+200D (the zero-width non-joiner and
joiner, respectively, which are needed for correct spelling in Persian,
Hindi, and other languages).  However, it is an error for the first
character to have a general category of Nd, Mc, or Me.  It is also an
error to use a non-Unicode character in symbols or identifiers.

All Scheme implementations must permit the escape sequence
\x<hexdigits>; to appear in Scheme identifiers that are enclosed in
vertical lines.  If the character with the given Unicode scalar value is
supported by the implementation, identifiers containing such a sequence
are equivalent to identifiers containing the corresponding character.

<token> --> <identifier> | <boolean> | <number>
     | <character> | <string>
     | ( | ) | #( | # u8( | ' | ` | , | ,@ | .
<delimiter> --> <whitespace> | <vertical line>
    | ( | ) | " | ;
<intraline whitespace> --> <space or tab>
<whitespace> --> <intraline whitespace> | <line ending>
<vertical line> --> |
<line ending> --> <newline> | <return> <newline>
    | <return>
<comment> --> ;  <all subsequent characters up to a
                 line ending>
                 | <nested comment>
                 | #; <intertoken space> <datum>
<nested comment> --> #|  <comment text>
                         <comment cont>* |#
<comment text> -->  <character sequence not containing
                    #| or |#>
<comment cont> --> <nested comment> <comment text>
<directive> --> #!fold-case | #!no-fold-case


Note that it is ungrammatical to follow a <directive> with anything but
a <delimiter> or the end of file.

<atmosphere> --> <whitespace> | <comment> | <directive>
<intertoken space> --> <atmosphere>*


Note that '+i', '-i' and <infnan> below are exceptions to the <peculiar
identifier> rule; they are parsed as numbers, not identifiers.

<identifier> --> <initial> <subsequent>*
     | <vertical line> <symbol element>* <vertical line>
     | <peculiar identifier>
<initial> --> <letter> | <special initial>
<letter> --> a | b | c | ... | z
    | A | B | C | ... | Z
<special initial> --> ! | $ | % | & | * | / | : | < | =
     | > | ? | @ | ^ | _ | ~
<subsequent> --> <initial> | <digit>
     | <special subsequent>
<digit> --> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<hex digit> --> <digit> | a | b | c | d | e | f
<explicit sign> --> + | -
<special subsequent> --> <explicit sign> | . | @
<inline hex escape> --> \x<hex scalar value>;
<hex scalar value> --> <hex digit>+
<mnemonic escape> --> \a | \b | \t | \n | \r
<peculiar identifier> --> <explicit sign>
    | <explicit sign> <sign subsequent> <subsequent>*
    | <explicit sign> . <dot subsequent> <subsequent>*
    | . <dot subsequent> <subsequent>*

<dot subsequent> --> <sign subsequent> | .
<sign subsequent> --> <initial> | <explicit sign> | @
<symbol element> -->
    <any character other than <vertical line> or \>
    | <inline hex escape> | <mnemonic escape> | \|

<boolean> --> #t | #f | #true | #false

<character> --> #\ <any character>
     | #\ <character name>
     | #\x<hex scalar value>
<character name> --> alarm | backspace | delete
    | escape | newline | null | return | space | tab

<string> --> " <string element>* "
<string element> --> <any character other than " or \>
    | <mnemonic escape> | \" | \\ | \|
     | \<intraline whitespace>*<line ending>
       <intraline whitespace>*
     | <inline hex escape>
<bytevector> --> #u8(<byte>*)
<byte> --> <any exact integer between 0 and 255>


<number> --> <num 2> | <num 8>
     | <num 10> | <num 16>



The following rules for <num R>, <complex R>, <real R>, <ureal R>,
<uinteger R>, and <prefix R> are implicitly replicated for R = 2, 8, 10,
and 16.  There are no rules for <decimal 2>, <decimal 8>, and <decimal
16>, which means that numbers containing decimal points or exponents are
always in decimal radix.  Although not shown below, all alphabetic
characters used in the grammar of numbers can appear in either upper or
lower case.

<num R> --> <prefix R> <complex R>
<complex R> --> <real R> | <real R> @ <real R>
    | <real R> + <ureal R> i | <real R> - <ureal R> i
    | <real R> + i | <real R> - i | <real R> <infnan> i
    | + <ureal R> i | - <ureal R> i
    | <infnan> i | + i | - i
<real R> --> <sign> <ureal R>
    | <infnan>
<ureal R> --> <uinteger R>
    | <uinteger R> / <uinteger R>
    | <decimal R>
<decimal 10> --> <uinteger 10> <suffix>
    | . <digit 10>+ <suffix>
    | <digit 10>+ . <digit 10>* <suffix>
<uinteger R> --> <digit R>+
<prefix R> --> <radix R> <exactness>
    | <exactness> <radix R>
<infnan> --> +inf.0 | -inf.0 | +nan.0 | -nan.0



<suffix> --> <empty>
    | <exponent marker> <sign> <digit 10>+
<exponent marker> --> e
<sign> --> <empty>  | + |  -
<exactness> --> <empty> | #i | #e
<radix 2> --> #b
<radix 8> --> #o
<radix 10> --> <empty> | #d
<radix 16> --> #x
<digit 2> --> 0 | 1
<digit 8> --> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
<digit 10> --> <digit>
<digit 16> --> <digit 10> | a | b | c | d | e | f



File: r7rs.info,  Node: External representation,  Next: Expression,  Prev: Lexical structure,  Up: Formal syntax

7.1.2 External representations
------------------------------

<Datum> is what the 'read' procedure (section *note Input::)
successfully parses.  Note that any string that parses as an
<expression> will also parse as a <datum>.

<datum> --> <simple datum> | <compound datum>
     | <label> = <datum> | <label> #
<simple datum> --> <boolean> | <number>
     | <character> | <string> |  <symbol> | <bytevector>
<symbol> --> <identifier>
<compound datum> --> <list> | <vector> | <abbreviation>
<list> --> (<datum>*) | (<datum>+ . <datum>)
<abbreviation> --> <abbrev prefix> <datum>
<abbrev prefix> --> ' | ` | , | ,@
<vector> --> #(<datum>*)
<label> --> # <uinteger 10>



File: r7rs.info,  Node: Expression,  Next: Quasiquotations,  Prev: External representation,  Up: Formal syntax

7.1.3 Expressions
-----------------

The definitions in this and the following subsections assume that all
the syntax keywords defined in this report have been properly imported
from their libraries, and that none of them have been redefined or
shadowed.

<expression> --> <identifier>
     | <literal>
     | <procedure call>
     | <lambda expression>
     | <conditional>
     | <assignment>
     | <derived expression>
     | <macro use>
     | <macro block>
     | <includer>

<literal> --> <quotation> | <self-evaluating>
<self-evaluating> --> <boolean> | <number> | <vector>
     | <character> | <string> | <bytevector>
<quotation> --> '<datum> | (quote <datum>)
<procedure call> --> (<operator> <operand>*)
<operator> --> <expression>
<operand> --> <expression>

<lambda expression> --> (lambda <formals> <body>)
<formals> --> (<identifier>*) | <identifier>
     | (<identifier>+ . <identifier>)
<body> -->  <definition>* <sequence>
<sequence> --> <command>* <expression>
<command> --> <expression>

<conditional> --> (if <test> <consequent> <alternate>)
<test> --> <expression>
<consequent> --> <expression>
<alternate> --> <expression> | <empty>

<assignment> --> (set! <identifier> <expression>)

<derived expression> -->
       (cond <cond clause>+)
     | (cond <cond clause>* (else <sequence>))
     | (case <expression>
         <case clause>+)
     | (case <expression>
         <case clause>*
         (else <sequence>))
     | (case <expression>
         <case clause>*
         (else => <recipient>))
     | (and <test>*)
     | (or <test>*)
     | (when <test> <sequence>)
     | (unless <test> <sequence>)
     | (let (<binding spec>*) <body>)
     | (let <identifier> (<binding spec>*) <body>)
     | (let* (<binding spec>*) <body>)
     | (letrec (<binding spec>*) <body>)
     | (letrec* (<binding spec>*) <body>)
     | (let-values (<mv binding spec>*) <body>)
     | (let*-values (<mv binding spec>*) <body>)
     | (begin <sequence>)
     | (do (<iteration spec>*)
           (<test> <do result>)
         <command>*)
     | (delay <expression>)
     | (delay-force <expression>)
     | (parameterize ((<expression> <expression>)*)
          <body>)
     | (guard (<identifier> <cond clause>*) <body>)
     | <quasiquotation>
     | (case-lambda <case-lambda clause>*)

<cond clause> --> (<test> <sequence>)
      | (<test>)
      | (<test> => <recipient>)
<recipient> --> <expression>
<case clause> --> ((<datum>*) <sequence>)
      | ((<datum>*) => <recipient>)
<binding spec> --> (<identifier> <expression>)
<mv binding spec> --> (<formals> <expression>)
<iteration spec> --> (<identifier> <init> <step>)
    | (<identifier> <init>)
<case-lambda clause> --> (<formals> <body>)
<init> --> <expression>
<step> --> <expression>
<do result> --> <sequence> | <empty>

<macro use> --> (<keyword> <datum>*)
<keyword> --> <identifier>

<macro block> -->
     (let-syntax (<syntax spec>*) <body>)
     | (letrec-syntax (<syntax spec>*) <body>)
<syntax spec> --> (<keyword> <transformer spec>)

<includer> -->
    | (include <string>+)
    | (include-ci <string>+)




File: r7rs.info,  Node: Quasiquotations,  Next: Transformers,  Prev: Expression,  Up: Formal syntax

7.1.4 Quasiquotations
---------------------

The following grammar for quasiquote expressions is not context-free.
It is presented as a recipe for generating an infinite number of
production rules.  Imagine a copy of the following rules for D = 1, 2,3,
..., where D is the nesting depth.

<quasiquotation> --> <quasiquotation 1>
<qq template 0> --> <expression>
<quasiquotation D> --> `<qq template D>
       | (quasiquote <qq template D>)
<qq template D> --> <simple datum>
       | <list qq template D>
       | <vector qq template D>
       | <unquotation D>
<list qq template D> --> (<qq template or splice D>*)
       | (<qq template or splice D>+ . <qq template D>)
       | '<qq template D>
       | <quasiquotation D+1>
<vector qq template D> --> #(<qq template or splice D>*)
<unquotation D> --> ,<qq template D-1>
       | (unquote <qq template D-1>)
<qq template or splice D> --> <qq template D>
       | <splicing unquotation D>
<splicing unquotation D> --> ,@<qq template D-1>
       | (unquote-splicing <qq template D-1>)


In <quasiquotation>s, a <list qq template D> can sometimes be confused
with either an <unquotation D> or a <splicing unquotation D>.  The
interpretation as an <unquotation> or <splicing unquotation D> takes
precedence.


File: r7rs.info,  Node: Transformers,  Next: Programs and definitions,  Prev: Quasiquotations,  Up: Formal syntax

7.1.5 Transformers
------------------

     _Note:_ Though this grammar does not say so, a top-level
     syntax-rules pattern must be a list pattern, not a vector pattern
     or an identifier pattern.

<transformer spec> -->
    (syntax-rules (<identifier>*) <syntax rule>*)
    | (syntax-rules <identifier> (<identifier>*)
         <syntax rule>*)
<syntax rule> --> (<pattern> <template>)
<pattern> --> <pattern identifier>
     | <underscore>
     | (<pattern>*)
     | (<pattern>+ . <pattern>)
     | (<pattern>* <pattern> <ellipsis> <pattern>*)
     | (<pattern>* <pattern> <ellipsis> <pattern>*
         . <pattern>)
     | #(<pattern>*)
     | #(<pattern>* <pattern> <ellipsis> <pattern>*)
     | <pattern datum>
<pattern datum> --> <string>
     | <character>
     | <boolean>
     | <number>
     | <bytevector>
<template> --> <pattern identifier>
     | (<template element>*)
     | (<template element>+ . <template>)
     | #(<template element>*)
     | <template datum>
<template element> --> <template>
     | <template> <ellipsis>
<template datum> --> <pattern datum>
<pattern identifier> --> <any identifier except '...'>
<ellipsis> --> <an identifier defaulting to '...'>
<underscore> --> <the identifier ' '>




File: r7rs.info,  Node: Programs and definitions,  Next: Librarie,  Prev: Transformers,  Up: Formal syntax

7.1.6 Programs and definitions
------------------------------

<program> -->
    <import declaration>+
    <command or definition>+
<command or definition> --> <command>
    | <definition>
    | (begin <command or definition>+)
<definition> --> (define <identifier> <expression>)
      | (define (<identifier> <def formals>) <body>)
      | <syntax definition>
      | (define-values <formals> <body>)
      | (define-record-type <identifier>
         <constructor> <identifier> <field spec>*)
      | (begin <definition>*)
<def formals> --> <identifier>*
      | <identifier>* . <identifier>
<constructor> --> (<identifier> <field name>*)
<field spec> --> (<field name> <accessor>)
      | (<field name> <accessor> <mutator>)
<field name> --> <identifier>
<accessor> --> <identifier>
<mutator> --> <identifier>
<syntax definition> -->
     (define-syntax <keyword> <transformer spec>)




File: r7rs.info,  Node: Librarie,  Prev: Programs and definitions,  Up: Formal syntax

7.1.7 Libraries
---------------

<library> -->
    (define-library <library name>
       <library declaration>*)
<library name> --> (<library name part>+)
<library name part> --> <identifier> | <uinteger 10>
<library declaration> --> (export <export spec>*)
    | <import declaration>
    | (begin <command or definition>*)
    | <includer>
    | (include-library-declarations <string>+)
    | (cond-expand <cond-expand clause>+)
    | (cond-expand <cond-expand clause>+
                (else <library declaration>*))
<import declaration> --> (import <import set>+)
<export spec> --> <identifier>
    | (rename <identifier> <identifier>)
<import set> --> <library name>
    | (only <import set> <identifier>+)
    | (except <import set> <identifier>+)
    | (prefix <import set> <identifier>)
    | (rename <import set> (<identifier> <identifier>)+)
<cond-expand clause> -->
    (<feature requirement> <library declaration>*)
<feature requirement> --> <identifier>
    | (library <library name>)
    | (and <feature requirement>*)
    | (or <feature requirement>*)
    | (not <feature requirement>)




File: r7rs.info,  Node: Formal semantics,  Next: Derived expression type,  Prev: Formal syntax,  Up: Formal syntax and semantics

7.2 Formal semantics
====================

This section provides a formal denotational semantics for the primitive
expressions of Scheme and selected built-in procedures.  The concepts
and notation used here are described in [STOY77].

     _Note:_ The formal semantics section was written in LaTeX which is
     incompatible with TeXinfo.  See the Formal semantics section:
     <http://swissnet.ai.mit.edu/~jaffer/r7rs-formal.pdf>


File: r7rs.info,  Node: Derived expression type,  Prev: Formal semantics,  Up: Formal syntax and semantics

7.3 Derived expression types
============================

This section gives syntax definitions for the derived expression types
in terms of the primitive expression types (literal, variable, call,
'lambda', 'if', and 'set!'), except for 'quasiquote'.

Conditional derived syntax types:


     (define-syntax cond
       (syntax-rules (else =>)
         ((cond (else result1 result2 ...))
          (begin result1 result2 ...))
         ((cond (test => result))
          (let ((temp test))
            (if temp (result temp))))
         ((cond (test => result) clause1 clause2 ...)
          (let ((temp test))
            (if temp
                (result temp)
                (cond clause1 clause2 ...))))
         ((cond (test)) test)
         ((cond (test) clause1 clause2 ...)
          (let ((temp test))
            (if temp
                temp
                (cond clause1 clause2 ...))))
         ((cond (test result1 result2 ...))
          (if test (begin result1 result2 ...)))
         ((cond (test result1 result2 ...)
                clause1 clause2 ...)
          (if test
              (begin result1 result2 ...)
              (cond clause1 clause2 ...)))))



     (define-syntax case
       (syntax-rules (else =>)
         ((case (key ...)
            clauses ...)
          (let ((atom-key (key ...)))
            (case atom-key clauses ...)))
         ((case key
            (else => result))
          (result key))
         ((case key
            (else result1 result2 ...))
          (begin result1 result2 ...))
         ((case key
            ((atoms ...) => result))
          (if (memv key '(atoms ...))
              (result key)))
         ((case key
            ((atoms ...) result1 result2 ...))
          (if (memv key '(atoms ...))
              (begin result1 result2 ...)))
         ((case key
            ((atoms ...) => result)
            clause clauses ...)
          (if (memv key '(atoms ...))
              (result key)
              (case key clause clauses ...)))
         ((case key
            ((atoms ...) result1 result2 ...)
            clause clauses ...)
          (if (memv key '(atoms ...))
              (begin result1 result2 ...)
              (case key clause clauses ...)))))



     (define-syntax and
       (syntax-rules ()
         ((and) #t)
         ((and test) test)
         ((and test1 test2 ...)
          (if test1 (and test2 ...) #f))))



     (define-syntax or
       (syntax-rules ()
         ((or) #f)
         ((or test) test)
         ((or test1 test2 ...)
          (let ((x test1))
            (if x x (or test2 ...))))))



     (define-syntax when
       (syntax-rules ()
         ((when test result1 result2 ...)
          (if test
              (begin result1 result2 ...)))))



     (define-syntax unless
       (syntax-rules ()
         ((unless test result1 result2 ...)
          (if (not test)
              (begin result1 result2 ...)))))


Binding constructs:


     (define-syntax let
       (syntax-rules ()
         ((let ((name val) ...) body1 body2 ...)
          ((lambda (name ...) body1 body2 ...)
           val ...))
         ((let tag ((name val) ...) body1 body2 ...)
          ((letrec ((tag (lambda (name ...)
                           body1 body2 ...)))
             tag)
           val ...))))



     (define-syntax let*
       (syntax-rules ()
         ((let* () body1 body2 ...)
          (let () body1 body2 ...))
         ((let* ((name1 val1) (name2 val2) ...)
            body1 body2 ...)
          (let ((name1 val1))
            (let* ((name2 val2) ...)
              body1 body2 ...)))))


The following 'letrec' macro uses the symbol '<undefined>' in place of
an expression which returns something that when stored in a location
makes it an error to try to obtain the value stored in the location.
(No such expression is defined in Scheme.)  A trick is used to generate
the temporary names needed to avoid specifying the order in which the
values are evaluated.  This could also be accomplished by using an
auxiliary macro.


     (define-syntax letrec
       (syntax-rules ()
         ((letrec ((var1 init1) ...) body ...)
          (letrec "generate temp names"
            (var1 ...)
            ()
            ((var1 init1) ...)
            body ...))
         ((letrec "generate temp names"
            ()
            (temp1 ...)
            ((var1 init1) ...)
            body ...)
          (let ((var1 <undefined>) ...)
            (let ((temp1 init1) ...)
              (set! var1 temp1)
              ...
              body ...)))
         ((letrec "generate temp names"
            (x y ...)
            (temp ...)
            ((var1 init1) ...)
            body ...)
          (letrec "generate temp names"
            (y ...)
            (newtemp temp ...)
            ((var1 init1) ...)
            body ...))))



     (define-syntax letrec*
       (syntax-rules ()
         ((letrec* ((var1 init1) ...) body1 body2 ...)
          (let ((var1 <undefined>) ...)
            (set! var1 init1)
            ...
            (let () body1 body2 ...)))))



     (define-syntax let-values
       (syntax-rules ()
         ((let-values (binding ...) body0 body1 ...)
          (let-values "bind"
              (binding ...) () (begin body0 body1 ...)))

         ((let-values "bind" () tmps body)
          (let tmps body))

         ((let-values "bind" ((b0 e0)
              binding ...) tmps body)
          (let-values "mktmp" b0 e0 ()
              (binding ...) tmps body))

         ((let-values "mktmp" () e0 args
              bindings tmps body)
          (call-with-values
            (lambda () e0)
            (lambda args
              (let-values "bind"
                  bindings tmps body))))

         ((let-values "mktmp" (a . b) e0 (arg ...)
              bindings (tmp ...) body)
          (let-values "mktmp" b e0 (arg ... x)
              bindings (tmp ... (a x)) body))

         ((let-values "mktmp" a e0 (arg ...)
             bindings (tmp ...) body)
          (call-with-values
            (lambda () e0)
            (lambda (arg ... . x)
              (let-values "bind"
                  bindings (tmp ... (a x)) body))))))



     (define-syntax let*-values
       (syntax-rules ()
         ((let*-values () body0 body1 ...)
          (let () body0 body1 ...))

         ((let*-values (binding0 binding1 ...)
              body0 body1 ...)
          (let-values (binding0)
            (let*-values (binding1 ...)
              body0 body1 ...)))))



     (define-syntax define-values
       (syntax-rules ()
         ((define-values () expr)
          (define dummy
            (call-with-values (lambda () expr)
                              (lambda args #f))))
         ((define-values (var) expr)
          (define var expr))
         ((define-values (var0 var1 ... varn) expr)
          (begin
            (define var0
              (call-with-values (lambda () expr)
                                list))
            (define var1
              (let ((v (cadr var0)))
                (set-cdr! var0 (cddr var0))
                v)) ...
            (define varn
              (let ((v (cadr var0)))
                (set! var0 (car var0))
                v))))
         ((define-values (var0 var1 ... . varn) expr)
          (begin
            (define var0
              (call-with-values (lambda () expr)
                                list))
            (define var1
              (let ((v (cadr var0)))
                (set-cdr! var0 (cddr var0))
                v)) ...
            (define varn
              (let ((v (cdr var0)))
                (set! var0 (car var0))
                v))))
         ((define-values var expr)
          (define var
            (call-with-values (lambda () expr)
                              list)))))



     (define-syntax begin
       (syntax-rules ()
         ((begin exp ...)
          ((lambda () exp ...)))))


The following alternative expansion for 'begin' does not make use of the
ability to write more than one expression in the body of a lambda
expression.  In any case, note that these rules apply only if the body
of the 'begin' contains no definitions.


     (define-syntax begin
       (syntax-rules ()
         ((begin exp)
          exp)
         ((begin exp1 exp2 ...)
          (call-with-values
              (lambda () exp1)
            (lambda args
              (begin exp2 ...))))))


The following syntax definition of 'do' uses a trick to expand the
variable clauses.  As with 'letrec' above, an auxiliary macro would also
work.  The expression '(if #f #f)' is used to obtain an unspecific
value.


     (define-syntax do
       (syntax-rules ()
         ((do ((var init step ...) ...)
              (test expr ...)
              command ...)
          (letrec
            ((loop
              (lambda (var ...)
                (if test
                    (begin
                      (if #f #f)
                      expr ...)
                    (begin
                      command
                      ...
                      (loop (do "step" var step ...)
                            ...))))))
            (loop init ...)))
         ((do "step" x)
          x)
         ((do "step" x y)
          y)))


Here is a possible implementation of 'delay', 'force' and 'delay-force'.
We define the expression


     (delay-force <expression>)


to have the same meaning as the procedure call


     (make-promise #f (lambda () <expression>))


as follows


     (define-syntax delay-force
       (syntax-rules ()
         ((delay-force expression)
          (make-promise #f (lambda () expression)))))


and we define the expression


     (delay <expression>)


to have the same meaning as:


     (delay-force (make-promise #t <expression>))


as follows


     (define-syntax delay
       (syntax-rules ()
         ((delay expression)
          (delay-force (make-promise #t expression)))))


where 'make-promise' is defined as follows:


     (define make-promise
       (lambda (done? proc)
         (list (cons done? proc))))


Finally, we define 'force' to call the procedure expressions in promises
iteratively using a trampoline technique following [srfi45] until a
non-lazy result (i.e.  a value created by 'delay' instead of
'delay-force') is returned, as follows:


     (define (force promise)
       (if (promise-done? promise)
           (promise-value promise)
           (let ((promise* ((promise-value promise))))
             (unless (promise-done? promise)
               (promise-update! promise* promise))
             (force promise))))


with the following promise accessors:


     (define promise-done?
       (lambda (x) (car (car x))))
     (define promise-value
       (lambda (x) (cdr (car x))))
     (define promise-update!
       (lambda (new old)
         (set-car! (car old) (promise-done? new))
         (set-cdr! (car old) (promise-value new))
         (set-car! new (car old))))


The following implementation of 'make-parameter' and 'parameterize' is
suitable for an implementation with no threads.  Parameter objects are
implemented here as procedures, using two arbitrary unique objects
<param-set!> and <param-convert>:


     (define (make-parameter init . o)
       (let* ((converter
               (if (pair? o) (car o) (lambda (x) x)))
              (value (converter init)))
         (lambda args
           (cond
            ((null? args)
             value)
            ((eq? (car args) <param-set!>)
             (set! value (cadr args)))
            ((eq? (car args) <param-convert>)
             converter)
            (else
             (error "bad parameter syntax"))))))


Then 'parameterize' uses 'dynamic-wind' to dynamically rebind the
associated value:


     (define-syntax parameterize
       (syntax-rules ()
         ((parameterize ("step")
                        ((param value p old new) ...)
                        ()
                        body)
          (let ((p param) ...)
            (let ((old (p)) ...
                  (new ((p <param-convert>) value)) ...)
              (dynamic-wind
               (lambda () (p <param-set!> new) ...)
               (lambda () . body)
               (lambda () (p <param-set!> old) ...)))))
         ((parameterize ("step")
                        args
                        ((param value) . rest)
                        body)
          (parameterize ("step")
                        ((param value p old new) . args)
                        rest
                        body))
         ((parameterize ((param value) ...) . body)
          (parameterize ("step")
                        ()
                        ((param value) ...)
                        body))))


The following implementation of 'guard' depends on an auxiliary macro,
here called 'guard-aux'.


     (define-syntax guard
       (syntax-rules ()
         ((guard (var clause ...) e1 e2 ...)
          ((call/cc
            (lambda (guard-k)
              (with-exception-handler
               (lambda (condition)
                 ((call/cc
                    (lambda (handler-k)
                      (guard-k
                       (lambda ()
                         (let ((var condition))
                           (guard-aux
                             (handler-k
                               (lambda ()
                                 (raise-continuable condition)))
                             clause ...))))))))
               (lambda ()
                 (call-with-values
                  (lambda () e1 e2 ...)
                  (lambda args
                    (guard-k
                      (lambda ()
                        (apply values args)))))))))))))

     (define-syntax guard-aux
       (syntax-rules (else =>)
         ((guard-aux reraise (else result1 result2 ...))
          (begin result1 result2 ...))
         ((guard-aux reraise (test => result))
          (let ((temp test))
            (if temp
                (result temp)
                reraise)))
         ((guard-aux reraise (test => result)
                     clause1 clause2 ...)
          (let ((temp test))
            (if temp
                (result temp)
                (guard-aux reraise clause1 clause2 ...))))
         ((guard-aux reraise (test))
          (or test reraise))
         ((guard-aux reraise (test) clause1 clause2 ...)
          (let ((temp test))
            (if temp
                temp
                (guard-aux reraise clause1 clause2 ...))))
         ((guard-aux reraise (test result1 result2 ...))
          (if test
              (begin result1 result2 ...)
              reraise))
         ((guard-aux reraise
                     (test result1 result2 ...)
                     clause1 clause2 ...)
          (if test
              (begin result1 result2 ...)
              (guard-aux reraise clause1 clause2 ...)))))



     (define-syntax case-lambda
       (syntax-rules ()
         ((case-lambda (params body0 ...) ...)
          (lambda args
            (let ((len (length args)))
              (letrec-syntax
                  ((cl (syntax-rules ::: ()
                         ((cl)
                          (error "no matching clause"))
                         ((cl ((p :::) . body) . rest)
                          (if (= len (length '(p :::)))
                              (apply (lambda (p :::)
                                       . body)
                                     args)
                              (cl . rest)))
                         ((cl ((p ::: . tail) . body)
                              . rest)
                          (if (>= len (length '(p :::)))
                              (apply
                               (lambda (p ::: . tail)
                                 . body)
                               args)
                              (cl . rest))))))
                (cl (params body0 ...) ...)))))))



This definition of 'cond-expand' does not interact with the 'features'
procedure.  It requires that each feature identifier provided by the
implementation be explicitly mentioned.


     (define-syntax cond-expand
       ;; Extend this to mention all feature ids and libraries
       (syntax-rules (and or not else r7rs library scheme base)
         ((cond-expand)
          (syntax-error "Unfulfilled cond-expand"))
         ((cond-expand (else body ...))
          (begin body ...))
         ((cond-expand ((and) body ...) more-clauses ...)
          (begin body ...))
         ((cond-expand ((and req1 req2 ...) body ...)
                       more-clauses ...)
          (cond-expand
            (req1
              (cond-expand
                ((and req2 ...) body ...)
                more-clauses ...))
            more-clauses ...))
         ((cond-expand ((or) body ...) more-clauses ...)
          (cond-expand more-clauses ...))
         ((cond-expand ((or req1 req2 ...) body ...)
                       more-clauses ...)
          (cond-expand
            (req1
             (begin body ...))
            (else
             (cond-expand
                ((or req2 ...) body ...)
                more-clauses ...))))
         ((cond-expand ((not req) body ...)
                       more-clauses ...)
          (cond-expand
            (req
              (cond-expand more-clauses ...))
            (else body ...)))
         ((cond-expand (r7rs body ...)
                       more-clauses ...)
            (begin body ...))
         ;; Add clauses here for each
         ;; supported feature identifier.
         ;; Samples:
         ;; ((cond-expand (exact-closed body ...)
         ;;               more-clauses ...)
         ;;   (begin body ...))
         ;; ((cond-expand (ieee-float body ...)
         ;;               more-clauses ...)
         ;;   (begin body ...))
         ((cond-expand ((library (scheme base))
                        body ...)
                       more-clauses ...)
           (begin body ...))
         ;; Add clauses here for each library
         ((cond-expand (feature-id body ...)
                       more-clauses ...)
            (cond-expand more-clauses ...))
         ((cond-expand ((library (name ...))
                        body ...)
                       more-clauses ...)
            (cond-expand more-clauses ...))))




File: r7rs.info,  Node: Standard Libraries,  Next: Standard Feature Identifiers,  Prev: Formal syntax and semantics,  Up: Top

B Standard Libraries
********************

This section lists the exports provided by the standard libraries.  The
libraries are factored so as to separate features which might not be
supported by all implementations, or which might be expensive to load.

The 'scheme' library prefix is used for all standard libraries, and is
reserved for use by future standards.

Base Library

The (scheme base) library exports many of the procedures and syntax
bindings that are traditionally associated with Scheme.  The division
between the base library and the other standard libraries is based on
use, not on construction.  In particular, some facilities that are
typically implemented as primitives by a compiler or the run-time system
rather than in terms of other standard procedures or syntax are not part
of the base library, but are defined in separate libraries.  By the same
token, some exports of the base library are implementable in terms of
other exports.  They are redundant in the strict sense of the word, but
they capture common patterns of usage, and are therefore provided as
convenient abbreviations.


     '*'                       '+'
     '-'                       '...'
     '/'                       '<'
     '<='                      '='
     '=>'                      '>'
     '>='                      ' '
     'abs'                     'and'
     'append'                  'apply'
     'assoc'                   'assq'
     'assv'                    'begin'
     'binary-port? '           'boolean=?'
     'boolean? '               'bytevector'
     'bytevector-append'       'bytevector-copy'
     'bytevector-copy!'        'bytevector-length'
     'bytevector-u8-ref'       'bytevector-u8-set!'
     'bytevector? '            'caar'
     'cadr'
     'call-with-current-continuation'
     'call-with-port'          'call-with-values'
     'call/cc'                 'car'
     'case'                    'cdar'
     'cddr'                    'cdr'
     'ceiling'                 'char->integer'
     'char-ready? '            'char<=?'
     'char<? '                 'char=?'
     'char>=? '                'char>?'
     'char? '                  'close-input-port'
     'close-output-port'       'close-port'
     'complex? '               'cond'
     'cond-expand'             'cons'
     'current-error-port'      'current-input-port'
     'current-output-port'     'define'
     'define-record-type'      'define-syntax'
     'define-values'           'denominator'
     'do'                      'dynamic-wind'
     'else'                    'eof-object'
     'eof-object? '            'eq?'
     'equal? '                 'eqv?'
     'error'                   'error-object-irritants'
     'error-object-message'    'error-object?'
     'even? '                  'exact'
     'exact-integer-sqrt'      'exact-integer?'
     'exact? '                 'expt'
     'features'                'file-error?'
     'floor'                   'floor-quotient'
     'floor-remainder'         'floor/'
     'flush-output-port'       'for-each'
     'gcd'                     'get-output-bytevector'
     'get-output-string'       'guard'
     'if'                      'include'
     'include-ci'              'inexact'
     'inexact? '               'input-port-open?'
     'input-port? '            'integer->char'
     'integer? '               'lambda'
     'lcm'                     'length'
     'let'                     'let*'
     'let*-values'             'let-syntax'
     'let-values'              'letrec'
     'letrec*'                 'letrec-syntax'
     'list'                    'list->string'
     'list->vector'            'list-copy'
     'list-ref'                'list-set!'
     'list-tail'               'list?'
     'make-bytevector'         'make-list'
     'make-parameter'          'make-string'
     'make-vector'             'map'
     'max'                     'member'
     'memq'                    'memv'
     'min'                     'modulo'
     'negative? '              'newline'
     'not'                     'null?'
     'number->string'          'number?'
     'numerator'               'odd?'
     'open-input-bytevector'   'open-input-string'
     'open-output-bytevector'  'open-output-string'
     'or'                      'output-port-open?'
     'output-port? '           'pair?'
     'parameterize'            'peek-char'
     'peek-u8'                 'port?'
     'positive? '              'procedure?'
     'quasiquote'              'quote'
     'quotient'                'raise'
     'raise-continuable'       'rational?'
     'rationalize'             'read-bytevector'
     'read-bytevector!'        'read-char'
     'read-error? '            'read-line'
     'read-string'             'read-u8'
     'real? '                  'remainder'
     'reverse'                 'round'
     'set!'                    'set-car!'
     'set-cdr!'                'square'
     'string'                  'string->list'
     'string->number'          'string->symbol'
     'string->utf8'            'string->vector'
     'string-append'           'string-copy'
     'string-copy!'            'string-fill!'
     'string-for-each'         'string-length'
     'string-map'              'string-ref'
     'string-set!'             'string<=?'
     'string<? '               'string=?'
     'string>=? '              'string>?'
     'string? '                'substring'
     'symbol->string'          'symbol=?'
     'symbol? '                'syntax-error'
     'syntax-rules'            'textual-port?'
     'truncate'                'truncate-quotient'
     'truncate-remainder'      'truncate/'
     'u8-ready? '              'unless'
     'unquote'                 'unquote-splicing'
     'utf8->string'            'values'
     'vector'                  'vector->list'
     'vector->string'          'vector-append'
     'vector-copy'             'vector-copy!'
     'vector-fill!'            'vector-for-each'
     'vector-length'           'vector-map'
     'vector-ref'              'vector-set!'
     'vector? '                'when'
     'with-exception-handler'  'write-bytevector'
     'write-char'              'write-string'
     'write-u8'                'zero?'


Case-Lambda Library

The (scheme case-lambda) library exports the 'case-lambda' syntax.


     'case-lambda'


Char Library

The (scheme char) library provides the procedures for dealing with
characters that involve potentially large tables when supporting all of
Unicode.


     'char-alphabetic? '       'char-ci<=?'
     'char-ci<? '              'char-ci=?'
     'char-ci>=? '             'char-ci>?'
     'char-downcase'           'char-foldcase'
     'char-lower-case? '       'char-numeric?'
     'char-upcase'             'char-upper-case?'
     'char-whitespace? '       'digit-value'
     'string-ci<=? '           'string-ci<?'
     'string-ci=? '            'string-ci>=?'
     'string-ci>? '            'string-downcase'
     'string-foldcase'         'string-upcase'


Complex Library

The (scheme complex) library exports procedures which are typically only
useful with non-real numbers.


     'angle'                   'imag-part'
     'magnitude'               'make-polar'
     'make-rectangular'        'real-part'


CxR Library

The (scheme cxr) library exports twenty-four procedures which are the
compositions of from three to four 'car' and 'cdr' operations.  For
example 'caddar' could be defined by


     (define caddar
       (lambda (x) (car (cdr (cdr (car x)))))).


The procedures 'car' and 'cdr' themselves and the four two-level
compositions are included in the base library.  See section *note Pairs
and lists::.


     'caaaar'                  'caaadr'
     'caaar'                   'caadar'
     'caaddr'                  'caadr'
     'cadaar'                  'cadadr'
     'cadar'                   'caddar'
     'cadddr'                  'caddr'
     'cdaaar'                  'cdaadr'
     'cdaar'                   'cdadar'
     'cdaddr'                  'cdadr'
     'cddaar'                  'cddadr'
     'cddar'                   'cdddar'
     'cddddr'                  'cdddr'


Eval Library

The (scheme eval) library exports procedures for evaluating Scheme data
as programs.


     'environment'             'eval'


File Library

The (scheme file) library provides procedures for accessing files.


     'call-with-input-file'    'call-with-output-file'
     'delete-file'             'file-exists?'
     'open-binary-input-file'  'open-binary-output-file'
     'open-input-file'         'open-output-file'
     'with-input-from-file'    'with-output-to-file'


Inexact Library

The (scheme inexact) library exports procedures which are typically only
useful with inexact values.


     'acos'                    'asin'
     'atan'                    'cos'
     'exp'                     'finite?'
     'infinite? '              'log'
     'nan? '                   'sin'
     'sqrt'                    'tan'


Lazy Library

The (scheme lazy) library exports procedures and syntax keywords for
lazy evaluation.


     'delay'                   'delay-force'
     'force'                   'make-promise'
     'promise?'


Load Library

The (scheme load) library exports procedures for loading Scheme
expressions from files.


     'load'


Process-Context Library

The (scheme process-context) library exports procedures for accessing
with the program's calling context.


     'command-line'            'emergency-exit'
     'exit'
     'get-environment-variable'
     'get-environment-variables'


Read Library

The (scheme read) library provides procedures for reading Scheme
objects.


     'read'


Repl Library

The (scheme repl) library exports the 'interaction-environment'
procedure.


     'interaction-environment'


Time Library

The (scheme time) library provides access to time-related values.


     'current-jiffy'           'current-second'
     'jiffies-per-second'


Write Library

The (scheme write) library provides procedures for writing Scheme
objects.


     'display'                 'write'
     'write-shared'            'write-simple'


R5RS Library

The (scheme r5rs) library provides the identifiers defined by R^{5}RS,
except that 'transcript-on' and 'transcript-off' are not present.  Note
that the 'exact' and 'inexact' procedures appear under their R^{5}RS
names 'inexact->exact' and 'exact->inexact' respectively.  However, if
an implementation does not provide a particular library such as the
complex library, the corresponding identifiers will not appear in this
library either.


     '*'                       '+'
     '-'                       '...'
     '/'                       '<'
     '<='                      '='
     '=>'                      '>'
     '>='                      ' '
     'abs'                     'acos'
     'and'                     'angle'
     'append'                  'apply'
     'asin'                    'assoc'
     'assq'                    'assv'
     'atan'                    'begin'
     'boolean? '               'caaaar'
     'caaadr'                  'caaar'
     'caadar'                  'caaddr'
     'caadr'                   'caar'
     'cadaar'                  'cadadr'
     'cadar'                   'caddar'
     'cadddr'                  'caddr'
     'cadr'
     'call-with-current-continuation'
     'call-with-input-file'    'call-with-output-file'
     'call-with-values'        'car'
     'case'                    'cdaaar'
     'cdaadr'                  'cdaar'
     'cdadar'                  'cdaddr'
     'cdadr'                   'cdar'
     'cddaar'                  'cddadr'
     'cddar'                   'cdddar'
     'cddddr'                  'cdddr'
     'cddr'                    'cdr'
     'ceiling'                 'char->integer'
     'char-alphabetic? '       'char-ci<=?'
     'char-ci<? '              'char-ci=?'
     'char-ci>=? '             'char-ci>?'
     'char-downcase'           'char-lower-case?'
     'char-numeric? '          'char-ready?'
     'char-upcase'             'char-upper-case?'
     'char-whitespace? '       'char<=?'
     'char<? '                 'char=?'
     'char>=? '                'char>?'
     'char? '                  'close-input-port'
     'close-output-port'       'complex?'
     'cond'                    'cons'
     'cos'                     'current-input-port'
     'current-output-port'     'define'
     'define-syntax'           'delay'
     'denominator'             'display'
     'do'                      'dynamic-wind'
     'else'                    'eof-object?'
     'eq? '                    'equal?'
     'eqv? '                   'eval'
     'even? '                  'exact->inexact'
     'exact? '                 'exp'
     'expt'                    'floor'
     'for-each'                'force'
     'gcd'                     'if'
     'imag-part'               'inexact->exact'
     'inexact? '               'input-port?'
     'integer->char'           'integer?'
     'interaction-environment' 'lambda'
     'lcm'                     'length'
     'let'                     'let*'
     'let-syntax'              'letrec'
     'letrec-syntax'           'list'
     'list->string'            'list->vector'
     'list-ref'                'list-tail'
     'list? '                  'load'
     'log'                     'magnitude'
     'make-polar'              'make-rectangular'
     'make-string'             'make-vector'
     'map'                     'max'
     'member'                  'memq'
     'memv'                    'min'
     'modulo'                  'negative?'
     'newline'                 'not'
     'null-environment'        'null?'
     'number->string'          'number?'
     'numerator'               'odd?'
     'open-input-file'         'open-output-file'
     'or'                      'output-port?'
     'pair? '                  'peek-char'
     'positive? '              'procedure?'
     'quasiquote'              'quote'
     'quotient'                'rational?'
     'rationalize'             'read'
     'read-char'               'real-part'
     'real? '                  'remainder'
     'reverse'                 'round'
     'scheme-report-environment'
     'set!'                    'set-car!'
     'set-cdr!'                'sin'
     'sqrt'                    'string'
     'string->list'            'string->number'
     'string->symbol'          'string-append'
     'string-ci<=? '           'string-ci<?'
     'string-ci=? '            'string-ci>=?'
     'string-ci>? '            'string-copy'
     'string-fill!'            'string-length'
     'string-ref'              'string-set!'
     'string<=? '              'string<?'
     'string=? '               'string>=?'
     'string>? '               'string?'
     'substring'               'symbol->string'
     'symbol? '                'syntax-rules'
     'tan'                     'truncate'
     'values'                  'vector'
     'vector->list'            'vector-fill!'
     'vector-length'           'vector-ref'
     'vector-set!'             'vector?'
     'with-input-from-file'    'with-output-to-file'
     'write'                   'write-char'
     'zero?'



File: r7rs.info,  Node: Standard Feature Identifiers,  Next: Language changes,  Prev: Standard Libraries,  Up: Top

C Standard Feature Identifiers
******************************

An implementation may provide any or all of the feature identifiers
listed below for use by 'cond-expand' and 'features', but must not
provide a feature identifier if it does not provide the corresponding
feature.

r7rs
     All R^{7}RS Scheme implementations have this feature.

exact-closed
     The algebraic operations '+', '-', '*', and 'expt' where the second
     argument is a non-negative integer produce exact values given exact
     inputs.

exact-complex
     Exact complex numbers are provided.

ieee-float
     Inexact numbers are IEEE 754 binary floating point values.

full-unicode
     All Unicode characters present in Unicode version 6.0 are supported
     as Scheme characters.

ratios
     '/' with exact arguments produces an exact result when the divisor
     is nonzero.

posix
     This implementation is running on a POSIX system.

windows
     This implementation is running on Windows.

unix, darwin, gnu-linux, bsd, freebsd, solaris, ...
     Operating system flags (perhaps more than one).

i386, x86-64, ppc, sparc, jvm, clr, llvm, ...
     CPU architecture flags.

ilp32, lp64, ilp64, ...
     C memory model flags.

big-endian, little-endian
     Byte order flags.

<name>
     The name of this implementation.

<name-version>
     The name and version of this implementation.


File: r7rs.info,  Node: Language changes,  Next: Additional material,  Prev: Standard Feature Identifiers,  Up: Top

Language changes
****************

* Menu:

* Incompatibilities with R^{5}RS::
* Other language changes since R^{5}RS::
* Incompatibilities with R^{6}RS::


File: r7rs.info,  Node: Incompatibilities with R^{5}RS,  Next: Other language changes since R^{5}RS,  Prev: Language changes,  Up: Language changes

Incompatibilities with R^{5}RS
==============================

This section enumerates the incompatibilities between this report and
the "Revised^5 report" [R5RS].

_This list is not authoritative, but is believed to be correct and
complete._

   * Case sensitivity is now the default in symbols and character names.
     This means that code written under the assumption that symbols
     could be written 'FOO' or 'Foo' in some contexts and 'foo' in other
     contexts can either be changed, be marked with the new
     '#!fold-case' directive, or be included in a library using the
     'include-ci' library declaration.  All standard identifiers are
     entirely in lower case.

   * The 'syntax-rules' construct now recognizes _ _ (underscore) as a
     wildcard, which means it cannot be used as a syntax variable.  It
     can still be used as a literal.

   * The R^{5}RS procedures 'exact->inexact' and 'inexact->exact' have
     been renamed to their R^{6}RS names, 'inexact' and 'exact',
     respectively, as these names are shorter and more correct.  The
     former names are still available in the R^{5}RS library.

   * The guarantee that string comparison (with 'string<?' and the
     related predicates) is a lexicographical extension of character
     comparison (with 'char<?' and the related predicates) has been
     removed.

   * Support for the # character in numeric literals is no longer
     required.

   * Support for the letters 's', 'f', 'd', and 'l' as exponent markers
     is no longer required.

   * Implementations of 'string->number' are no longer permitted to
     return #f when the argument contains an explicit radix prefix, and
     must be compatible with 'read' and the syntax of numbers in
     programs.

   * The procedures 'transcript-on' and 'transcript-off' have been
     removed.


File: r7rs.info,  Node: Other language changes since R^{5}RS,  Next: Incompatibilities with R^{6}RS,  Prev: Incompatibilities with R^{5}RS,  Up: Language changes

Other language changes since R^{5}RS
====================================

This section enumerates the additional differences between this report
and the "Revised^5 report" [R5RS].

_This list is not authoritative, but is believed to be correct and
complete._

   * Various minor ambiguities and unclarities in R^{5}RS have been
     cleaned up.

   * Libraries have been added as a new program structure to improve
     encapsulation and sharing of code.  Some existing and new
     identifiers have been factored out into separate libraries.
     Libraries can be imported into other libraries or main programs,
     with controlled exposure and renaming of identifiers.  The contents
     of a library can be made conditional on the features of the
     implementation on which it is to be used.  There is an R^{5}RS
     compatibility library.

   * The expressions types 'include', 'include-ci', and 'cond-expand'
     have been added to the base library; they have the same semantics
     as the corresponding library declarations.

   * Exceptions can now be signaled explicitly with 'raise',
     'raise-continuable' or 'error', and can be handled with
     'with-exception-handler' and the 'guard' syntax.  Any object can
     specify an error condition; the implementation-defined conditions
     signaled by 'error' have a predicate to detect them and accessor
     functions to retrieve the arguments passed to 'error'.  Conditions
     signaled by 'read' and by file-related procedures also have
     predicates to detect them.

   * New disjoint types supporting access to multiple fields can be
     generated with the 'define-record-type' of SRFI 9 [srfi9]

   * Parameter objects can be created with 'make-parameter', and
     dynamically rebound with 'parameterize'.  The procedures
     'current-input-port' and 'current-output-port' are now parameter
     objects, as is the newly introduced 'current-error-port'.

   * Support for promises has been enhanced based on SRFI 45 [srfi45].

   * _Bytevectors_, vectors of exact integers in the range from 0 to 255
     inclusive, have been added as a new disjoint type.  A subset of the
     vector procedures is provided.  Bytevectors can be converted to and
     from strings in accordance with the UTF-8 character encoding.
     Bytevectors have a datum representation and evaluate to themselves.

   * Vector constants evaluate to themselves.

   * The procedure 'read-line' is provided to make line-oriented textual
     input simpler.

   * The procedure 'flush-output-port' is provided to allow minimal
     control of output port buffering.

   * _Ports_ can now be designated as _textual_ or _binary_ ports, with
     new procedures for reading and writing binary data.  The new
     predicates 'input-port-open?' and 'output-port-open?' return
     whether a port is open or closed.  The new procedure 'close-port'
     now closes a port; if the port has both input and output sides,
     both are closed.

   * _String ports_ have been added as a way to read and write
     characters to and from strings, and _bytevector ports_ to read and
     write bytes to and from bytevectors.

   * There are now I/O procedures specific to strings and bytevectors.

   * The 'write' procedure now generates datum labels when applied to
     circular objects.  The new procedure 'write-simple' never generates
     labels; 'write-shared' generates labels for all shared and circular
     structure.  The 'display' procedure must not loop on circular
     objects.

   * The R^{6}RS procedure 'eof-object' has been added.  Eof-objects are
     now required to be a disjoint type.

   * Syntax definitions are now allowed wherever variable definitions
     are.

   * The 'syntax-rules' construct now allows the ellipsis symbol to be
     specified explicitly instead of the default '...', allows template
     escapes with an ellipsis-prefixed list, and allows tail patterns to
     follow an ellipsis pattern.

   * The 'syntax-error' syntax has been added as a way to signal
     immediate and more informative errors when a macro is expanded.

   * The 'letrec*' binding construct has been added, and internal
     'define' is specified in terms of it.

   * Support for capturing multiple values has been enhanced with
     'define-values', 'let-values', and 'let*-values'.  Standard
     expression types which contain a sequence of expressions now permit
     passing zero or more than one value to the continuations of all
     non-final expressions of the sequence.

   * The 'case' conditional now supports => syntax analogous to 'cond'
     not only in regular clauses but in the 'else' clause as well.

   * To support dispatching on the number of arguments passed to a
     procedure, 'case-lambda' has been added in its own library.

   * The convenience conditionals 'when' and 'unless' have been added.

   * The behavior of 'eqv?' on inexact numbers now conforms to the
     R^{6}RS definition.

   * When applied to procedures, 'eq?' and 'eqv?' are permitted to
     return different answers.

   * The R^{6}RS procedures 'boolean=?' and 'symbol=?' have been added.

   * Positive infinity, negative infinity, NaN, and negative inexact
     zero have been added to the numeric tower as inexact values with
     the written representations +inf.0, -inf.0, +nan.0, and '-0.0'
     respectively.  Support for them is not required.  The
     representation -nan.0 is synonymous with +nan.0.

   * The 'log' procedure now accepts a second argument specifying the
     logarithm base.

   * The procedures 'map' and 'for-each' are now required to terminate
     on the shortest argument list.

   * The procedures 'member' and 'assoc' now take an optional third
     argument specifying the equality predicate to be used.

   * The numeric procedures 'finite?', 'infinite?', 'nan?',
     'exact-integer?', 'square', and 'exact-integer-sqrt' have been
     added.

   * The '-' and '/' procedures and the character and string comparison
     predicates are now required to support more than two arguments.

   * The forms #true and #false are now supported as well as #t and #f.

   * The procedures 'make-list', 'list-copy', 'list-set!', 'string-map',
     'string-for-each', 'string->vector', 'vector-append',
     'vector-copy', 'vector-map', 'vector-for-each', 'vector->string',
     'vector-copy!', and 'string-copy!' have been added to round out the
     sequence operations.

   * Some string and vector procedures support processing of part of a
     string or vector using optional START and END arguments.

   * Some list procedures are now defined on circular lists.

   * Implementations may provide any subset of the full Unicode
     repertoire that includes ASCII, but implementations must support
     any such subset in a way consistent with Unicode.  Various
     character and string procedures have been extended accordingly, and
     case conversion procedures added for strings.  String comparison is
     no longer required to be consistent with character comparison,
     which is based solely on Unicode scalar values.  The new
     'digit-value' procedure has been added to obtain the numerical
     value of a numeric character.

   * There are now two additional comment syntaxes: #; to skip the next
     datum, and #| ... |# for nestable block comments.

   * Data prefixed with datum labels #<n>= can be referenced with #<n>#,
     allowing for reading and writing of data with shared structure.

   * Strings and symbols now allow mnemonic and numeric escape
     sequences, and the list of named characters has been extended.

   * The procedures 'file-exists?' and 'delete-file' are available in
     the (scheme file) library.

   * An interface to the system environment, command line, and process
     exit status is available in the (scheme process-context) library.

   * Procedures for accessing time-related values are available in the
     (scheme time) library.

   * A less irregular set of integer division operators is provided with
     new and clearer names.

   * The 'load' procedure now accepts a second argument specifying the
     environment to load into.

   * The 'call-with-current-continuation' procedure now has the synonym
     'call/cc'.

   * The semantics of read-eval-print loops are now partly prescribed,
     requiring the redefinition of procedures, but not syntax keywords,
     to have retroactive effect.

   * The formal semantics now handles 'dynamic-wind'.


File: r7rs.info,  Node: Incompatibilities with R^{6}RS,  Prev: Other language changes since R^{5}RS,  Up: Language changes

Incompatibilities with R^{6}RS
==============================

This section enumerates the incompatibilities between R^{7}RS and the
"Revised^6 report" [R6RS] and its accompanying Standard Libraries
document.

_This list is not authoritative, and is possibly incomplete._

   * R^{7}RS libraries begin with the keyword 'define-library' rather
     than 'library' in order to make them syntactically distinguishable
     from R^{6}RS libraries.  In R^{7}RS terms, the body of an R^{6}RS
     library consists of a single export declaration followed by a
     single import declaration, followed by commands and definitions.
     In R^{7}RS, commands and definitions are not permitted directly
     within the body: they have to be wrapped in a 'begin' library
     declaration.

   * There is no direct R^{6}RS equivalent of the 'include',
     'include-ci', 'include-library-declarations', or 'cond-expand'
     library declarations.  On the other hand, the R^{7}RS library
     syntax does not support phase or version specifications.

   * The grouping of standardized identifiers into libraries is
     different from the R^{6}RS approach.  In particular, procedures
     which are optional in R^{5}RS either expressly or by implication,
     have been removed from the base library.  Only the base library
     itself is an absolute requirement.

   * No form of identifier syntax is provided.

   * Internal syntax definitions are allowed, but uses of a syntax form
     cannot appear before its definition; the 'even'/'odd' example given
     in R^{6}RS is not allowed.

   * The R^{6}RS exception system was incorporated as-is, but the
     condition types have been left unspecified.  In particular, where
     R^{6}RS requires a condition of a specified type to be signaled,
     R^{7}RS says only "it is an error", leaving the question of
     signaling open.

   * Full Unicode support is not required.  Normalization is not
     provided.  Character comparisons are defined by Unicode, but string
     comparisons are implementation-dependent.  Non-Unicode characters
     are permitted.

   * The full numeric tower is optional as in R^{5}RS, but optional
     support for IEEE infinities, NaN, and mbox -0.0 was adopted from
     R^{6}RS. Most clarifications on numeric results were also adopted,
     but the semantics of the R^{6}RS procedures 'real?', 'rational?',
     and 'integer'?  were not adopted.  (Note that the R^{5}RS/R^{7}RS
     semantics are available in R^{6}RS using 'real-valued?',
     'rational-valued?', and 'integer-valued?').  The R^{6}RS division
     operators 'div', 'mod', 'div-and-mod', 'div0', 'mod0' and
     'div0-and-mod0' are not provided.

   * When a result is unspecified, it is still required to be a single
     value.  However, non-final expressions in a body can return any
     number of values.

   * The semantics of 'map' and 'for-each' have been changed to use the
     SRFI 1 [srfi1] early termination behavior.  Likewise, 'assoc' and
     'member' take an optional 'equal?' argument as in SRFI 1, instead
     of the separate 'assp' and 'memp' procedures of R^{6}RS.

   * The R^{6}RS 'quasiquote' clarifications have been adopted, with the
     exception of multiple-argument 'unquote' and 'unquote-splicing'.

   * The R^{6}RS method of specifying mantissa widths was not adopted.

   * String ports are compatible with SRFI 6 [srfi6] rather than
     R^{6}RS.

   * R^{6}RS-style bytevectors are included, but only the unsigned byte
     ('u8') procedures have been provided.  The lexical syntax uses
     '#u8' for compatibility with SRFI 4 [srfi4], rather than the
     R^{6}RS '#vu8' style.

   * The utility macros 'when' and 'unless' are provided, but their
     result is left unspecified.

   * The remaining features of the Standard Libraries document were left
     to future standardization efforts.


File: r7rs.info,  Node: Additional material,  Next: Example,  Prev: Language changes,  Up: Top

Additional material
*******************

The Scheme community website at <http://schemers.org> contains
additional resources for learning and programming, job and event
postings, and Scheme user group information.

A bibliography of Scheme-related research at
<http://library.readscheme.org> links to technical papers and theses
related to the Scheme language, including both classic papers and recent
research.

On-line Scheme discussions are held using IRC on the '#scheme' channel
at 'irc.freenode.net' and on the Usenet discussion group
'comp.lang.scheme'.


File: r7rs.info,  Node: Example,  Next: Bibliography,  Prev: Additional material,  Up: Top

Example
*******

The procedure 'integrate-system' integrates the system

            y_k^^ = f_k(y_1, y_2, ..., y_n), k = 1, ..., n

of differential equations with the method of Runge-Kutta.

The parameter system-derivative is a function that takes a system state
(a vector of values for the state variables y_1, ..., y_n) and produces
a system derivative (the values y_1^^, ...,y_n^^).  The parameter
initial-state provides an initial system state, and h is an initial
guess for the length of the integration step.

The value returned by 'integrate-system' is an infinite stream of system
states.


     (define (integrate-system system-derivative
                               initial-state
                               h)
       (let ((next (runge-kutta-4 system-derivative h)))
         (letrec ((states
                   (cons initial-state
                         (delay (map-streams next
                                             states)))))
           states)))


The procedure 'runge-kutta-4' takes a function, f, that produces a
system derivative from a system state.  It produces a function that
takes a system state and produces a new system state.


     (define (runge-kutta-4 f h)
       (let ((*h (scale-vector h))
             (*2 (scale-vector 2))
             (*1/2 (scale-vector (/ 1 2)))
             (*1/6 (scale-vector (/ 1 6))))
         (lambda (y)
           ;; y is a system state
           (let* ((k0 (*h (f y)))
                  (k1 (*h (f (add-vectors y (*1/2 k0)))))
                  (k2 (*h (f (add-vectors y (*1/2 k1)))))
                  (k3 (*h (f (add-vectors y k2)))))
             (add-vectors y
               (*1/6 (add-vectors k0
                                  (*2 k1)
                                  (*2 k2)
                                  k3)))))))

     (define (elementwise f)
       (lambda vectors
         (generate-vector
          (vector-length (car vectors))
          (lambda (i)
            (apply f
                   (map (lambda (v) (vector-ref  v i))
                        vectors))))))

     (define (generate-vector size proc)
       (let ((ans (make-vector size)))
         (letrec ((loop
                   (lambda (i)
                     (cond ((= i size) ans)
                           (else
                            (vector-set! ans i (proc i))
                            (loop (+ i 1)))))))
           (loop 0))))

     (define add-vectors (elementwise +))

     (define (scale-vector s)
       (elementwise (lambda (x) (* x s))))


The 'map-streams' procedure is analogous to 'map': it applies its first
argument (a procedure) to all the elements of its second argument (a
stream).


     (define (map-streams f s)
       (cons (f (head s))
             (delay (map-streams f (tail s)))))


Infinite streams are implemented as pairs whose car holds the first
element of the stream and whose cdr holds a promise to deliver the rest
of the stream.


     (define head car)
     (define (tail stream)
       (force (cdr stream)))








The following illustrates the use of 'integrate-system' in integrating
the system

                     C dv_C / dt = -i_L - v_C / R

                           L di_L / dt = v_C

which models a damped oscillator.


     (define (damped-oscillator R L C)
       (lambda (state)
         (let ((Vc (vector-ref state 0))
               (Il (vector-ref state 1)))
           (vector (- 0 (+ (/ Vc (* R C)) (/ Il C)))
                   (/ Vc L)))))

     (define the-states
       (integrate-system
          (damped-oscillator 10000 1000 .001)
          '#(1 0)
          .01))



File: r7rs.info,  Node: Bibliography,  Next: Index,  Prev: Example,  Up: Top

Bibliography
************

   * [SICP] Harold Abelson and Gerald Jay Sussman with Julie Sussman.
     _Structure and Interpretation of Computer Programs, second
     edition._  MIT Press, Cambridge, 1996.

   * [Bawden88] Alan Bawden and Jonathan Rees.  Syntactic closures.  In
     _Proceedings of the 1988 ACM Symposium on Lisp and Functional
     Programming_, pages 86-95.

   * [rfc2119] S. Bradner.  Key words for use in RFCs to Indicate
     Requirement Levels.  <http://www.ietf.org/rfc/rfc2119.txt>, 1997.

   * [howtoprint] Robert G. Burger and R. Kent Dybvig.  Printing
     floating-point numbers quickly and accurately.  In _Proceedings of
     the ACM SIGPLAN '96 Conference on Programming Language Design and
     Implementation_, pages 108-116.

   * [howtoread] William Clinger.  How to read floating point numbers
     accurately.  In _Proceedings of the ACM SIGPLAN '90 Conference on
     Programming Language Design and Implementation_, pages 92-101.
     Proceedings published as _SIGPLAN Notices_ 25(6), June 1990.

   * [propertailrecursion] William Clinger.  Proper Tail Recursion and
     Space Efficiency.  In _Proceedings of the 1998 ACM Conference on
     Programming Language Design and Implementation_, June 1998.

   * [srfi6] William Clinger.  SRFI 6: Basic String Ports.
     <http://srfi.schemers.org/srfi-6/>, 1999.

   * [RRRS] William Clinger, editor.  The revised revised report on
     Scheme, or an uncommon Lisp.  MIT Artificial Intelligence Memo 848,
     August 1985.  Also published as Computer Science Department
     Technical Report 174, Indiana University, June 1985.

   * [macrosthatwork] William Clinger and Jonathan Rees.  Macros that
     work.  In _Proceedings of the 1991 ACM Conference on Principles of
     Programming Languages_, pages 155-162.

   * [R4RS] William Clinger and Jonathan Rees, editors.  The revised^4
     report on the algorithmic language Scheme.  In _ACM Lisp Pointers_
     4(3), pages 1-55, 1991.

   * [uax44] Mark Davis.  Unicode Standard Annex #44, Unicode Character
     Database.  <http://unicode.org/reports/tr44/>, 2010.

   * [syntacticabstraction] R. Kent Dybvig, Robert Hieb, and Carl
     Bruggeman.  Syntactic abstraction in Scheme.  _Lisp and Symbolic
     Computation_ 5(4):295-326, 1993.

   * [srfi4] Marc Feeley.  SRFI 4: Homogeneous Numeric Vector Datatypes.
     <http://srfi.schemers.org/srfi-4/>, 1999.

   * [Scheme311] Carol Fessenden, William Clinger, Daniel P. Friedman,
     and Christopher Haynes.  Scheme 311 version 4 reference manual.
     Indiana University Computer Science Technical Report 137, February
     1983.  Superseded by [Scheme84].

   * [Scheme84] D. Friedman, C. Haynes, E. Kohlbecker, and M. Wand.
     Scheme 84 interim reference manual.  Indiana University Computer
     Science Technical Report 153, January 1985.

   * [life] Martin Gardner.  Mathematical Games: The fantastic
     combinations of John Conway's new solitaire game "Life."  In
     _Scientific American_, 223:120-123, October 1970.

   * [IEEE] _IEEE Standard 754-2008.  IEEE Standard for Floating-Point
     Arithmetic._  IEEE, New York, 2008.

   * [IEEEScheme] _IEEE Standard 1178-1990.  IEEE Standard for the
     Scheme Programming Language._  IEEE, New York, 1991.

   * [srfi9] Richard Kelsey.  SRFI 9: Defining Record Types.
     <http://srfi.schemers.org/srfi-9/>, 1999.

   * [R5RS] Richard Kelsey, William Clinger, and Jonathan Rees, editors.
     The revised^5 report on the algorithmic language Scheme.
     _Higher-Order and Symbolic Computation_, 11(1):7-105, 1998.

   * [Kohlbecker86] Eugene E. Kohlbecker Jr.  _Syntactic Extensions in
     the Programming Language Lisp._  PhD thesis, Indiana University,
     August 1986.

   * [hygienic] Eugene E. Kohlbecker Jr., Daniel P. Friedman, Matthias
     Felleisen, and Bruce Duba.  Hygienic macro expansion.  In
     _Proceedings of the 1986 ACM Conference on Lisp and Functional
     Programming_, pages 151-161.

   * [McCarthy] John McCarthy.  Recursive Functions of Symbolic
     Expressions and Their Computation by Machine, Part I.
     _Communications of the ACM_ 3(4):184-195, April 1960.

   * [MITScheme] MIT Department of Electrical Engineering and Computer
     Science.  Scheme manual, seventh edition.  September 1984.

   * [Naur63] Peter Naur et al.  Revised report on the algorithmic
     language Algol 60.  _Communications of the ACM_ 6(1):1-17, January
     1963.

   * [Penfield81] Paul Penfield, Jr.  Principal values and branch cuts
     in complex APL. In _APL '81 Conference Proceedings,_ pages 248-256.
     ACM SIGAPL, San Francisco, September 1981.  Proceedings published
     as _APL Quote Quad_ 12(1), ACM, September 1981.

   * [Rees82] Jonathan A. Rees and Norman I. Adams IV. T: A dialect of
     Lisp or, lambda: The ultimate software tool.  In _Conference Record
     of the 1982 ACM Symposium on Lisp and Functional Programming_,
     pages 114-122.

   * [Rees84] Jonathan A. Rees, Norman I. Adams IV, and James R. Meehan.
     The T manual, fourth edition.  Yale University Computer Science
     Department, January 1984.

   * [R3RS] Jonathan Rees and William Clinger, editors.  The revised^3
     report on the algorithmic language Scheme.  In _ACM SIGPLAN
     Notices_ 21(12), pages 37-79, December 1986.

   * [srfi1] Olin Shivers.  SRFI 1: List Library.
     <http://srfi.schemers.org/srfi-1/>, 1999.

   * [Scheme78] Guy Lewis Steele Jr.  and Gerald Jay Sussman.  The
     revised report on Scheme, a dialect of Lisp.  MIT Artificial
     Intelligence Memo 452, January 1978.

   * [Rabbit] Guy Lewis Steele Jr.  Rabbit: a compiler for Scheme.  MIT
     Artificial Intelligence Laboratory Technical Report 474, May 1978.

   * [R6RS] Michael Sperber, R. Kent Dybvig, Mathew Flatt, and Anton van
     Straaten, editors.  _The revised^6 report on the algorithmic
     language Scheme._  Cambridge University Press, 2010.

   * [CLtL] Guy Lewis Steele Jr.  _Common Lisp: The Language, second
     edition._  Digital Press, Burlington MA, 1990.

   * [Scheme75] Gerald Jay Sussman and Guy Lewis Steele Jr.  Scheme: an
     interpreter for extended lambda calculus.  MIT Artificial
     Intelligence Memo 349, December 1975.

   * [Stoy77] Joseph E. Stoy.  _Denotational Semantics: The
     Scott-Strachey Approach to Programming Language Theory._  MIT
     Press, Cambridge, 1977.

   * [TImanual85] Texas Instruments, Inc.  TI Scheme Language Reference
     Manual.  Preliminary version 1.0, November 1985.

   * [srfi45] Andre van Tonder.  SRFI 45: Primitives for Expressing
     Iterative Lazy Algorithms.  <http://srfi.schemers.org/srfi-45/>,
     2002.

   * [GasbichlerKnauelSperberKelsey2003] Martin Gasbichler, Eric Knauel,
     Michael Sperber and Richard Kelsey.  How to Add Threads to a
     Sequential Language Without Getting Tangled Up.  _Proceedings of
     the Fourth Workshop on Scheme and Functional Programming_, November
     2003.

   * [TAI] International Earth Rotation Service.  Historical table of
     TAI-UTC offsets.  <http://maia.usno.navy.mil/ser7/tai-utc.dat>


File: r7rs.info,  Node: Index,  Prev: Bibliography,  Up: Top

Alphabetic index of definitions of concepts, keywords, and procedures
*********************************************************************

The principal entry for each term, procedure, or keyword is listed
first, separated from the other entries by a semicolon.







Concepts
========

 [index ]
* Menu:

* "|#@|#:                                Whitespace and comments.
                                                              (line  27)
* #"|@#|:                                Whitespace and comments.
                                                              (line  27)
* ':                                     Literal expressions. (line  12)
* ,:                                     Quasiquotation.      (line  22)
* ,@:                                    Quasiquotation.      (line  27)
* ;:                                     Whitespace and comments.
                                                              (line  19)
* =>:                                    Conditional.         (line  27)
* _:                                     Pattern language.    (line  20)
* ' <1>:                                 Quasiquotation.      (line  96)
* acknowledgments:                       Acknowledgments.     (line   6)
* additional material:                   Additional material. (line   6)
* alphabetic index of definitions of concepts, keywords, and procedures: Index.
                                                              (line   6)
* assignments:                           Assignments.         (line   6)
* background:                            Background.          (line   6)
* backquote:                             Quasiquotation.      (line  18)
* base and optional features:            Base and optional features.
                                                              (line   6)
* base library:                          Base and optional features.
                                                              (line   7)
* basic concepts:                        Basic concepts.      (line  13)
* bibliography:                          Bibliography.        (line   6)
* binding:                               Variables; syntactic keywords; and regions.
                                                              (line  11)
* binding construct:                     Variables; syntactic keywords; and regions.
                                                              (line  23)
* binding constructs:                    Binding constructs.  (line   6)
* binding constructs for syntactic keywords: Binding constructs for syntactic keywords.
                                                              (line   6)
* body:                                  Binding constructs.  (line 124)
* booleans:                              Booleans.            (line   6)
* bound:                                 Variables; syntactic keywords; and regions.
                                                              (line  43)
* byte:                                  Bytevectors.         (line   8)
* bytevectors:                           Bytevectors.         (line   6)
* caaaar:                                Pairs and lists.     (line 175)
* caaadr:                                Pairs and lists.     (line 175)
* caadar:                                Pairs and lists.     (line 175)
* caaddr:                                Pairs and lists.     (line 175)
* cadaar:                                Pairs and lists.     (line 175)
* cadadr:                                Pairs and lists.     (line 175)
* cadar:                                 Pairs and lists.     (line 175)
* caddar:                                Pairs and lists.     (line 175)
* cadddr:                                Pairs and lists.     (line 175)
* caddr:                                 Pairs and lists.     (line 175)
* call:                                  Procedure calls.     (line  12)
* call by need:                          Delayed evaluation.  (line  10)
* case-lambda:                           Case-lambda.         (line   6)
* cdaaar:                                Pairs and lists.     (line 175)
* cdaadr:                                Pairs and lists.     (line 175)
* cdaar:                                 Pairs and lists.     (line 175)
* cdadar:                                Pairs and lists.     (line 175)
* cdaddr:                                Pairs and lists.     (line 175)
* cdadr:                                 Pairs and lists.     (line 175)
* cddaar:                                Pairs and lists.     (line 175)
* cddadr:                                Pairs and lists.     (line 175)
* cddar:                                 Pairs and lists.     (line 175)
* cdddr:                                 Pairs and lists.     (line 175)
* characters:                            Characters.          (line   6)
* comma:                                 Quasiquotation.      (line  21)
* command:                               Naming conventions.  (line  22)
* comment:                               Whitespace and comments.
                                                              (line  19)
* comment <1>:                           Lexical structure.   (line  51)
* conditionals:                          Conditionals.        (line   6)
* conditionals <1>:                      Conditional.         (line   6)
* constant:                              Storage model.       (line  43)
* continuation:                          Control features.    (line 270)
* control features:                      Control features.    (line   6)
* current exception handler:             Exceptions.          (line  16)
* datum labels:                          Datum labels.        (line   6)
* define:                                Variable definitions.
                                                              (line  14)
* define-library:                        Library Syntax.      (line   8)
* define-record-type:                    Record-type definitions.
                                                              (line  13)
* define-syntax:                         Syntax definitions.  (line   6)
* definition:                            Programs.            (line  17)
* delayed evaluation:                    Delayed evaluation.  (line   6)
* derived expression types:              Derived expression types.
                                                              (line  18)
* derived expression types <1>:          Derived expression type.
                                                              (line   6)
* disjointness of types:                 Disjointness of types.
                                                              (line   6)
* do:                                    Iteration.           (line   9)
* dotted pair:                           Pairs and lists.     (line   6)
* 
dynamic :                             Dynamic bindings.    (line  15)
* dynamic bindings:                      Dynamic bindings.    (line   6)
* dynamic extent:                        Dynamic bindings.    (line   6)
* else:                                  Conditional.         (line  27)
* empty list:                            Disjointness of types.
                                                              (line  23)
* empty list <1>:                        Booleans.            (line  19)
* empty list <2>:                        Pairs and lists.     (line  13)
* entry format:                          Entry format.        (line   6)
* environment:                           System interface.    (line  82)
* environment variables:                 System interface.    (line  82)
* environments and evaluation:           Environments and evaluation.
                                                              (line   6)
* equivalence predicate:                 Equivalence predicates.
                                                              (line   7)
* equivalence predicates:                Equivalence predicates.
                                                              (line   6)
* error:                                 Error situations and unspecified behavior.
                                                              (line   6)
* error situations and unspecified behavior: Error situations and unspecified behavior.
                                                              (line   6)
* escape procedure:                      Control features.    (line 199)
* escape sequence:                       Strings.             (line   8)
* evaluation examples:                   Evaluation examples. (line   6)
* exact complex number:                  Exactness.           (line  21)
* exactness:                             Exactness.           (line   6)
* example:                               Example.             (line   6)
* exception handler:                     Exceptions.          (line  11)
* exception handling:                    Exception handling.  (line   6)
* exceptions:                            Exceptions.          (line   6)
* expressions:                           Expressions.         (line  12)
* expressions <1>:                       Expression.          (line   6)
* external representations:              External representations.
                                                              (line   6)
* external representations <1>:          External representation.
                                                              (line   6)
* false:                                 Disjointness of types.
                                                              (line  27)
* false <1>:                             Booleans.            (line  10)
* fields:                                Record-type definitions.
                                                              (line  10)
* formal semantics:                      Formal semantics.    (line   6)
* formal syntax:                         Formal syntax.       (line  16)
* formal syntax and semantics:           Formal syntax and semantics.
                                                              (line  12)
* fresh:                                 Procedures.          (line  20)
* global environment:                    Variables; syntactic keywords; and regions.
                                                              (line  43)
* global environment <1>:                Standard procedures. (line  23)
* guard:                                 Exception handling.  (line  10)
* hygienic:                              Macros.              (line  56)
* identifier:                            Identifiers.         (line   6)
* identifier <1>:                        Variables; syntactic keywords; and regions.
                                                              (line   6)
* identifier <2>:                        Lexical structure.   (line  40)
* identifiers:                           Identifiers.         (line   6)
* immutable:                             Storage model.       (line  32)
* implementation extension:              Implementation extensions.
                                                              (line   6)
* implementation extensions:             Implementation extensions.
                                                              (line   6)
* implementation restriction:            Error situations and unspecified behavior.
                                                              (line  40)
* implementation restriction <1>:        Implementation restrictions.
                                                              (line   6)
* implementation restrictions:           Implementation restrictions.
                                                              (line   6)
* import:                                Import declarations. (line   6)
* import declarations:                   Import declarations. (line   6)
* improper list:                         Pairs and lists.     (line  56)
* inclusion:                             Inclusion.           (line   6)
* incompatibilities with r^{5}rs:        Incompatibilities with R^{5}RS.
                                                              (line   6)
* incompatibilities with r^{6}rs:        Incompatibilities with R^{6}RS.
                                                              (line   6)
* 
inexact :                             Exactness.           (line  23)
* initial environment:                   Standard procedures. (line  23)
* input:                                 Input.               (line   6)
* input and output:                      Input and output.    (line  11)
* internal definition:                   Internal definitions.
                                                              (line  12)
* internal definitions:                  Internal definitions.
                                                              (line   6)
* internal syntax definition:            Syntax definitions.  (line  18)
* introduction:                          Introduction.        (line  11)
* irritants:                             Exceptions.          (line  95)
* iteration:                             Iteration.           (line   6)
* jiffies:                               System interface.    (line 125)
* keyword:                               Macros.              (line  21)
* language changes:                      Language changes.    (line  11)
* lazy evaluation:                       Delayed evaluation.  (line  10)
* lexical conventions:                   Lexical conventions. (line  13)
* lexical structure:                     Lexical structure.   (line   6)
* libraries:                             Base and optional features.
                                                              (line   7)
* libraries <1>:                         Libraries.           (line  11)
* libraries <2>:                         Librarie.            (line   6)
* library example:                       Library example.     (line   6)
* library syntax:                        Library Syntax.      (line   6)
* list:                                  Pairs and lists.     (line  12)
* literal expressions:                   Literal expressions. (line   6)
* location:                              Storage model.       (line   7)
* macro:                                 Macros.              (line  13)
* macro keyword:                         Macros.              (line  21)
* macro transformer:                     Macros.              (line  26)
* macro use:                             Macros.              (line  24)
* macros:                                Macros.              (line  12)
* multiple-value definitions:            Multiple-value definitions.
                                                              (line   6)
* mutable:                               Storage model.       (line  31)
* mutation procedures:                   Naming conventions.  (line  14)
* naming conventions:                    Naming conventions.  (line   6)
* newly allocated:                       Standard procedures. (line  40)
* notation and terminology:              Notation and terminology.
                                                              (line  13)
* number:                                Numbers.             (line  16)
* numbers:                               Numbers.             (line  16)
* numerical input and output:            Numerical input and output.
                                                              (line   6)
* numerical operations:                  Numerical operations.
                                                              (line   6)
* numerical types:                       Numerical types.     (line   6)
* object:                                Semantics.           (line  16)
* other language changes since r^{5}rs:  Other language changes since R^{5}RS.
                                                              (line   6)
* other notations:                       Other notations.     (line   6)
* output:                                Output.              (line   6)
* overview of scheme:                    Overview of Scheme.  (line  11)
* pair:                                  Pairs and lists.     (line   6)
* pairs and lists:                       Pairs and lists.     (line   6)
* parameter objects:                     Dynamic bindings.    (line  13)
* parameterize:                          Dynamic bindings.    (line  35)
* pattern language:                      Pattern language.    (line   6)
* polar notation:                        Syntax of numerical constants.
                                                              (line  49)
* port:                                  Ports.               (line   8)
* ports:                                 Ports.               (line   6)
* predicate:                             Equivalence predicates.
                                                              (line   6)
* predicates:                            Naming conventions.  (line   8)
* primitive expression types:            Primitive expression types.
                                                              (line  15)
* procedure:                             Standard procedures. (line  23)
* procedure call:                        Procedure calls.     (line  12)
* procedure calls:                       Procedure calls.     (line   6)
* procedures:                            Procedures.          (line   6)
* program structure:                     Program structure.   (line  15)
* programs:                              Programs.            (line   6)
* programs and definitions:              Programs and definitions.
                                                              (line   6)
* promise:                               Delayed evaluation.  (line  11)
* proper tail recursion:                 Proper tail recursion.
                                                              (line   6)
* quasiquotation:                        Quasiquotation.      (line   6)
* quasiquotations:                       Quasiquotations.     (line   6)
* record types:                          Record-type definitions.
                                                              (line   7)
* record-type definitions:               Record-type definitions.
                                                              (line   6)
* records:                               Record-type definitions.
                                                              (line   9)
* rectangular notation:                  Syntax of numerical constants.
                                                              (line  48)
* referentially transparent:             Macros.              (line  56)
* region:                                Variables; syntactic keywords; and regions.
                                                              (line  34)
* region <1>:                            Assignments.         (line  11)
* region <2>:                            Binding constructs.  (line   9)
* region <3>:                            Iteration.           (line  38)
* repl:                                  The REPL.            (line   7)
* semantics:                             Semantics.           (line   6)
* sequencing:                            Sequencing.          (line   6)
* signaling errors in macro transformers: Signaling errors in macro transformers.
                                                              (line   6)
* simplest rational:                     Numerical operations.
                                                              (line 348)
* standard feature identifiers:          Standard Feature Identifiers.
                                                              (line   6)
* standard libraries:                    Standard Libraries.  (line   6)
* standard procedures:                   Standard procedures. (line  23)
* storage model:                         Storage model.       (line   6)
* strings:                               Strings.             (line   6)
* summary:                               (outside of any node).
                                                              (line   0)
* summary <1>:                           Top.                 (line  27)
* symbols:                               Symbols.             (line   6)
* syntactic keyword:                     Identifiers.         (line  56)
* syntactic keyword <1>:                 Variables; syntactic keywords; and regions.
                                                              (line   8)
* syntactic keyword <2>:                 Macros.              (line  21)
* syntax:                                Syntax.              (line   6)
* syntax definition:                     Syntax definitions.  (line   6)
* syntax definitions:                    Syntax definitions.  (line   6)
* syntax of numerical constants:         Syntax of numerical constants.
                                                              (line   6)
* syntax-error:                          Signaling errors in macro transformers.
                                                              (line   8)
* system interface:                      System interface.    (line   6)
* tail call:                             Proper tail recursion.
                                                              (line  42)
* the repl:                              The REPL.            (line   6)
* thunk:                                 Naming conventions.  (line  25)
* token:                                 Lexical structure.   (line   6)
* top level definitions:                 Top level definitions.
                                                              (line   6)
* transformers:                          Transformers.        (line   6)
* true:                                  Disjointness of types.
                                                              (line  27)
* true <1>:                              Conditionals.        (line  12)
* true <2>:                              Conditional.         (line  29)
* true <3>:                              Booleans.            (line  10)
* type:                                  Disjointness of types.
                                                              (line  23)
* unbound:                               Variables; syntactic keywords; and regions.
                                                              (line  43)
* unbound <1>:                           Variable references. (line  12)
* unbound <2>:                           Top level definitions.
                                                              (line  21)
* unspecified:                           Error situations and unspecified behavior.
                                                              (line  50)
* valid indexes:                         Strings.             (line  46)
* valid indexes <1>:                     Vectors.             (line  13)
* valid indexes <2>:                     Bytevectors.         (line  13)
* variable:                              Identifiers.         (line  56)
* variable <1>:                          Variables; syntactic keywords; and regions.
                                                              (line  10)
* variable <2>:                          Variable references. (line   8)
* variable definition:                   Variable definitions.
                                                              (line  12)
* variable definitions:                  Variable definitions.
                                                              (line  12)
* variable references:                   Variable references. (line   6)
* variables; syntactic keywords; and regions: Variables; syntactic keywords; and regions.
                                                              (line   6)
* vectors:                               Vectors.             (line   6)
* whitespace:                            Whitespace and comments.
                                                              (line   7)
* whitespace and comments:               Whitespace and comments.
                                                              (line   6)

Procedures
==========

 [index ]
* Menu:

*          ...:                          Pairs and lists.     (line 173)
* '<datum>:                              Literal expressions. (line   8)
* (<operator>:                           Procedure calls.     (line   6)
* (define-record-type:                   Record-type definitions.
                                                              (line  13)
* (do:                                   Iteration.           (line   7)
* (guard:                                Exception handling.  (line   6)
* (make-vector:                          Entry format.        (line  52)
* (make-vector <1>:                      Entry format.        (line  54)
* (parameterize:                         Dynamic bindings.    (line  31)
* (syntax-error:                         Signaling errors in macro transformers.
                                                              (line   6)
* (syntax-rules:                         Pattern language.    (line   8)
* (syntax-rules <1>:                     Pattern language.    (line  12)
* (vector-ref:                           Entry format.        (line  45)
* *:                                     Numerical operations.
                                                              (line 181)
* +:                                     Numerical operations.
                                                              (line 180)
* ,:                                     Quasiquotation.      (line  12)
* ,@:                                    Quasiquotation.      (line  16)
* -:                                     Numerical operations.
                                                              (line 192)
* - <1>:                                 Numerical operations.
                                                              (line 193)
* /:                                     Numerical operations.
                                                              (line 194)
* / <1>:                                 Numerical operations.
                                                              (line 195)
* <:                                     Numerical operations.
                                                              (line 120)
* <=:                                    Numerical operations.
                                                              (line 122)
* <constant>:                            Literal expressions. (line  10)
* <variable>:                            Variable references. (line   6)
* =:                                     Numerical operations.
                                                              (line 119)
* =>:                                    Conditional.         (line  10)
* >:                                     Numerical operations.
                                                              (line 121)
* >=:                                    Numerical operations.
                                                              (line 123)
* `<qq template>:                        Quasiquotation.      (line   8)
* ...:                                   Pattern language.    (line  18)
* abs:                                   Numerical operations.
                                                              (line 214)
* acos:                                  Numerical operations.
                                                              (line 368)
* and:                                   Conditional.         (line 115)
* angle:                                 Numerical operations.
                                                              (line 483)
* append:                                Pairs and lists.     (line 232)
* apply:                                 Control features.    (line  26)
* asin:                                  Numerical operations.
                                                              (line 367)
* assoc:                                 Pairs and lists.     (line 328)
* assoc <1>:                             Pairs and lists.     (line 329)
* assq:                                  Pairs and lists.     (line 326)
* assv:                                  Pairs and lists.     (line 327)
* atan:                                  Numerical operations.
                                                              (line 369)
* atan <1>:                              Numerical operations.
                                                              (line 370)
* begin:                                 Sequencing.          (line   9)
* begin <1>:                             Sequencing.          (line  22)
* binary-port?:                          Ports.               (line  57)
* boolean=?:                             Booleans.            (line  54)
* boolean?:                              Booleans.            (line  44)
* bytevector:                            Bytevectors.         (line  43)
* bytevector-append:                     Bytevectors.         (line 111)
* bytevector-copy:                       Bytevectors.         (line  76)
* bytevector-copy <1>:                   Bytevectors.         (line  77)
* bytevector-copy <2>:                   Bytevectors.         (line  78)
* bytevector-copy!:                      Bytevectors.         (line  87)
* bytevector-copy! <1>:                  Bytevectors.         (line  88)
* bytevector-copy! <2>:                  Bytevectors.         (line  89)
* bytevector-length:                     Bytevectors.         (line  51)
* bytevector-u8-ref:                     Bytevectors.         (line  55)
* bytevector-u8-set!:                    Bytevectors.         (line  65)
* bytevector?:                           Bytevectors.         (line  28)
* caaar:                                 Pairs and lists.     (line 170)
* caadr:                                 Pairs and lists.     (line 171)
* caar:                                  Pairs and lists.     (line 157)
* cadr:                                  Pairs and lists.     (line 158)
* call-with-current-continuation:        Control features.    (line 193)
* call-with-input-file:                  Ports.               (line  45)
* call-with-output-file:                 Ports.               (line  46)
* call-with-port:                        Ports.               (line  28)
* call-with-values:                      Control features.    (line 296)
* call/cc:                               Control features.    (line 194)
* car:                                   Pairs and lists.     (line 122)
* case:                                  Conditional.         (line  59)
* case-lambda:                           Case-lambda.         (line   6)
* cdar:                                  Pairs and lists.     (line 159)
* cdddar:                                Pairs and lists.     (line 175)
* cddddr:                                Pairs and lists.     (line 176)
* cddr:                                  Pairs and lists.     (line 160)
* cdr:                                   Pairs and lists.     (line 133)
* ceiling:                               Numerical operations.
                                                              (line 310)
* char->integer:                         Characters.          (line 129)
* char-alphabetic?:                      Characters.          (line 101)
* char-ci<=?:                            Characters.          (line  91)
* char-ci<?:                             Characters.          (line  89)
* char-ci=?:                             Characters.          (line  88)
* char-ci>=?:                            Characters.          (line  92)
* char-ci>?:                             Characters.          (line  90)
* char-downcase:                         Characters.          (line 144)
* char-foldcase:                         Characters.          (line 145)
* char-lower-case?:                      Characters.          (line 105)
* char-numeric?:                         Characters.          (line 102)
* char-ready?:                           Input.               (line  91)
* char-ready? <1>:                       Input.               (line  92)
* char-upcase:                           Characters.          (line 143)
* char-upper-case?:                      Characters.          (line 104)
* char-whitespace?:                      Characters.          (line 103)
* char<=?:                               Characters.          (line  78)
* char<?:                                Characters.          (line  76)
* char=?:                                Characters.          (line  75)
* char>=?:                               Characters.          (line  79)
* char>?:                                Characters.          (line  77)
* char?:                                 Characters.          (line  71)
* close-input-port:                      Ports.               (line 115)
* close-output-port:                     Ports.               (line 116)
* close-port:                            Ports.               (line 114)
* command-line:                          System interface.    (line  44)
* complex?:                              Numerical operations.
                                                              (line  17)
* cond:                                  Conditional.         (line   6)
* cond-expand:                           Conditional.         (line 173)
* cons:                                  Pairs and lists.     (line 109)
* cos:                                   Numerical operations.
                                                              (line 365)
* current-error-port:                    Ports.               (line  72)
* current-input-port:                    Ports.               (line  70)
* current-jiffy:                         System interface.    (line 122)
* current-output-port:                   Ports.               (line  71)
* current-second:                        System interface.    (line 110)
* define-values:                         Multiple-value definitions.
                                                              (line  10)
* delay:                                 Delayed evaluation.  (line   6)
* delay-force:                           Delayed evaluation.  (line  17)
* delete-file:                           System interface.    (line  36)
* denominator:                           Numerical operations.
                                                              (line 296)
* digit-value:                           Characters.          (line 117)
* display:                               Output.              (line  51)
* display <1>:                           Output.              (line  52)
* dynamic-wind:                          Control features.    (line 310)
* else:                                  Conditional.         (line   8)
* emergency-exit:                        System interface.    (line  69)
* emergency-exit <1>:                    System interface.    (line  70)
* environment:                           Environments and evaluation.
                                                              (line   6)
* eof-object:                            Input.               (line  87)
* eof-object?:                           Input.               (line  80)
* eq?:                                   Equivalence predicates.
                                                              (line 183)
* equal?:                                Equivalence predicates.
                                                              (line 227)
* eqv?:                                  Equivalence predicates.
                                                              (line  13)
* error:                                 Exceptions.          (line  90)
* error-object-irritants:                Exceptions.          (line 119)
* error-object-message:                  Exceptions.          (line 115)
* error-object?:                         Exceptions.          (line 107)
* eval:                                  Environments and evaluation.
                                                              (line  61)
* even?:                                 Numerical operations.
                                                              (line 157)
* exact:                                 Numerical operations.
                                                              (line 514)
* exact-integer-sqrt:                    Numerical operations.
                                                              (line 459)
* exact-integer?:                        Numerical operations.
                                                              (line  75)
* exact?:                                Numerical operations.
                                                              (line  63)
* exit:                                  System interface.    (line  51)
* exit <1>:                              System interface.    (line  52)
* exp:                                   Numerical operations.
                                                              (line 361)
* expt:                                  Numerical operations.
                                                              (line 468)
* features:                              System interface.    (line 155)
* file-error?:                           Exceptions.          (line 124)
* file-exists?:                          System interface.    (line  30)
* finite?:                               Numerical operations.
                                                              (line  84)
* floor:                                 Numerical operations.
                                                              (line 309)
* floor-quotient:                        Numerical operations.
                                                              (line 222)
* floor-remainder:                       Numerical operations.
                                                              (line 223)
* floor/:                                Numerical operations.
                                                              (line 221)
* flush-output-port:                     Output.              (line 110)
* flush-output-port <1>:                 Output.              (line 111)
* for-each:                              Control features.    (line 131)
* force:                                 Delayed evaluation.  (line  28)
* gcd:                                   Numerical operations.
                                                              (line 282)
* get-environment-variable:              System interface.    (line  79)
* get-environment-variables:             System interface.    (line  98)
* get-output-bytevector:                 Ports.               (line 168)
* get-output-string:                     Ports.               (line 139)
* if:                                    Conditionals.        (line   6)
* if <1>:                                Conditionals.        (line   7)
* imag-part:                             Numerical operations.
                                                              (line 481)
* include:                               Inclusion.           (line   6)
* include-ci:                            Inclusion.           (line   7)
* inexact:                               Numerical operations.
                                                              (line 513)
* inexact?:                              Numerical operations.
                                                              (line  64)
* infinite?:                             Numerical operations.
                                                              (line  95)
* input-port-open?:                      Ports.               (line  64)
* input-port?:                           Ports.               (line  54)
* integer->char:                         Characters.          (line 130)
* integer?:                              Numerical operations.
                                                              (line  20)
* interaction-environment:               Environments and evaluation.
                                                              (line  52)
* jiffies-per-second:                    System interface.    (line 142)
* lambda:                                Procedures.          (line   6)
* lcm:                                   Numerical operations.
                                                              (line 283)
* length:                                Pairs and lists.     (line 223)
* let:                                   Binding constructs.  (line  19)
* let <1>:                               Iteration.           (line  57)
* let*:                                  Binding constructs.  (line  50)
* let*-values:                           Binding constructs.  (line 197)
* let-syntax:                            Binding constructs for syntactic keywords.
                                                              (line  12)
* let-values:                            Binding constructs.  (line 168)
* letrec:                                Binding constructs.  (line  73)
* letrec*:                               Binding constructs.  (line 117)
* letrec-syntax:                         Binding constructs for syntactic keywords.
                                                              (line  46)
* list:                                  Pairs and lists.     (line 215)
* list->string:                          Strings.             (line 196)
* list->vector:                          Vectors.             (line  84)
* list-copy:                             Pairs and lists.     (line 360)
* list-ref:                              Pairs and lists.     (line 274)
* list-set!:                             Pairs and lists.     (line 286)
* list-tail:                             Pairs and lists.     (line 261)
* list?:                                 Pairs and lists.     (line 191)
* load:                                  System interface.    (line  10)
* load <1>:                              System interface.    (line  11)
* log:                                   Numerical operations.
                                                              (line 362)
* log <1>:                               Numerical operations.
                                                              (line 363)
* magnitude:                             Numerical operations.
                                                              (line 482)
* make-bytevector:                       Bytevectors.         (line  32)
* make-bytevector <1>:                   Bytevectors.         (line  33)
* make-list:                             Pairs and lists.     (line 205)
* make-list <1>:                         Pairs and lists.     (line 206)
* make-parameter:                        Dynamic bindings.    (line  18)
* make-parameter <1>:                    Dynamic bindings.    (line  19)
* make-polar:                            Numerical operations.
                                                              (line 479)
* make-promise:                          Delayed evaluation.  (line 134)
* make-rectangular:                      Numerical operations.
                                                              (line 478)
* make-string:                           Strings.             (line  73)
* make-string <1>:                       Strings.             (line  74)
* make-vector:                           Vectors.             (line  34)
* make-vector <1>:                       Vectors.             (line  35)
* map:                                   Control features.    (line  41)
* max:                                   Numerical operations.
                                                              (line 162)
* member:                                Pairs and lists.     (line 302)
* member <1>:                            Pairs and lists.     (line 303)
* memq:                                  Pairs and lists.     (line 300)
* memv:                                  Pairs and lists.     (line 301)
* min:                                   Numerical operations.
                                                              (line 163)
* modulo:                                Numerical operations.
                                                              (line 273)
* nan?:                                  Numerical operations.
                                                              (line 107)
* negative?:                             Numerical operations.
                                                              (line 155)
* newline:                               Output.              (line  74)
* newline <1>:                           Output.              (line  75)
* not:                                   Booleans.            (line  30)
* null-environment:                      Environments and evaluation.
                                                              (line  33)
* null?:                                 Pairs and lists.     (line 187)
* number->string:                        Numerical input and output.
                                                              (line   6)
* number->string <1>:                    Numerical input and output.
                                                              (line   7)
* number?:                               Numerical operations.
                                                              (line  16)
* numerator:                             Numerical operations.
                                                              (line 295)
* odd?:                                  Numerical operations.
                                                              (line 156)
* open-binary-input-file:                Ports.               (line  96)
* open-binary-output-file:               Ports.               (line 104)
* open-input-bytevector:                 Ports.               (line 158)
* open-input-file:                       Ports.               (line  95)
* open-input-string:                     Ports.               (line 128)
* open-output-bytevector:                Ports.               (line 163)
* open-output-file:                      Ports.               (line 103)
* open-output-string:                    Ports.               (line 134)
* or:                                    Conditional.         (line 130)
* output-port-open?:                     Ports.               (line  65)
* output-port?:                          Ports.               (line  55)
* pair?:                                 Pairs and lists.     (line  98)
* peek-char:                             Input.               (line  46)
* peek-char <1>:                         Input.               (line  47)
* peek-u8:                               Input.               (line 124)
* peek-u8 <1>:                           Input.               (line 125)
* port?:                                 Ports.               (line  58)
* positive?:                             Numerical operations.
                                                              (line 154)
* procedure?:                            Control features.    (line  12)
* promise?:                              Delayed evaluation.  (line 128)
* quasiquote:                            Quasiquotation.      (line   6)
* quote:                                 Literal expressions. (line   6)
* quotient:                              Numerical operations.
                                                              (line 271)
* raise:                                 Exceptions.          (line  52)
* raise-continuable:                     Exceptions.          (line  63)
* rational?:                             Numerical operations.
                                                              (line  19)
* rationalize:                           Numerical operations.
                                                              (line 344)
* read:                                  Input.               (line  16)
* read <1>:                              Input.               (line  17)
* read-bytevector:                       Input.               (line 139)
* read-bytevector <1>:                   Input.               (line 140)
* read-bytevector!:                      Input.               (line 148)
* read-bytevector! <1>:                  Input.               (line 149)
* read-bytevector! <2>:                  Input.               (line 150)
* read-bytevector! <3>:                  Input.               (line 151)
* read-char:                             Input.               (line  39)
* read-char <1>:                         Input.               (line  40)
* read-error?:                           Exceptions.          (line 123)
* read-line:                             Input.               (line  63)
* read-line <1>:                         Input.               (line  64)
* read-string:                           Input.               (line 108)
* read-string <1>:                       Input.               (line 109)
* read-u8:                               Input.               (line 117)
* read-u8 <1>:                           Input.               (line 118)
* real-part:                             Numerical operations.
                                                              (line 480)
* real?:                                 Numerical operations.
                                                              (line  18)
* remainder:                             Numerical operations.
                                                              (line 272)
* reverse:                               Pairs and lists.     (line 251)
* round:                                 Numerical operations.
                                                              (line 312)
* scheme-report-environment:             Environments and evaluation.
                                                              (line  15)
* set!:                                  Assignments.         (line   6)
* set-car!:                              Pairs and lists.     (line 143)
* set-cdr!:                              Pairs and lists.     (line 153)
* SHARP<n>#:                             Datum labels.        (line   8)
* SHARP<n>=<datum>:                      Datum labels.        (line   6)
* sin:                                   Numerical operations.
                                                              (line 364)
* sqrt:                                  Numerical operations.
                                                              (line 449)
* square:                                Numerical operations.
                                                              (line 441)
* string:                                Strings.             (line  81)
* string->list:                          Strings.             (line 193)
* string->list <1>:                      Strings.             (line 194)
* string->list <2>:                      Strings.             (line 195)
* string->number:                        Numerical input and output.
                                                              (line  44)
* string->number <1>:                    Numerical input and output.
                                                              (line  45)
* string->symbol:                        Symbols.             (line  60)
* string->utf8:                          Bytevectors.         (line 123)
* string->utf8 <1>:                      Bytevectors.         (line 124)
* string->utf8 <2>:                      Bytevectors.         (line 125)
* string->vector:                        Vectors.             (line 104)
* string->vector <1>:                    Vectors.             (line 105)
* string->vector <2>:                    Vectors.             (line 106)
* string-append:                         Strings.             (line 188)
* string-ci<=?:                          Strings.             (line 131)
* string-ci<?:                           Strings.             (line 127)
* string-ci=?:                           Strings.             (line 118)
* string-ci>=?:                          Strings.             (line 133)
* string-ci>?:                           Strings.             (line 129)
* string-copy:                           Strings.             (line 205)
* string-copy <1>:                       Strings.             (line 206)
* string-copy <2>:                       Strings.             (line 207)
* string-copy!:                          Strings.             (line 212)
* string-copy! <1>:                      Strings.             (line 213)
* string-copy! <2>:                      Strings.             (line 214)
* string-downcase:                       Strings.             (line 163)
* string-fill!:                          Strings.             (line 232)
* string-fill! <1>:                      Strings.             (line 233)
* string-fill! <2>:                      Strings.             (line 234)
* string-foldcase:                       Strings.             (line 164)
* string-for-each:                       Control features.    (line 153)
* string-length:                         Strings.             (line  86)
* string-map:                            Control features.    (line  70)
* string-ref:                            Strings.             (line  90)
* string-set!:                           Strings.             (line  97)
* string-upcase:                         Strings.             (line 162)
* string<=?:                             Strings.             (line 130)
* string<?:                              Strings.             (line 126)
* string=?:                              Strings.             (line 112)
* string>=?:                             Strings.             (line 132)
* string>?:                              Strings.             (line 128)
* string?:                               Strings.             (line  69)
* substring:                             Strings.             (line 180)
* symbol->string:                        Symbols.             (line  46)
* symbol=?:                              Symbols.             (line  38)
* symbol?:                               Symbols.             (line  26)
* tan:                                   Numerical operations.
                                                              (line 366)
* TEMPLATE:                              Entry format.        (line  12)
* TEMPLATE <1>:                          Entry format.        (line  16)
* textual-port?:                         Ports.               (line  56)
* truncate:                              Numerical operations.
                                                              (line 311)
* truncate-quotient:                     Numerical operations.
                                                              (line 225)
* truncate-remainder:                    Numerical operations.
                                                              (line 226)
* truncate/:                             Numerical operations.
                                                              (line 224)
* u8-ready?:                             Input.               (line 131)
* u8-ready? <1>:                         Input.               (line 132)
* unless:                                Conditional.         (line 159)
* unquote:                               Quasiquotation.      (line  10)
* unquote-splicing:                      Quasiquotation.      (line  14)
* utf8->string:                          Bytevectors.         (line 120)
* utf8->string <1>:                      Bytevectors.         (line 121)
* utf8->string <2>:                      Bytevectors.         (line 122)
* values:                                Control features.    (line 286)
* vector:                                Vectors.             (line  41)
* vector->list:                          Vectors.             (line  81)
* vector->list <1>:                      Vectors.             (line  82)
* vector->list <2>:                      Vectors.             (line  83)
* vector->string:                        Vectors.             (line 101)
* vector->string <1>:                    Vectors.             (line 102)
* vector->string <2>:                    Vectors.             (line 103)
* vector-append:                         Vectors.             (line 160)
* vector-copy:                           Vectors.             (line 124)
* vector-copy <1>:                       Vectors.             (line 125)
* vector-copy <2>:                       Vectors.             (line 126)
* vector-copy!:                          Vectors.             (line 140)
* vector-copy! <1>:                      Vectors.             (line 141)
* vector-copy! <2>:                      Vectors.             (line 142)
* vector-fill!:                          Vectors.             (line 169)
* vector-fill! <1>:                      Vectors.             (line 170)
* vector-fill! <2>:                      Vectors.             (line 171)
* vector-for-each:                       Control features.    (line 173)
* vector-length:                         Vectors.             (line  49)
* vector-map:                            Control features.    (line 101)
* vector-ref:                            Vectors.             (line  53)
* vector-set!:                           Vectors.             (line  67)
* vector?:                               Vectors.             (line  30)
* when:                                  Conditional.         (line 145)
* with-exception-handler:                Exceptions.          (line  21)
* with-input-from-file:                  Ports.               (line  80)
* with-output-to-file:                   Ports.               (line  81)
* write:                                 Output.              (line  15)
* write <1>:                             Output.              (line  16)
* write-bytevector:                      Output.              (line 102)
* write-bytevector <1>:                  Output.              (line 103)
* write-bytevector <2>:                  Output.              (line 104)
* write-bytevector <3>:                  Output.              (line 105)
* write-char:                            Output.              (line  81)
* write-char <1>:                        Output.              (line  82)
* write-shared:                          Output.              (line  36)
* write-shared <1>:                      Output.              (line  37)
* write-simple:                          Output.              (line  43)
* write-simple <1>:                      Output.              (line  44)
* write-string:                          Output.              (line  88)
* write-string <1>:                      Output.              (line  89)
* write-string <2>:                      Output.              (line  90)
* write-string <3>:                      Output.              (line  91)
* write-u8:                              Output.              (line  96)
* write-u8 <1>:                          Output.              (line  97)
* zero?:                                 Numerical operations.
                                                              (line 153)

Variables
=========

 [index ]
* Menu:

* !:                                     Naming conventions.  (line  12)
* #!fold-case:                           Identifiers.         (line  68)
* #!no-fold-case:                        Identifiers.         (line  68)
* #;:                                    Whitespace and comments.
                                                              (line  22)
* #b:                                    Syntax of numerical constants.
                                                              (line  12)
* #b <1>:                                Lexical structure.   (line 157)
* #d:                                    Syntax of numerical constants.
                                                              (line  12)
* #e:                                    Syntax of numerical constants.
                                                              (line  16)
* #e <1>:                                Lexical structure.   (line 156)
* #f:                                    Booleans.            (line   7)
* #i:                                    Syntax of numerical constants.
                                                              (line  17)
* #i <1>:                                Lexical structure.   (line 156)
* #o:                                    Syntax of numerical constants.
                                                              (line  12)
* #o <1>:                                Lexical structure.   (line 158)
* #t:                                    Booleans.            (line   7)
* #x:                                    Syntax of numerical constants.
                                                              (line  12)
* #x <1>:                                Lexical structure.   (line 160)
* ':                                     Pairs and lists.     (line  88)
* ,:                                     Pairs and lists.     (line  88)
* ->:                                    Naming conventions.  (line  17)
* .:                                     Identifiers.         (line   9)
* ...:                                   Pattern language.    (line  54)
* =:                                     Numerical operations.
                                                              (line 150)
* =>:                                    Conditional.         (line  38)
* ?:                                     Naming conventions.  (line   6)
* abs:                                   Numerical operations.
                                                              (line 510)
* apply:                                 Proper tail recursion.
                                                              (line 118)
* begin:                                 Programs.            (line  19)
* begin <1>:                             Internal definitions.
                                                              (line  45)
* begin <2>:                             Library Syntax.      (line  58)
* body:                                  Syntax definitions.  (line  12)
* boolean?:                              Disjointness of types.
                                                              (line  23)
* bytevector-length:                     Implementation restrictions.
                                                              (line  31)
* bytevector?:                           Disjointness of types.
                                                              (line  23)
* call-with-current-continuation:        Proper tail recursion.
                                                              (line 119)
* call-with-current-continuation <1>:    Control features.    (line 316)
* call-with-values:                      Proper tail recursion.
                                                              (line 120)
* case-lambda:                           Internal definitions.
                                                              (line   9)
* char?:                                 Disjointness of types.
                                                              (line  23)
* complex?:                              Numerical types.     (line  18)
* complex? <1>:                          Numerical operations.
                                                              (line  59)
* cond:                                  Pattern language.    (line 177)
* cond-expand:                           Conditional.         (line 175)
* cond-expand <1>:                       Library Syntax.      (line  70)
* delay:                                 Delayed evaluation.  (line  31)
* delay-force:                           Delayed evaluation.  (line  31)
* dynamic-wind:                          Control features.    (line 205)
* else:                                  Conditional.         (line  84)
* eof-object?:                           Disjointness of types.
                                                              (line  23)
* eq?:                                   Procedures.          (line  72)
* eqv?:                                  Storage model.       (line  15)
* eqv? <1>:                              Procedures.          (line  71)
* eval:                                  Proper tail recursion.
                                                              (line 121)
* exact:                                 Exactness.           (line  40)
* except:                                Import declarations. (line  44)
* export:                                Library Syntax.      (line  39)
* force:                                 Delayed evaluation.  (line   9)
* guard:                                 Internal definitions.
                                                              (line   9)
* import:                                Library Syntax.      (line  53)
* include:                               Inclusion.           (line   9)
* include <1>:                           Library Syntax.      (line  58)
* include-ci:                            Inclusion.           (line  10)
* include-ci <1>:                        Library Syntax.      (line  58)
* include-library-declarations:          Library Syntax.      (line  64)
* integer?:                              Numerical types.     (line  18)
* lambda:                                Internal definitions.
                                                              (line   7)
* length:                                Implementation restrictions.
                                                              (line  30)
* let:                                   Iteration.           (line  60)
* let <1>:                               Pattern language.    (line 177)
* let <2>:                               Internal definitions.
                                                              (line   7)
* let*:                                  Internal definitions.
                                                              (line   7)
* let*-values:                           Internal definitions.
                                                              (line   8)
* let-syntax:                            Internal definitions.
                                                              (line   8)
* let-values:                            Internal definitions.
                                                              (line   8)
* letrec:                                Internal definitions.
                                                              (line   7)
* letrec*:                               Internal definitions.
                                                              (line   7)
* letrec-syntax:                         Internal definitions.
                                                              (line   8)
* make-promise:                          Delayed evaluation.  (line  31)
* nil:                                   Booleans.            (line  19)
* number?:                               Disjointness of types.
                                                              (line  23)
* number? <1>:                           Numerical types.     (line  18)
* number? <2>:                           Numerical operations.
                                                              (line  60)
* only:                                  Import declarations. (line  44)
* pair?:                                 Disjointness of types.
                                                              (line  23)
* parameterize:                          Internal definitions.
                                                              (line   9)
* port?:                                 Disjointness of types.
                                                              (line  23)
* prefix:                                Import declarations. (line  44)
* procedure?:                            Disjointness of types.
                                                              (line  23)
* quasiquote:                            Pairs and lists.     (line  90)
* quote:                                 Pairs and lists.     (line  90)
* raise:                                 Exception handling.  (line  14)
* rational?:                             Numerical types.     (line  18)
* read:                                  Pairs and lists.     (line  88)
* read <1>:                              External representation.
                                                              (line   6)
* real?:                                 Numerical types.     (line  18)
* rename:                                Import declarations. (line  26)
* rename <1>:                            Library Syntax.      (line  49)
* set-cdr!:                              Pairs and lists.     (line  70)
* string-length:                         Implementation restrictions.
                                                              (line  31)
* string-set!:                           Symbols.             (line  50)
* string?:                               Disjointness of types.
                                                              (line  23)
* symbol->string:                        Storage model.       (line  32)
* symbol?:                               Disjointness of types.
                                                              (line  23)
* syntax-rules:                          Syntax definitions.  (line  11)
* unquote:                               Pairs and lists.     (line  90)
* unquote-splicing:                      Pairs and lists.     (line  91)
* values:                                Procedure calls.     (line  26)
* vector-length:                         Implementation restrictions.
                                                              (line  30)
* vector?:                               Disjointness of types.
                                                              (line  23)
* write:                                 Quasiquotation.      (line  94)
* zero?:                                 Numerical operations.
                                                              (line 150)

References
==========

 [index ]
* Menu:

* bawden88:                              Bibliography.        (line  10)
* cltl:                                  Bibliography.        (line 135)
* gasbichlerknauelsperberkelsey2003:     Bibliography.        (line 153)
* howtoprint:                            Bibliography.        (line  17)
* howtoread:                             Bibliography.        (line  22)
* hygienic:                              Bibliography.        (line  87)
* ieee:                                  Bibliography.        (line  70)
* ieeescheme:                            Bibliography.        (line  73)
* kohlbecker86:                          Bibliography.        (line  83)
* life:                                  Bibliography.        (line  66)
* macrosthatwork:                        Bibliography.        (line  39)
* mccarthy:                              Bibliography.        (line  92)
* mitscheme:                             Bibliography.        (line  96)
* naur63:                                Bibliography.        (line  99)
* penfield81:                            Bibliography.        (line 103)
* propertailrecursion:                   Bibliography.        (line  27)
* r3rs:                                  Bibliography.        (line 117)
* r4rs:                                  Bibliography.        (line  43)
* r5rs:                                  Bibliography.        (line  79)
* r6rs:                                  Bibliography.        (line 131)
* rabbit:                                Bibliography.        (line 128)
* rees82:                                Bibliography.        (line 108)
* rees84:                                Bibliography.        (line 113)
* rfc2119:                               Bibliography.        (line  14)
* rrrs:                                  Bibliography.        (line  34)
* scheme311:                             Bibliography.        (line  57)
* scheme75:                              Bibliography.        (line 138)
* scheme78:                              Bibliography.        (line 124)
* scheme84:                              Bibliography.        (line  62)
* sicp:                                  Bibliography.        (line   6)
* srfi1:                                 Bibliography.        (line 121)
* srfi4:                                 Bibliography.        (line  54)
* srfi45:                                Bibliography.        (line 149)
* srfi6:                                 Bibliography.        (line  31)
* srfi9:                                 Bibliography.        (line  76)
* stoy77:                                Bibliography.        (line 142)
* syntacticabstraction:                  Bibliography.        (line  50)
* tai:                                   Bibliography.        (line 159)
* timanual85:                            Bibliography.        (line 146)
* uax44:                                 Bibliography.        (line  47)



Tag Table:
Node: Top2238
Node: Introduction5424
Node: Background7274
Node: Acknowledgments10118
Node: Overview of Scheme12997
Node: Semantics13209
Node: Syntax16183
Node: Notation and terminology17020
Node: Base and optional features17322
Node: Error situations and unspecified behavior18858
Node: Entry format22098
Node: Evaluation examples26335
Node: Naming conventions27038
Node: Lexical conventions28146
Node: Identifiers28564
Node: Whitespace and comments31832
Node: Other notations33396
Node: Datum labels35886
Node: Basic concepts37465
Node: Variables; syntactic keywords; and regions37756
Node: Disjointness of types40320
Node: External representations41362
Node: Storage model43731
Node: Proper tail recursion46161
Node: Expressions51951
Node: Primitive expression types52721
Node: Variable references53049
Node: Literal expressions53648
Node: Procedure calls55833
Node: Procedures57958
Node: Conditionals61177
Node: Assignments62089
Node: Inclusion62778
Node: Derived expression types63808
Node: Conditional64475
Node: Binding constructs72547
Node: Sequencing81365
Node: Iteration82979
Node: Delayed evaluation86263
Node: Dynamic bindings92016
Node: Exception handling95533
Node: Quasiquotation97096
Node: Case-lambda101034
Node: Macros102440
Node: Binding constructs for syntactic keywords104654
Node: Pattern language107560
Node: Signaling errors in macro transformers115747
Node: Program structure116929
Node: Programs117223
Node: Import declarations119154
Node: Variable definitions121154
Node: Top level definitions122176
Node: Internal definitions123014
Node: Multiple-value definitions124862
Node: Syntax definitions125801
Node: Record-type definitions127973
Node: Libraries131754
Node: Library Syntax132142
Node: Library example136658
Node: The REPL139923
Node: Standard procedures141315
Node: Equivalence predicates142758
Node: Numbers153940
Node: Numerical types154613
Node: Exactness155785
Node: Implementation restrictions158537
Node: Implementation extensions163081
Node: Syntax of numerical constants166664
Node: Numerical operations169265
Node: Numerical input and output191176
Node: Booleans194924
Node: Pairs and lists196987
Node: Symbols210079
Node: Characters213002
Node: Strings219892
Node: Vectors230143
Node: Bytevectors236337
Node: Control features241280
Node: Exceptions257275
Node: Environments and evaluation262073
Node: Input and output265746
Node: Ports265963
Node: Input273318
Node: Output280296
Node: System interface284672
Node: Formal syntax and semantics291971
Node: Formal syntax292355
Node: Lexical structure293231
Node: External representation299372
Node: Expression300157
Node: Quasiquotations303359
Node: Transformers304720
Node: Programs and definitions306067
Node: Librarie307066
Node: Formal semantics308257
Node: Derived expression type308823
Node: Standard Libraries327235
Node: Standard Feature Identifiers342614
Node: Language changes344106
Node: Incompatibilities with R^{5}RS344381
Node: Other language changes since R^{5}RS346370
Node: Incompatibilities with R^{6}RS355042
Node: Additional material359044
Node: Example359704
Node: Bibliography363405
Node: Index370577

End Tag Table


Local Variables:
coding: utf-8
End:
